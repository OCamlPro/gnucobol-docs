This is gnucobpg.info, produced by makeinfo version 7.2 from
gnucobpg.texi.

This manual documents GnuCOBOL 3.2 - Final, 11th January 2025 at 17:40
GMT.  build.


   Document: Copyright 2009-2014 Gary L. Cutler & FSF (Free Software
Foundation).
Updates : Copyright 2014-2025 Vincent B. Coen & FSF.
Contributions: Eugenio Di Lorenzo 2024 - 2025.

     The authors and copyright holders of the COBOL programming language
     itself used herein:

     FLOW-MATIC (trademark for Sperry Rand Corporation) Programming for
     the Univac(R) I & II. Data Automation Systems copyrighted 1958,
     1959, by Sperry Rand Corporation; IBM commercial translator form
     F28-8013, copyrighted 1959 by IBM; FACT DSI27A5260-2760,
     copyrighted 1960 by Minneapolis-Honeywell, have specifically
     authorised the use of this material in whole or in part of the
     COBOL specifications.  Such authorisation extends to the
     reproduction & use of COBOL specifications in programming manuals
     or similar publications.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License
     [FDL], Version 1.3 or any later version published by the Free
     Software Foundation; with Invariant Section "Introduction", no
     Front-Cover Texts, and no Back-Cover Texts.  A copy of the license
     is included in the section entitled "GNU Free Documentation
     License".

     Permission is granted to make and distribute verbatim copies of
     this manual provided the copyright notice and this permission
     notice are preserved on all copies.

     Permission is granted to copy and distribute modified versions of
     this manual under the conditions for verbatim copying, provided
     that the entire resulting derived work is distributed under the
     terms of a permission notice identical to this one.

     Permission is granted to copy and distribute translations of this
     manual into another language, under the above conditions for
     modified versions, except that this permission notice may be stated
     in a translation approved by the Free Software Foundation.

INFO-DIR-SECTION GNU-COBOL
START-INFO-DIR-ENTRY
* GNU-COBOL: (gnucobpg)        GnuCOBOL Programmer's Guide
END-INFO-DIR-ENTRY


File: gnucobpg.info,  Node: SYSTEM,  Next: X"91",  Prev: EXTFH,  Up: Built-In System Subroutines

8.2.61 SYSTEM
-------------

                   SYSTEM Built-In Subroutine Syntax
=======================================================================

 CALL "SYSTEM" USING command
 ~~~~          ~~~~~


=======================================================================
   This subroutine submits COMMAND (an alphanumeric literal or data
item) to a command shell for execution as if it were typed into a
console/terminal window.

   A shell will be opened subordinate to the GnuCOBOL program issuing
the call to ‘SYSTEM’.

   Output from the command (if any) will appear in the command window in
which the GnuCOBOL program was executed.

   On a Unix system, the shell environment will be established using the
default shell program.  This is also true when using a GnuCOBOL build
created with and for OSX or the Cygwin Unix emulator.

   With native Windows Windows/MinGW builds, the shell environment will
be the Windows console window command processor (usually ‘cmd.exe’)
appropriate for the version of Windows you're using.

   To trap output from the executed command and process it within the
GnuCOBOL program, use a redirection (‘>’) to send the command output to
a temporary file which you read from within the program once control
returns.

   The exit status of the executed command will be available in the
‘RETURN-CODE’ special-register.



File: gnucobpg.info,  Node: X"91",  Next: X"E4",  Prev: SYSTEM,  Up: Built-In System Subroutines

8.2.62 X"91"
------------

                   X"91" Built-In Subroutine Syntax
=======================================================================

 CALL X"91" USING return-code, function-code, binary-variable-arg
 ~~~~       ~~~~~


=======================================================================
   The original Micro Focus version of this routine is capable of
providing a wide variety of functions.  GnuCOBOL supports just three of
them but more on the way subject to version of compiler (see file NEWS):
   • Turning runtime switches (‘SWITCH-1’, ... , ‘SWITCH-8’) on.

   • Turning runtime switches (‘SWITCH-1’, ... , ‘SWITCH-8’) off.

   • Retrieving the number of arguments passed to a subroutine.

   The RETURN-CODE argument must be a one-byte binary numeric data item
(‘USAGE BINARY-CHAR’ is recommended).  It will receive a value of 0 if
the operation was successful, 1 otherwise.

   The FUNCTION-CODE argument must be either a numeric literal or a
one-byte binary numeric data item (‘USAGE BINARY-CHAR’ is recommended).

   The third argument -- VARIABLE-ARG -- is defined differently
depending upon the FUNCTION-CODE value, as follows:

11
     Sets and/or clears all eight of the COBOL switches (‘SWITCH-1’
     through ‘SWITCH-8’).  *Note SPECIAL-NAMES::, for an explanation of
     those switches.  Also referred to as programmable 0 - 7.

     The VARIABLE-ARG argument should be an ‘OCCURS 8 TIMES’ table of
     ‘USAGE BINARY-CHAR’.

     Each occurrence that is set to a value of zero prior to the ‘CALL
     X"91"’ will cause the corresponding switch to be cleared.  Each
     occurrence set to 1 prior to the ‘CALL X"91"’ will cause the
     corresponding switch to be set.

     Values other than 0 or 1 will be ignored.

12
     Reads all eight of the COBOL switches (‘SWITCH-1’ through
     ‘SWITCH-8’) and debug switches as prorammable 0 - 7.

     The VARIABLE-ARG argument should be an ‘OCCURS 8 TIMES’ table of
     ‘USAGE BINARY-CHAR’.

     Each of the 1^{st} eight occurrences of the array will be set to
     either 0 or 1 -- 1 if the corresponding switch is set, 0 otherwise.

13 + 14
     Allow access to runtime switches 1 - 26 as A-Z. In case of A.N.T:
     set related runtime setting.  Option 13 read them and option 14
     sets them.

15
     Prepare for program lookup.  Checks to see if a program exists.
     You pass the program name and its length in parameter.  When
     routine exits, result is zero if found and non-zero if not.
     Parameter is a group item consisting of two data items: a PIC X
     COMP-X specifyinh length in bytes of data item containing the file
     name and PIC X data item of varaiable length containing the file
     name.

16
     Retrieves the number of arguments passed to the program executing
     the ‘CALL X"91"’, saving that number into the VARIABLE-ARG
     argument.  That should be a binary numeric data item (‘USAGE
     BINARY-CHAR’ is recommended).

35
     Prepare for DOS EXEC call.

46-49
     Prepare for file specific settings LS_NULLS/LS_TABS.

69
     Prepare for directory search.



File: gnucobpg.info,  Node: X"E4",  Next: X"E5",  Prev: X"91",  Up: Built-In System Subroutines

8.2.63 X"E4"
------------

                   X"E4" Built-In Subroutine Syntax
=======================================================================

 CALL X"E4"
 ~~~~


=======================================================================
   Use ‘X"E4"’ to clear the screen.  There are no arguments and no
returned value.


File: gnucobpg.info,  Node: X"E5",  Next: X"F4",  Prev: X"E4",  Up: Built-In System Subroutines

8.2.64 X"E5"
------------

                   X"E5" Built-In Subroutine Syntax
=======================================================================

 CALL X"E5"
 ~~~~


=======================================================================
   The ‘X"E5"’ routine will sound the PC "bell".  There are no arguments
and no returned value.


File: gnucobpg.info,  Node: X"F4",  Next: X"F5",  Prev: X"E5",  Up: Built-In System Subroutines

8.2.65 X"F4"
------------

                   X"F4" Built-In Subroutine Syntax
=======================================================================

 CALL X"F4" USING byte, table
 ~~~~       ~~~~~


=======================================================================
   This routine packs the low-order (rightmost) bit from each of the
eight 1-byte items in TABLE into the corresponding bit positions of the
single-byte data item BYTE.

   The BYTE data item need be only a single byte in size.  If it is
longer, the excess will be unaffected by this subroutine.

   The TABLE data item must be at least 8 bytes long.  If it is longer,
the excess will be ignored by this subroutine.

   Typically, table is defined similarly to the following:

     01  Table-Arg.
         05 Each-Byte OCCURS 8 TIMES USAGE BINARY-CHAR.


File: gnucobpg.info,  Node: X"F5",  Prev: X"F4",  Up: Built-In System Subroutines

8.2.66 X"F5"
------------

                   X"F5" Built-In Subroutine Syntax
=======================================================================

 CALL X"F5" USING byte, table
 ~~~~       ~~~~~


=======================================================================
   This routine unpacks each bit of the single-byte data item BYTE into
the low-order (rightmost) bit of each of the corresponding eight 1-byte
items in TABLE.  The other seven bit positions of each of the first
eight entries in TABLE will be set to zero.

   The BYTE data item need be only a single byte in size.  If it is
longer, the excess will be unaffected by this subroutine.

   The TABLE data item must be at least 8 bytes long.  If it is longer,
the excess will be ignored by this subroutine.

   Typically, table is defined similarly to the following:

     01  Table-Arg.
         05 Each-Byte OCCURS 8 TIMES USAGE BINARY-CHAR.



File: gnucobpg.info,  Node: Report Writer Usage,  Next: Interfacing With The OS,  Prev: Functions,  Up: Top

9 Report Writer Usage
*********************

* Menu:

* RWCS Lexicon.
* The Anatomy of a Report.
* The Anatomy of a Report Page.
* How RWCS Builds Report Pages.
* Control Hierarchy.
* An Example.
* Data.
* Program.
* Generated Report Pages.
* Control Hierarchy (Revisited).
* Turning PHYSICAL Page Formatting Into LOGICAL Formatting.


File: gnucobpg.info,  Node: RWCS Lexicon,  Next: The Anatomy of a Report,  Up: Report Writer Usage

9.1 RWCS Lexicon
================

There are a number of terms that describe various aspects of the
operation of the Report Writer Control System (RWCS). Understanding the
meanings of these terms is vital to developing an understanding of the
subject.
Control Break
     An event that is triggered when a control field on an
     RWCS-generated report changes value.  It is these events that
     trigger the generation of control heading and control footing
     groups.

Control Field
     A field of data being presented within a detail group; as the
     various detail groups that comprise the report are presented, they
     are presumed to appear in sorted sequence of the control fields
     contained within them.  As an example, a department-by-department
     sales report for a chain of stores would probably be sorted by
     store number and - within like store numbers - be further sorted by
     department number.  The store number will undoubtedly serve as a
     control field for the report, allowing control heading groups to be
     presented before each sequence of detail groups for the same store
     and control footing groups to be presented after each such
     sequence.

Control Footing
     A report group that appears immediately after one or more detail
     groups of an RWCS-generated report.  Such are produced
     automatically as a result of a control break.  This type of group
     typically serves as a summary of the detail group(s) that precede
     it, as might be the case on a sales report for a chain of stores,
     where the detail groups documenting sales for each department (one
     department per detail group) from the same store might be followed
     by a control footing that provides a summation of the
     department-by-department sales for that store.

Control Heading
     A report group that appears immediately before one or more detail
     groups of an RWCS-generated report.  Such are produced
     automatically as a result of a control break.  This type of group
     typically serves as an introduction to the detail group(s) that
     follow, as might be the case on a sales report for a chain of
     stores, where the detail groups documenting sales for each
     department (one department per detail group) from the same store
     might be preceded by a control heading that states the full name
     and location of the store.

Detail Group
     A report group that contains the detailed data being presented for
     the report.

Page Footing
     A report group that appears at the bottom of every page of an
     RWCS-generated report.  Information typically found within such a
     report group might be:
        • The date the report was generated
        • The current page number of the report
Page Heading
     A report group that appears at the top of every page of an
     RWCS-generated report.  Information typically found within such a
     report group might be:
        • A title for the report
        • The date the report was generated
        • The current page number of the report
        • Column headings describing the fields within the detail
          group(s)
Report Footing
     A report group that occurs only once in an RWCS-generated report --
     as the very last presented report group of the report.  These
     typically serve as a visual indication that the report is finished.

Report Group
     One or more consecutive lines on a report that serve a common
     informational purpose or function.  For example, lines of text that
     are displayed at the top or bottom of every printed page of a
     report.

Report Heading
     A report group that occurs only once in an RWCS-generated report --
     as the very first presented report group of the report.  These
     typically serve as an introduction to the report.


File: gnucobpg.info,  Node: The Anatomy of a Report,  Next: The Anatomy of a Report Page,  Prev: RWCS Lexicon,  Up: Report Writer Usage

9.2 The Anatomy of a Report
===========================

Every report has the same basic structure, as shown here, even though
not all reports will have all of the groups shown.  In fact, it is a
very unusual report indeed that actually has every one of these groups:
   • REPORT HEADING
   • PAGE HEADING [1]
   • CONTROL HEADING(S) [2]
   • DETAIL GROUP(S) [2]
   • CONTROL FOOTING(S) [2]
   • FINAL CONTROL FOOTING
   • PAGE FOOTING [1]
   • REPORT FOOTING
[1]  Presented throughout the report, as needed
[2]  Repeated, as needed

   These groups will be presented (printed) across however many
formatted pages are necessary to hold them.  No single report group will
be allowed to cross page boundaries.

   The management of paging, enforcement of the groups cannot span pages
rule and almost every aspect of report generation are handled entirely
by the Report Writer Control System.


File: gnucobpg.info,  Node: The Anatomy of a Report Page,  Next: How RWCS Builds Report Pages,  Prev: The Anatomy of a Report,  Up: Report Writer Usage

9.3 The Anatomy of a Report Page
================================

Each page of a report is divided into as many as five (5) areas, as
shown in the following diagram.

  _______________________________
 |                               |
 | Top-of-page Unusable Area     |--# Lines: LINES AT TOP (LINAGE)
 |_______________________________|
 |                               |--Line #: HEADING (RD)
 | Heading Area                  |
 |_______________________________|--Line #: FIRST DETAIL (RD) - 1
 |                               |--Line #: FIRST DETAIL (RD)
 |                               |
 | Body Area                     |--Line #: LAST CONTROL HEADING (RD)
 |                               |--Line #: LAST DETAIL (RD)
 |_______________________________|--Line #: FOOTING (RD)
 |                               |--Line #: FOOTING (RD) + 1
 | Footing Area                  |
 |_______________________________|
 |                               |
 | Bottom-of-page Unusable Area  |--# Lines: LINES AT BOTTOM (LINAGE)
 |_______________________________|

   When describing a report via the ‘RD’ (*note REPORT SECTION::)
clause, the total number of usable lines are specified as the ‘PAGE
LIMIT’ value; this value is the sum of the number of lines contained in
the Heading, Body and Footing Areas.

   The unusable areas of a page (if any) will appear above and below
that usable area.  You don't specify the unusable area in the ‘RD’, but
rather using a ‘LINAGE’ (*note File/Sort-Description::) clause in the
‘FD’ of the file the report is "attached" to.

   The various report groups will be presentable in the various areas of
a page, as follows:
‘REPORT HEADING’
     Heading Area -- An exception to this is the situation where the
     report heading report group contains the ‘NEXT GROUP NEXT PAGE’
     (*note NEXT GROUP::) option; in those cases, the report heading
     will be presented on a page by itself (anywhere on that page) at
     the beginning of the report.

‘PAGE HEADING’
     Heading Area

‘CONTROL HEADING’
     Body Area, but no line of a control heading is allowed past the
     line number specified by ‘LAST CONTROL HEADING’

‘DETAIL’
     Body Area, but no line of a detail report group is allowed past the
     line number specified by ‘LAST DETAIL’

‘CONTROL FOOTING’
     Body Area, but no line of a control footing report group is allowed
     past the line number specified by ‘FOOTING’

‘PAGE FOOTING’
     Footing Area

‘REPORT FOOTING’
     Footing Area -- An exception to this is the situation where the
     report footing report group contains the ‘NEXT PAGE’ option in its
     ‘LINE’ (*note LINE::) clause; in those cases, the report footing
     will be presented on a page by itself at the end of the report.


File: gnucobpg.info,  Node: How RWCS Builds Report Pages,  Next: Control Hierarchy,  Prev: The Anatomy of a Report Page,  Up: Report Writer Usage

9.4 How RWCS Builds Report Pages
================================

A report created via a ‘WRITE’ statement (*note WRITE::) will contain
carriage-control information.  Most notably, ASCII form-feed characters
(X'0C') will be written to the report file to support the statement's
‘ADVANCING PAGE’ option.  Whether the data for a report line created via
‘ADVANCING PAGE’ occurs before or after the form-feed character depends
upon whether the programmer coded ‘WRITE RECORD-NAME BEFORE ADVANCING
PAGE’ or ‘WRITE RECORD-NAME AFTER ADVANCING PAGE’, respectively.

   The GnuCOBOL implementation of RWCS does not issue any
carriage-control information to the report files it produces -- instead,
it relies upon the information coded in the ‘RD’ for the report
(specifically the ‘PAGE LIMITS’ and related options) and its
internally-generated and managed ‘LINE-COUNTER’ special register (*note
Special Registers::) for the report to know when to issue any blank
lines to the file to fill-out the end of a printed page.

   Because this is the way the GnuCOBOL RWCS works, in order to design
an RWCS-generated report you'll need to know answers to the following
questions:
  1. What printer(s) will the report be printed on?

  2. What paper orientation will you use, -- Landscape (long edge of the
     paper at the top and bottom of page), or Portrait (long edge of the
     paper at the left and right of page)?

  3. What tool will be used to print the report (direct printing to the
     device, notepad.exe, MS-Word, ...)?

  4. What font and font size will be used for the report when it is
     printed?  RWCS-generated reports will assume that a fixed-width
     font such as "Courier", "Lucida Console", "Consolas" and the like
     will be used to print, as variable-pitch fonts would make the
     proper alignment of columns of data on reports virtually
     impossible.

  5. When unprintable area exists at all four margins of the paper?
     These are generally caused by the printer itself or by its software
     driver.

  6. What is the maximum number of lines per page that may be printed on
     a single sheet of paper?

  7. What is the maximum number of characters that may be printed on one
     line?

   Once you know the answer to questions 1-4, you may easily determine
the answers to the remaining questions as follows:
  1. Prepare a text file containing 100 or so records, each consisting
     of a numeric scale (‘123456789012345678901234’...).

  2. Print the file in a manner consistent with your answers to
     questions 1-4.

  3. Add any necessary additional digits to each record in your test
     file (if lines weren't full) or remove characters from the end of
     each record if lines wrapped.  If you made changes, reprint the
     file.

  4. Now that you know exactly how long each record may be, add
     additional records and reprint.  Continue until printing overflows
     to a second page.

  5. The first page you print is now a perfect template to use when
     designing reports -- it shows, given the answers to questions 1-4,
     every available printable character position on a page!  The number
     of lines printed on that page becomes your ‘PAGE LIMIT’ value for
     the ‘RD’.

   The remaining ‘PAGE LIMIT’ values can be established as required by
your report(s).

   Using IDENTIFIER rather than INTEGER specifications in the ‘RD’ will
give your program the ability -- at run time -- to accommodate multiple
printers, fonts, font sizes and paper orientation.  Just follow the
above steps for each combination you wish your program to support.


File: gnucobpg.info,  Node: Control Hierarchy,  Next: An Example,  Prev: How RWCS Builds Report Pages,  Up: Report Writer Usage

9.5 Control Hierarchy
=====================

Every report that employs control breaks has a natural hierarchy of
those control breaks based upon the manner in which the data the report
is being generated from is sorted.  This concept is best understood
using an example which assumes a COBOL program to process sales data
collected from every computerized cash register across a chain of stores
having multiple departments is being developed.

   The application that collects data from the various cash registers at
each store will generate data records that look like this to a COBOL
program:

     01  Sales-For-Register.
         05 Sales-Date            PIC 9(8).
         05 Time-Collected        PIC 9(6).
         05 Register-Number       PIC 9(7).
         05 Store-Number          PIC 9(3).
         05 Department-Number     PIC 9(3).
         05 Total-Sales           PIC 9(6)V99.

   Your task is to develop a report that shows the sales total from each
cash register and summarizes those sales by department within each
store, by store and also generates a total sales figure for the day
across all stores.

   To accomplish this, you will use a ‘SORT’ statement (*note SORT::) to
sort the file of cash register sales data into:
  1. Ascending sequence of store number
  2. Within each store, data will be sorted into ascending sequence of
     department number
  3. If there are multiple cash registers in a particular department of
     a specific store, the data needs to be further sorted so that the
     cash registers are ordered in sequence of their register number.

   So, assuming a sort file has been defined and its record layout
(essentially a mirror of the raw data file) is defined as follows:

     01  Sorted-Sales-For-Register.
         05 Sorted-Sales-Date            PIC 9(8).
         05 Sorted-Time-Collected        PIC 9(6).
         05 Sorted-Register-Number       PIC 9(7).
         05 Sorted-Store-Number          PIC 9(3).
         05 Sorted-Department-Number     PIC 9(3).
         05 Sorted-Total-Sales           PIC 9(6)V99.

   Then the ‘SORT’ statement to accomplish the desired sequencing would
be:

     SORT SORT-FILE
         ASCENDING KEY Sorted-Store-Number
                       Sorted-Department-Number
                       Sorted-Register-Number
         USING Input-file
         OUTPUT PROCEDURE 100-Generate-Report

   As a result of the sort, our program might expect to see data
somewhat like this (date, time and sales totals are shown as "..."):

        +-------------------- Register Number
        |      +------------- Store Number
        |      |  +---------- Department Number
        |      |  |
     ...0535240001001...
     ...0589130001001...
     ...0625174001001...
     ...0122234001002...
     ...0732345001002...
     ...0003423001003...
     ...2038774001004...
     ...0112646002001...
     ...9963348002002...
     ...3245677002003...
     ...4456778002003...
     ...0002345002004...

   Because of the sort, the most-frequently changing value of the three
sort keys will be that of ‘Sorted-Register-Number’.  This essentially
defines the "detail" level of the report.

   The next most-frequently changing value is that of
‘Sorted-Department-Number’, and the least-frequently changing value is
that of ‘Sorted-Store-Number’.  remember that the program should be
generating totals each time one of these two values change, plus a grand
total of sales at the end of the report.  These three points are the
“Control Break” points of the report.

   When the report is defined, it's ‘RD’ would contain a ‘CONTROLS ARE’
clause that lists the control breaks in least- to most-frequent sequence
of changing.  This would be coded as:

   ‘CONTROLS ARE FINAL, Sorted-Store-Number, Sorted-Department-Number’

   A ‘FINAL’ control break only occurs once, at the very end of the
report.  The ‘CONTROL FOOTING’ for this break will be the one that
produces the grand total of sales for all stores.

   The next break listed on the ‘CONTROLS’ clause will be the one that
occurs next most-frequently (‘Sorted-Store-Number’).  This control break
will be the one that produces the summation for each entire store, and
will have its own ‘CONTROL FOOTING’.

   The next (and last, in this case) break listed on the ‘CONTROLS’
clause will be the one that occurs even more frequently
(‘Sorted-Department-Number’).  The ‘CONTROL FOOTING’ for this control
field will be the one that summarizes sales for each department within a
store.

   This sequence of control breaks from least- to most-frequent (in
other words, in the order they occur on the ‘CONTROLS ARE’ clause) is
the 'control hierarchy' of the report; control breaks that occur more
frequently than others are said to be at a lower level in the control
hierarchy.

   Defining a control hierarchy (via ‘CONTROLS ARE’) that does not match
the actual sequence in which data will be processed is a great way to
guarantee a "broken" report.  I'll show you an example in a later
section.


File: gnucobpg.info,  Node: An Example,  Next: Control Hierarchy (Revisited),  Prev: Control Hierarchy,  Up: Report Writer Usage

9.6 An Example
==============

This section contains an example of the RWCS at work.  The complete
program, presented here, is a stripped-down version of a program I have
used to generate a report for a class I teach on PC hardware.  This
report will provide benchmark statistics on a variety of popular AMD and
Intel CPUs.  The data for the report was obtained from the website
<www.cpubenchmark.net> in December of 2013.  By the time you are reading
this, that data will most likely have become rather out of date, but it
illustrates RWCS well enough.
* Menu:

* Data.
* Program.
* Generated Report Pages.


File: gnucobpg.info,  Node: Data,  Next: Program,  Up: An Example

9.6.1 Data
----------

Here is the data that the program will be reading.  Each record reflects
the aggregated benchmark scoring for one particular CPU, as scores for
benchmarks against that CPU have been reported to the <cpubenchmark.net>
website by their PassMark benchmark software.  The data consists of four
fields.  Fields are separated from one another by a single comma.  The
descriptions of the fields are as follows:
Benchmark Score
     A five-digit number showing the aggregated benchmark scores for the
     CPU; the higher this number, the better the CPU performed in
     benchmark testing.

Vendor
     The name of the vendor who makes the CPU. In this data, that will
     either be "AMD" (American Micro Devices) or "INTEL".

Family
     The 7-character family of CPU products the CPU falls into.  This
     will have values such as "A4", "A10", "Core i5", "Core i7", etc.

Model
     The specific model of CPU within the family.

   The first record of data shown below shows that the aggregated score
of all benchmarks reported for the AMD A10-4600M CPU is 3145, as
compared to the second record which shows that the aggregated score
reported of all benchmarks reported for the Intel Core-i7-4960X CPU is
14291.

   The following is the complete set of input data used for this
example.  This is by no means the complete set of data available at
<cpubenchmark.net> -- it is just a representative sample used for this
example.  For my class, I give my students a report showing the results
for almost a thousand CPUs.

   For the sake of brevity, this document lists the data in three
columns.

03145,AMD,A10,4600M            05421,AMD,FX,6100              03917,Intel,Core i5,4300U
14291,Intel,Core i7,4960X      05813,AMD,FX,6120              01743,Intel,Core i5,4300Y
02505,AMD,A10,4655M            06194,AMD,FX,6200              04804,Intel,Core i5,4330M
03449,AMD,A10,4657M            06388,AMD,FX,6300              03604,Intel,Core i5,4350U
04251,AMD,A10,5700             07017,AMD,FX,6350              06282,Intel,Core i5,4430
02758,AMD,A10,5745M            06163,AMD,FX,8100              05954,Intel,Core i5,4430S
03332,AMD,A10,5750M            06605,AMD,FX,8120              06517,Intel,Core i5,4440
03253,AMD,A10,5757M            06845,AMD,FX,8140              07061,Intel,Core i5,4570
04798,AMD,A10,5800B            07719,AMD,FX,8150              06474,Intel,Core i5,4570R
04677,AMD,A10,5800K            08131,AMD,FX,8320              06803,Intel,Core i5,4570S
04767,AMD,A10,6700             09067,AMD,FX,8350              02503,Intel,Core i5,4570T
05062,AMD,A10,6800K            09807,AMD,FX,9370              07492,Intel,Core i5,4670
00677,AMD,A4,1200              10479,AMD,FX,9590              07565,Intel,Core i5,4670K
00559,AMD,A4,1250              03076,Intel,Core i3,3110M      06351,Intel,Core i5,4670T
01583,AMD,A4,3300              03301,Intel,Core i3,3120M      03701,Intel,Core i7,3517U
01237,AMD,A4,3300M             03655,Intel,Core i3,3130M      03449,Intel,Core i7,3517UE
01227,AMD,A4,3305M             03820,Intel,Core i3,3210       04588,Intel,Core i7,3520M
01263,AMD,A4,3310MX            02266,Intel,Core i3,3217U      03912,Intel,Core i7,3537U
01193,AMD,A4,3320M             04219,Intel,Core i3,3220       04861,Intel,Core i7,3540M
01343,AMD,A4,3330MX            03724,Intel,Core i3,3220T      04009,Intel,Core i7,3555LE
01625,AMD,A4,3400              04407,Intel,Core i3,3225       06144,Intel,Core i7,3610QE
01768,AMD,A4,3420              02575,Intel,Core i3,3227U      07532,Intel,Core i7,3610QM
01685,AMD,A4,4300M             01885,Intel,Core i3,3229Y      06988,Intel,Core i7,3612QE
01169,AMD,A4,4355M             04259,Intel,Core i3,3240       06907,Intel,Core i7,3612QM
01919,AMD,A4,5000              03793,Intel,Core i3,3240T      05495,Intel,Core i7,3615QE
01973,AMD,A4,5150M             04414,Intel,Core i3,3245       07310,Intel,Core i7,3615QM
02078,AMD,A4,5300              04757,Intel,Core i3,3250       07759,Intel,Core i7,3630QM
01632,AMD,A4,5300B             03443,Intel,Core i3,4000M      07055,Intel,Core i7,3632QM
02305,AMD,A4,6300              02459,Intel,Core i3,4010U      06516,Intel,Core i7,3635QM
01634,AMD,A6,1450              02003,Intel,Core i3,4010Y      04032,Intel,Core i7,3667U
01964,AMD,A6,3400M             04904,Intel,Core i3,4130       04271,Intel,Core i7,3687U
02101,AMD,A6,3410MX            04041,Intel,Core i3,4130T      03479,Intel,Core i7,3689Y
02078,AMD,A6,3420M             05115,Intel,Core i3,4330       08347,Intel,Core i7,3720QM
02277,AMD,A6,3430MX            05117,Intel,Core i3,4340       08512,Intel,Core i7,3740QM
01995,AMD,A6,3500              03807,Intel,Core i5,3210M      09420,Intel,Core i7,3770
02798,AMD,A6,3600              03995,Intel,Core i5,3230M      09578,Intel,Core i7,3770K
02892,AMD,A6,3620              03126,Intel,Core i5,3317U      09074,Intel,Core i7,3770S
03232,AMD,A6,3650              04101,Intel,Core i5,3320M      08280,Intel,Core i7,3770T
03327,AMD,A6,3670              05902,Intel,Core i5,3330       08995,Intel,Core i7,3820
01630,AMD,A6,4400M             05690,Intel,Core i5,3330S      08548,Intel,Core i7,3820QM
01296,AMD,A6,4455M             05781,Intel,Core i5,3335S      09025,Intel,Core i7,3840QM
02440,AMD,A6,5200              03280,Intel,Core i5,3337U      09196,Intel,Core i7,3920XM
01958,AMD,A6,5350M             02252,Intel,Core i5,3339Y      12107,Intel,Core i7,3930K
01878,AMD,A6,5357M             06282,Intel,Core i5,3340       09052,Intel,Core i7,3940XM
01906,AMD,A6,5400B             04327,Intel,Core i5,3340M      12718,Intel,Core i7,3960X
02174,AMD,A6,5400K             05372,Intel,Core i5,3340S      12823,Intel,Core i7,3970X
02384,AMD,A6,6400K             06199,Intel,Core i5,3350P      03992,Intel,Core i7,4500U
02050,AMD,A8,3500M             04314,Intel,Core i5,3360M      04507,Intel,Core i7,4558U
02426,AMD,A8,3510MX            04555,Intel,Core i5,3380M      04892,Intel,Core i7,4600M
02245,AMD,A8,3520M             03589,Intel,Core i5,3427U      04484,Intel,Core i7,4600U
02276,AMD,A8,3530MX            03479,Intel,Core i5,3437U      03680,Intel,Core i7,4610Y
02866,AMD,A8,3550MX            03057,Intel,Core i5,3439Y      04345,Intel,Core i7,4650U
03215,AMD,A8,3800              06442,Intel,Core i5,3450       07352,Intel,Core i7,4700EQ
03217,AMD,A8,3820              06071,Intel,Core i5,3450S      08161,Intel,Core i7,4700HQ
03552,AMD,A8,3850              06576,Intel,Core i5,3470       07946,Intel,Core i7,4700MQ
03682,AMD,A8,3870K             06077,Intel,Core i5,3470S      08002,Intel,Core i7,4702HQ
02709,AMD,A8,4500M             04591,Intel,Core i5,3470T      07647,Intel,Core i7,4702MQ
02193,AMD,A8,4555M             05991,Intel,Core i5,3475S      08066,Intel,Core i7,4750HQ
04052,AMD,A8,5500              06828,Intel,Core i5,3550       07367,Intel,Core i7,4765T
03464,AMD,A8,5500B             06631,Intel,Core i5,3550S      09969,Intel,Core i7,4770
02434,AMD,A8,5545M             06993,Intel,Core i5,3570       10190,Intel,Core i7,4770K
03052,AMD,A8,5550M             07118,Intel,Core i5,3570K      09803,Intel,Core i7,4770S
02935,AMD,A8,5557M             06709,Intel,Core i5,3570S      08803,Intel,Core i7,4770T
04348,AMD,A8,5600K             05414,Intel,Core i5,3570T      10078,Intel,Core i7,4771
04390,AMD,A8,6500              04333,Intel,Core i5,4200M      08567,Intel,Core i7,4800MQ
04719,AMD,A8,6600K             03355,Intel,Core i5,4200U      09969,Intel,Core i7,4820K
04055,AMD,FX,4100              02358,Intel,Core i5,4200Y      09331,Intel,Core i7,4850HQ
04153,AMD,FX,4130              02382,Intel,Core i5,4210Y      09323,Intel,Core i7,4900MQ
04094,AMD,FX,4150              03482,Intel,Core i5,4250U      13620,Intel,Core i7,4930K
04774,AMD,FX,4170              04381,Intel,Core i5,4258U      09754,Intel,Core i7,4930MX
04711,AMD,FX,4300              04663,Intel,Core i5,4288U      10262,Intel,Core i7,4960HQ
05247,AMD,FX,4350              04786,Intel,Core i5,4300M


File: gnucobpg.info,  Node: Program,  Next: Generated Report Pages,  Prev: Data,  Up: An Example

9.6.2 Program
-------------

Here is the program that will be producing the report.  Pay attention to
how the data is sorted and how the control hierarchy (‘CONTROLS ARE’)
relates to the ‘SORT’.

     IDENTIFICATION DIVISION.
     PROGRAM-ID. DEMORWCS.
     ENVIRONMENT DIVISION.
     CONFIGURATION SECTION.
     REPOSITORY. FUNCTION ALL INTRINSIC.
     INPUT-OUTPUT SECTION.
     FILE-CONTROL.
         SELECT CPU-FILE             ASSIGN TO "CPUDATA.txt"
                                     LINE SEQUENTIAL.
         SELECT REPORT-FILE          ASSIGN TO "CPUREPORT.txt"
                                     LINE SEQUENTIAL.
         SELECT SORT-FILE            ASSIGN TO DISK.
     DATA DIVISION.
     FILE SECTION.
     FD  CPU-FILE.
     01  CPU-REC                     PIC X(26).

     FD  REPORT-FILE
         REPORT IS CPU-Report.

     SD  SORT-FILE.
     01  SORT-REC.
         05 F-SR-Score-NUM           PIC 9(5).
         05 F-SR-Vendor-TXT          PIC X(5).
         05 F-SR-Family-TXT          PIC X(7).
         05 F-SR-Model-TXT           PIC X(6).
     WORKING-STORAGE SECTION.
     01  WS-Date                     PIC 9(8).

     01  WS-Family-Counters.
         05 WS-FC-AVE                PIC 9(5)V99.
         05 WS-FC-Qty                BINARY-LONG.
         05 WS-FC-Total-NUM          BINARY-LONG.

     01  WS-Flags.
         05 WS-F-EOF                 PIC X(1).

     01  WS-One-Const                PIC 9 VALUE 1.

     01  WS-Overall-Counters.
         05 WS-OC-AVE                PIC 9(5)V99.
         05 WS-OC-Qty                BINARY-LONG.
         05 WS-OC-Total-NUM          BINARY-LONG.

     01  WS-Starz                    PIC X(44) VALUE ALL '*'.

     01  WS-Vendor-Counters.
         05 WS-VC-AVE                PIC 9(5)V99.
         05 WS-VC-Qty                BINARY-LONG.
         05 WS-VC-Total-NUM          BINARY-LONG.

     REPORT SECTION.
     RD  CPU-Report
         CONTROLS ARE FINAL
                      F-SR-Vendor-TXT
                      F-SR-Family-TXT

         PAGE LIMIT IS    36 LINES
             HEADING      1
             FIRST DETAIL 5
             LAST DETAIL  36.

     01  TYPE IS PAGE HEADING.
         05 LINE NUMBER PLUS 1.
            10 COL 1  SOURCE WS-Date                PIC 9999/99/99.
            10 COL 14 VALUE 'CPU Benchmark Scores'.
            10 COL 37 VALUE 'Page:'.
            10 COL 43 SOURCE PAGE-COUNTER           PIC Z9.
         05 LINE NUMBER PLUS 1.
            10 COL 1  SOURCE WS-Starz               PIC X(44).
         05 LINE NUMBER PLUS 1.
            10 COL 1  VALUE '**'.
            10 COL 6  VALUE 'All CPU Data From cpubenchmark.net'.
            10 COL 43 VALUE '**'.
         05 LINE NUMBER PLUS 1.
            10 COL 1  SOURCE WS-Starz               PIC X(44).

     01  TYPE CONTROL HEADING F-SR-Family-TXT.
         05 LINE NUMBER PLUS 1.
            10 COL 1  SOURCE F-SR-Vendor-TXT        PIC X(6).
            10 COL 8  SOURCE F-SR-Family-TXT        PIC X(7).
         05 LINE NUMBER PLUS 1.
            10 COL 1  VALUE 'Family'.
            10 COL 9  VALUE 'Model'.
            10 COL 16 VALUE 'Benchmark Score (High to Low)'.
         05 LINE NUMBER PLUS 1.
            10 COL 1  VALUE '======'.
            10 COL 9  VALUE '======'.
            10 COL 16 VALUE '============================='.

     01  Detail-Line TYPE IS DETAIL.
         05 LINE NUMBER PLUS 1.
            10 COL 1  SOURCE F-SR-Family-TXT PIC X(7) GROUP INDICATE.
            10 COL 9  PIC X(6)       SOURCE F-SR-Model-TXT.
            10 COL 16 PIC ZZZZ9      SOURCE F-SR-Score-NUM.

     01  End-Family TYPE IS CONTROL FOOTING F-SR-Family-TXT.
         05 LINE NUMBER PLUS 1.
            10 COL 9                 VALUE  'Ave...'.
            10 COL 16 PIC ZZZZ9.99   SOURCE WS-FC-AVE.
            10 COL 25                VALUE  '('.
            10 COL 26 PIC ZZ9        SUM    WS-One-Const.
            10 COL 30                VALUE  'Family CPUs)'.

     01  End-Vendor TYPE IS CONTROL FOOTING F-SR-Vendor-TXT.
         05 LINE NUMBER PLUS 1.
            10 COL 9                 VALUE  'Ave...'.
            10 COL 16 PIC ZZZZ9.99   SOURCE WS-VC-AVE.
            10 COL 25                VALUE  '('.
            10 COL 26 PIC ZZ9        SUM    WS-One-Const.
            10 COL 30                VALUE  'Vendor CPUs)'.

     01  End-Overall TYPE IS CONTROL FOOTING FINAL.
         05 LINE NUMBER PLUS 1.
            10 COL 9                 VALUE  'Ave...'.
            10 COL 16 PIC ZZZZ9.99   SOURCE WS-OC-AVE.
            10 COL 25                VALUE  '('.
            10 COL 26 PIC ZZ9        SUM    WS-One-Const.
            10 COL 30                VALUE  'CPUs)'.

     PROCEDURE DIVISION.
     DECLARATIVES.
     000-End-Family SECTION.
         USE BEFORE REPORTING End-Family.
     1.  IF WS-FC-Qty > 0
             COMPUTE WS-FC-AVE = WS-FC-Total-NUM / WS-FC-Qty
         ELSE
             MOVE 0 TO WS-FC-AVE
         END-IF
         MOVE 0 TO WS-FC-Qty
                   WS-FC-Total-NUM
         .
     000-End-Vendor SECTION.
         USE BEFORE REPORTING End-Vendor.
     1.  IF WS-VC-Qty > 0
             COMPUTE WS-VC-AVE = WS-VC-Total-NUM / WS-VC-Qty
         ELSE
             MOVE 0 TO WS-VC-AVE
         END-IF
         MOVE 0 TO WS-VC-Qty
                   WS-VC-Total-NUM
         .
     000-End-Overall SECTION.
         USE BEFORE REPORTING End-Overall.
     1.  IF WS-OC-Qty > 0
             COMPUTE WS-OC-AVE = WS-OC-Total-NUM / WS-OC-Qty
         ELSE
             MOVE 0 TO WS-OC-AVE
         END-IF
         MOVE 0 TO WS-OC-Qty
                   WS-OC-Total-NUM
         .
     END DECLARATIVES.

     010-Main SECTION.
     1.  ACCEPT WS-Date FROM DATE YYYYMMDD
         SORT SORT-FILE
             ASCENDING KEY    F-SR-Vendor-TXT
                              F-SR-Family-TXT
             DESCENDING KEY   F-SR-Score-NUM
             ASCENDING KEY    F-SR-Model-TXT
             INPUT PROCEDURE  100-Pre-Process-Data
             OUTPUT PROCEDURE 200-Generate-Report
         STOP RUN
         .
     100-Pre-Process-Data SECTION.
     1.  OPEN INPUT CPU-FILE
         PERFORM FOREVER
             READ CPU-FILE
             AT END
                 EXIT PERFORM
             END-READ
             MOVE SPACES TO SORT-REC
             UNSTRING CPU-REC DELIMITED BY ','
                 INTO F-SR-Score-NUM,
                      F-SR-Vendor-TXT,
                      F-SR-Family-TXT,
                      F-SR-Model-TXT
             RELEASE SORT-REC
         END-PERFORM
         CLOSE CPU-FILE
         .
     200-Generate-Report SECTION.
     1.  INITIALIZE WS-Family-Counters
                    WS-Flags
         OPEN OUTPUT REPORT-FILE
         INITIATE CPU-Report
         RETURN SORT-FILE
         AT END
             MOVE 'Y' TO WS-F-EOF
         END-RETURN
         PERFORM UNTIL WS-F-EOF = 'Y'
             GENERATE Detail-Line
             ADD 1              TO WS-FC-Qty
                                   WS-OC-Qty
                                   WS-VC-Qty
             ADD F-SR-Score-NUM TO WS-FC-Total-NUM
                                   WS-OC-Total-NUM
                                   WS-VC-Total-NUM
             RETURN SORT-FILE
             AT END
                 MOVE 'Y' TO WS-F-EOF
             END-RETURN
         END-PERFORM
         TERMINATE CPU-Report
         CLOSE REPORT-FILE
         .


File: gnucobpg.info,  Node: Generated Report Pages,  Prev: Program,  Up: An Example

9.6.3 Generated Report Pages
----------------------------

Finally, here's the report the program generates!

     2013/12/24   CPU Benchmark Scores   Page:  1
     ********************************************
     **   All CPU Data From cpubenchmark.net   **
     ********************************************
     AMD    A10
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     A10     6800K   5062
             5800B   4798
             6700    4767
             5800K   4677
             5700    4251
             4657M   3449
             5750M   3332
             5757M   3253
             4600M   3145
             5745M   2758
             4655M   2505
             Ave...  3817.90 ( 11 Family CPUs)
     AMD    A4
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     A4      6300    2305
             5300    2078
             5150M   1973
             5000    1919
             3420    1768
             4300M   1685
             5300B   1632
             3400    1625
             3300    1583
             3330MX  1343
             3310MX  1263
             3300M   1237
             3305M   1227
             3320M   1193
     ____________________________________________

     2013/12/24   CPU Benchmark Scores   Page:  2
     ********************************************
     **   All CPU Data From cpubenchmark.net   **
     ********************************************
     A4      4355M   1169
             1200     677
             1250     559
             Ave...  1484.47 ( 17 Family CPUs)
     AMD    A6
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     A6      3670    3327
             3650    3232
             3620    2892
             3600    2798
             5200    2440
             6400K   2384
             3430MX  2277
             5400K   2174
             3410MX  2101
             3420M   2078
             3500    1995
             3400M   1964
             5350M   1958
             5400B   1906
             5357M   1878
             1450    1634
             4400M   1630
             4455M   1296
             Ave...  2220.22 ( 18 Family CPUs)
     AMD    A8
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     A8      6600K   4719
             6500    4390
             5600K   4348
     ____________________________________________

     2013/12/24   CPU Benchmark Scores   Page:  3
     ********************************************
     **   All CPU Data From cpubenchmark.net   **
     ********************************************
     A8      5500    4052
             3870K   3682
             3850    3552
             5500B   3464
             3820    3217
             3800    3215
             5550M   3052
             5557M   2935
             3550MX  2866
             4500M   2709
             5545M   2434
             3510MX  2426
             3530MX  2276
             3520M   2245
             4555M   2193
             3500M   2050
             Ave...  3148.68 ( 19 Family CPUs)
     AMD    FX
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     FX      9590   10479
             9370    9807
             8350    9067
             8320    8131
             8150    7719
             6350    7017
             8140    6845
             8120    6605
             6300    6388
             6200    6194
             8100    6163
             6120    5813
     ____________________________________________

     2013/12/24   CPU Benchmark Scores   Page:  4
     ********************************************
     **   All CPU Data From cpubenchmark.net   **
     ********************************************
     FX      6100    5421
             4350    5247
             4170    4774
             4300    4711
             4130    4153
             4150    4094
             4100    4055
             Ave...  6457.00 ( 19 Family CPUs)
             Ave...  3448.86 ( 84 Vendor CPUs)
     Intel  Core i3
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     Core i3 4340    5117
             4330    5115
             4130    4904
             3250    4757
             3245    4414
             3225    4407
             3240    4259
             3220    4219
             4130T   4041
             3210    3820
             3240T   3793
             3220T   3724
             3130M   3655
             4000M   3443
             3120M   3301
             3110M   3076
             3227U   2575
             4010U   2459
             3217U   2266
             4010Y   2003
     ____________________________________________

     2013/12/24   CPU Benchmark Scores   Page:  5
     ********************************************
     **   All CPU Data From cpubenchmark.net   **
     ********************************************
     Core i3 3229Y   1885
             Ave...  3677.76 ( 21 Family CPUs)
     Intel  Core i5
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     Core i5 4670K   7565
             4670    7492
             3570K   7118
             4570    7061
             3570    6993
             3550    6828
             4570S   6803
             3570S   6709
             3550S   6631
             3470    6576
             4440    6517
             4570R   6474
             3450    6442
             4670T   6351
             3340    6282
             4430    6282
             3350P   6199
             3470S   6077
             3450S   6071
             3475S   5991
             4430S   5954
             3330    5902
             3335S   5781
             3330S   5690
             3570T   5414
             3340S   5372
             4330M   4804
     ____________________________________________

     2013/12/24   CPU Benchmark Scores   Page:  6
     ********************************************
     **   All CPU Data From cpubenchmark.net   **
     ********************************************
     Core i5 4300M   4786
             4288U   4663
             3470T   4591
             3380M   4555
             4258U   4381
             4200M   4333
             3340M   4327
             3360M   4314
             3320M   4101
             3230M   3995
             4300U   3917
             3210M   3807
             4350U   3604
             3427U   3589
             4250U   3482
             3437U   3479
             4200U   3355
             3337U   3280
             3317U   3126
             3439Y   3057
             4570T   2503
             4210Y   2382
             4200Y   2358
             3339Y   2252
             4300Y   1743
             Ave...  5026.13 ( 52 Family CPUs)
     Intel  Core i7
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     Core i7 4960X  14291
             4930K  13620
             3970X  12823
     ____________________________________________

     2013/12/24   CPU Benchmark Scores   Page:  7
     ********************************************
     **   All CPU Data From cpubenchmark.net   **
     ********************************************
     Core i7 3960X  12718
             3930K  12107
             4960HQ 10262
             4770K  10190
             4771   10078
             4770    9969
             4820K   9969
             4770S   9803
             4930MX  9754
             3770K   9578
             3770    9420
             4850HQ  9331
             4900MQ  9323
             3920XM  9196
             3770S   9074
             3940XM  9052
             3840QM  9025
             3820    8995
             4770T   8803
             4800MQ  8567
             3820QM  8548
             3740QM  8512
             3720QM  8347
             3770T   8280
             4700HQ  8161
             4750HQ  8066
             4702HQ  8002
             4700MQ  7946
             3630QM  7759
             4702MQ  7647
             3610QM  7532
             4765T   7367
     ____________________________________________

     2013/12/24   CPU Benchmark Scores   Page:  8
     ********************************************
     **   All CPU Data From cpubenchmark.net   **
     ********************************************
     Core i7 4700EQ  7352
             3615QM  7310
             3632QM  7055
             3612QE  6988
             3612QM  6907
             3635QM  6516
             3610QE  6144
             3615QE  5495
             4600M   4892
             3540M   4861
             3520M   4588
             4558U   4507
             4600U   4484
             4650U   4345
             3687U   4271
             3667U   4032
             3555LE  4009
             4500U   3992
             3537U   3912
             3517U   3701
             4610Y   3680
             3689Y   3479
             3517UE  3449
             Ave...  7725.58 ( 58 Family CPUs)
             Ave...  6005.16 (131 Vendor CPUs)
             Ave...  5006.42 (215 CPUs)





     ____________________________________________


File: gnucobpg.info,  Node: Control Hierarchy (Revisited),  Next: Turning PHYSICAL Page Formatting Into LOGICAL Formatting,  Prev: An Example,  Up: Report Writer Usage

9.7 Control Hierarchy (Revisited)
=================================

The sample program just discussed presents a great opportunity to show
what can happen if you don't define the control hierarchy of a report
properly.

   I changed the ‘CONTROLS ARE’ clause on the sample program from this:

     CONTROLS ARE FINAL
                  F-SR-Vendor-TXT
                  F-SR-Family-TXT

   To this:

     CONTROLS ARE FINAL
                  F-SR-Family-TXT
                  F-SR-Vendor-TXT

   And then ran the report again.  Here are the first two pages of that
new report.  See what happened to the control breaks?

     2013/12/24   CPU Benchmark Scores   Page:  1
     ********************************************
     **   All CPU Data From cpubenchmark.net   **
     ********************************************
     AMD    A10
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     A10     6800K   5062
             5800B   4798
             6700    4767
             5800K   4677
             5700    4251
             4657M   3449
             5750M   3332
             5757M   3253
             4600M   3145
             5745M   2758
             4655M   2505
             Ave...  3817.90 ( 11 Vendor CPUs)
             Ave...  3817.90 ( 11 Family CPUs)
     AMD    A4
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     A4      6300    2305
             5300    2078
             5150M   1973
             5000    1919
             3420    1768
             4300M   1685
             5300B   1632
             3400    1625
             3300    1583
             3330MX  1343
             3310MX  1263
             3300M   1237
             3305M   1227
     ____________________________________________

     2013/12/24   CPU Benchmark Scores   Page:  2
     ********************************************
     **   All CPU Data From cpubenchmark.net   **
     ********************************************
     A4      3320M   1193
             4355M   1169
             1200     677
             1250     559
             Ave...  1484.47 ( 17 Vendor CPUs)
             Ave...  1484.47 ( 17 Family CPUs)
     AMD    A6
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     A6      3670    3327
             3650    3232
             3620    2892
             3600    2798
             5200    2440
             6400K   2384
             3430MX  2277
             5400K   2174
             3410MX  2101
             3420M   2078
             3500    1995
             3400M   1964
             5350M   1958
             5400B   1906
             5357M   1878
             1450    1634
             4400M   1630
             4455M   1296
             Ave...  2220.22 ( 18 Vendor CPUs)
             Ave...  2220.22 ( 18 Family CPUs)
     AMD    A8
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     A8      6600K   4719

     ____________________________________________


File: gnucobpg.info,  Node: Turning PHYSICAL Page Formatting Into LOGICAL Formatting,  Prev: Control Hierarchy (Revisited),  Up: Report Writer Usage

9.8 Turning PHYSICAL Page Formatting Into LOGICAL Formatting
============================================================

You can trick RWCS into using the ‘PAGE LIMIT’ values as logical
specifications rather than physical ones quite easily -- simply include
an ASCII form-feed (‘X'0C'’) character into your page heading design!
Here's how the sample program shown earlier could be easily modified:

   Simply Change This...

     01  TYPE IS PAGE HEADING.
         05 LINE NUMBER 1.
            10 COL 1  SOURCE WS-Date PIC 9999/99/99.
            10 COL 14 VALUE 'CPU Benchmark Scores'.
            10 COL 37 VALUE 'Page:'.
            10 COL 43 SOURCE PAGE-COUNTER PIC Z9.
         05 LINE NUMBER PLUS 1.
            10 COL 1  SOURCE WS-Starz PIC X(44).
         05 LINE NUMBER PLUS 1.
            10 COL 1  VALUE '**'.
            10 COL 6  VALUE 'All CPU Data From ' &
                            'cpubenchmark.net'.
            10 COL 43 VALUE '**'.
         05 LINE NUMBER PLUS 1.
            10 COL 1  SOURCE WS-Starz PIC X(44).

   To This...

     01  TYPE IS PAGE HEADING.
         05 LINE NUMBER 1.                          *> NEW
            10 COL 1  VALUE X'0C'.                  *> NEW
         05 LINE NUMBER PLUS 1.                 *> CHANGED
            10 COL 1  SOURCE WS-Date PIC 9999/99/99.
            10 COL 14 VALUE 'CPU Benchmark Scores'.
            10 COL 37 VALUE 'Page:'.
            10 COL 43 SOURCE PAGE-COUNTER PIC Z9.
         05 LINE NUMBER PLUS 1.
            10 COL 1  SOURCE WS-Starz PIC X(44).
         05 LINE NUMBER PLUS 1.
            10 COL 1  VALUE '**'.
            10 COL 6  VALUE 'All CPU Data From ' &
                            'cpubenchmark.net'.
            10 COL 43 VALUE '**'.
         05 LINE NUMBER PLUS 1.
            10 COL 1  SOURCE WS-Starz PIC X(44).

   RWCS will still be counting lines to decide when to close off one
page and start a new one, but when a new page is started its page
heading will physically form-feed the printer when the report is
printed.  As long as any printer you plan on using supports at least as
many physical print lines as what is defined as the ‘PAGE LIMIT’ value
in whatever paper orientation and font you plan on (or are limited to)
printing in, you have now divorced your program from the physical
realities of the printer!

   Of course, whatever software you are using to deliver the printed
document to the printer with, must allow the ASCII form-feed character
to pass through to the printer.


File: gnucobpg.info,  Node: Interfacing With The OS,  Next: Sub-Programming,  Prev: Report Writer Usage,  Up: Top

10 Interfacing With The OS
**************************


* Menu:

* Compiling Programs::
* Running Programs::
* Binary Truncation::


File: gnucobpg.info,  Node: Compiling Programs,  Next: Running Programs,  Up: Interfacing With The OS

10.1 Compiling Programs
=======================

Program source files should have by convention, extensions of ‘.cob’ or
‘.cbl’.

   Program file names should match exactly the specification of
‘PROGRAM-ID’ (including case).

   Spaces cannot be included in primary entry-point names and therefore
must not be included in program file names.

   The GnuCOBOL compiler will translate your COBOL program into C source
code, compile that C source code into executable binary form using the C
compiler specified when GnuCOBOL was built and link that executable
binary into:
Directly executable form
     This is an executable file directly-executable from the
     command-line.  On Windows computers, this would be an ‘.exe’ file.
     On Unix systems, this will be a file with no specific extension,
     but with execute permissions.  This file will include the main
     program as well as any static-linked subprograms.

Static-linkable form
     This is a single subprogram compiled into object-code form, ready
     to be linked in with a main program to form a directly-executable
     program.  On windows computers, these generally are ‘.o’
     (object-code) files.

Dynamically-loadable executable form
     These are dynamically-loadable object code files ready to be
     invoked from other programs at execution time.  On Windows systems,
     these would be ‘.dll’ files, while on Unix systems they are
     typically ‘.so’ files (OSX uses ‘.dylib’).

* Menu:

* cobc - The GnuCOBOL Compiler::
* cobc option -Xref an example::
* Cross Reference listing using cobxref::
* Compilation Time Environment Variables::
* Predefined Compilation Variables::
* Locating Copybooks::
* Compiler Configuration Files::


File: gnucobpg.info,  Node: cobc - The GnuCOBOL Compiler,  Next: cobc option -Xref an example,  Up: Compiling Programs

10.1.1 cobc - The GnuCOBOL Compiler
-----------------------------------

The GnuCOBOL compiler is named ‘cobc’ (‘cobc.exe’ on a Windows system).

   The following describes the syntax and option switches of the cobc
command.  This information may be displayed by entering the command
‘cobc --help’ or ‘cobc -h’.

GnuCOBOL compiler for most COBOL dialects with lots of extensions

Sorted within groups

Usage: cobc [options]... file...

Options:
  -h, --help             display this help and exit

  -du(mpversion)         display compiler version and exit
  -i, --info             display compiler information (build/environment)
                         and exit
  -q, --brief            reduced displays, commands invoked not shown
  -v, --verbose          verbose mode, display additional information;
                         multiple -v options increase the verbosity,
                         the maximum is 3 as follows:
                         (1) display compiler version and the commands
                         invoked by the compiler,
                         (2) pass verbose option to assembler/compiler
                         (3) pass verbose option to linker
  -V, --version          display compiler version information and exit
  -###                   like -v but commands not executed

  -A <options>           add <options> to the C compile phase
  -b                     combine all input files into a single
                         dynamically loadable module
  -c                     compile and assemble, but do not link
  --conf=<file>          user-defined dialect configuration; see -std
  -C                     translation only; convert COBOL to C
  -d, --debug            enable all run-time error checking,
                         equal to -fstack-check -fec=EC-ALL
  -D <define>            define <define> for COBOL compilation
  -ext <extension>       add file extension for resolving COPY
  -E                     preprocess only; do not compile or link
  -F, --free             use free source format (alias for -fformat=free)
  --fixed                use fixed source format (default; alias for
                         -fformat=fixed)
  -fec=<exception-name>	 enable code generation for <exception-name>,
                         see --list-exceptions for the possible values,
                         sets -fsource-location
  -fno-ec=<exception-name>
                         disable code generation for <exception-name>
  -g                     enable C compiler debug and stack check
  -I <directory>         add <directory> to copy/include search path
  -j [<args>], --job[=<args>]
                         run program after build, passing <args>
  -K <entry>             generate CALL to <entry> as static
  -l <lib>               link the library <lib>
  -L <directory>         add <directory> to library search path
  --list-exceptions      display exception names
  --list-intrinsics      display intrinsic functions
  --list-mnemonics       display mnemonic names
  --list-reserved        display reserved words and internal registers
  --list-system          display system routines
  -m                     build a dynamically loadable module (default)
  -o <file>              place the output into <file>
  -O, -O2, -O3, -Os      enable optimization
  -O0                    disable optimization
  -P[=<dir or file>]     generate preprocessed program listing (.lst)
  -Q <options>           add <options> to the C link phase
  -std=<dialect>         warnings/features for a specific dialect
                         <dialect> can be one of:
                         default, cobol2014, cobol2002, cobol85, xopen,
                         ibm-strict, ibm, mvs-strict, mvs,
                         mf-strict, mf, bs2000-strict, bs2000,
                         acu-strict, acu, rm-strict, rm, gcos-strict,
                         gcos;
                         see configuration files in directory config
  -S                     compile only; output assembly file
  --save-temps[=<dir>]   save intermediate files
                         * default: current directory
  -t <file>              generate and place a program listing into <file>
  --tlines=<lines>       specify lines per page in listing, default = 55
  -T <file>              generate and place a wide program listing into <file>
  -x                     build an executable program
  -X, --Xref             generate internal cross reference


Warning options:
  -w                     disable all warnings
  -Wall                  enable most warnings (all except as noted below)
  -Wadditional           additional warnings only raised with -Wall
  -Warchaic              warn if archaic features are used
  -Warithmetic-osvs      warn if arithmetic expression precision has changed
  -Wcall-params          warn about non 01/77 items for CALL parameters
                         * NOT set with -Wall
  -Wcolumn-overflow      warn about text after program-text area, FIXED format
                         * NOT set with -Wall
  -Wconstant-expression  warn about expressions that always resolve to true/false
  -Wconstant-numlit-expression
                         warn about numeric expressions that always resolve to
                         true/false
  -Wdangling-text        warn about source text after program-area
                         * NOT set with -Wall
  -Werror                treat all warnings as errors
  -Werror=<warning>      treat specified <warning> as error
  -Wextra                like -Wall but enable some extra warning flags
  -Wimplicit-define      warn whenever data items are implicitly defined
                         * NOT set with -Wall
  -Winitial-value        warn if initial VALUE clause is ignored
  -Wlarger-01-redefines  warn about larger redefines allowed by COBOL standards
  -Wlinkage              warn about dangling LINKAGE items
                         * NOT set with -Wall
  -Wobsolete             warn if obsolete features are used
  -Woverlap              warn about overlapping MOVE of items
  -Wno-corresponding     do not warn about CORRESPONDING with no matching items
                         * ALWAYS active
  -Wno-dialect           do not warn about dialect specific issues
                         * ALWAYS active
  -Wgoto-different-section
                         warn about GO TO a praragraph defined in a different section
  -Wno-error             don't treat warnings as errors
  -Wno-error=<warning>   don't treat specified <warning> as error
  -Wno-goto-section      do not warn about GO TO section-name
                         * ALWAYS active
  -Wno-ignored-error     do not warn about errors in code parts which are
                         unreachable and so normally ignored
                         * ALWAYS active
  -Wno-missing-newline   do not warn about missing newlines
                         * ALWAYS active
  -Wno-others            do not warn about different issues
                         * ALWAYS active
  -Wno-pending           do not warn if pending features are used
                         * ALWAYS active
  -Wno-repository-checks
                         do not warn/check for program/function/external signature
                         mismatch
                         * ALWAYS active
  -Wno-unfinished        do not warn if unfinished features are used
                         * ALWAYS active
  -Wno-unsupported       do not warn if runtime does not support a feature used
  -Wno-<warning>         disable warning enabled by default, -Wall or -Wextra
  -Wparentheses          warn if parentheses are omitted around AND within OR
  -Wpossible-overlap     warn about MOVE of items that may overlap depending on
                         variables
                         * NOT set with -Wall
  -Wpossible-truncate    warn about possible field truncation
                         * NOT set with -Wall
  -Wprototypes           warn about missing FUNCTION prototypes/definitions
  -Wredefinition         warn about non-referenced ambiguous data items
  -Wstrict-typing        warn strictly about type mismatch
  -Wsuspicious-perform-thru
                         warn if PERFORM THRU references procedures not in ascending
                         order or multiple sections
                         * ALWAYS active
  -Wterminator           warn about lack of scope terminator END-XXX
                         * NOT set with -Wall
  -Wtruncate             warn about field truncation from constant assignments
  -Wunreachable          warn about likely unreachable statements
                         * NOT set with -Wall


Compiler options:
  -fsign=[ASCII|EBCDIC]	 define display sign representation
                         * default: machine native
  -ffold-copy=[UPPER|LOWER]
                         fold COPY subject to value
                         * default: no transformation
  -ffold-call=[UPPER|LOWER]
                         fold PROGRAM-ID, CALL, CANCEL subject to value
                         * default: no transformation
  -fmax-errors=<number>	 maximum number of errors to report before
                         compilation is aborted
                         * default: 128
  -fintrinsics=[ALL|intrinsic
                         function name(,name,...)]
                         intrinsics to be used without FUNCTION keyword
  -fdump=<scope>         dump data fields on abort, <scope> may be
                         a combination of: ALL, WS, LS, RD, FD, SC, LO
  -fcallfh=<name>        specifies <name> to be used for I/O
                         as external provided EXTFH interface module
  -febcdic-table=[DEFAULT|RESTRICTED-GC|IBM|GCOS]
                         define EBCDIC translation table:
                         * default: translation to extended ASCII as per MF
                         * restricted-gc: translation from restricted ASCII only
                         * ibm: translation to restricted ASCII as per IBM
                         * gcos: translation to extended ASCII as per GCOS7
  -fdefault-colseq=[ASCII|EBCDIC|NATIVE]
                         define default collating sequence
                         * default: NATIVE
  -fstack-extended       store origin of entrypoints and PERFORM
                         * turned on by -debug/-dump
  -fno-remove-unreachable
                         disable remove of unreachable code
                         * turned off by -g
  -ftrace                generate trace code
                         * scope: executed SECTION/PARAGRAPH
  -ftraceall             generate trace code
                         * scope: executed SECTION/PARAGRAPH/STATEMENTS
  -fsyntax-only          syntax error checking only; don't emit any output
  -fdebugging-line       enable debugging lines
                         * 'D' in indicator column or floating >>D
  -fsource-location      generate source location code
                         * turned on by -debug/-ftraceall/-fec/-dump
  -fimplicit-init        automatic initialization of the COBOL runtime system
  -fno-recursive-check   disable check of recursive program call;
                         effectively compiling as RECURSIVE program
  -fstack-check          PERFORM stack checking
                         * turned on by -debug/-g
  -fsection-exit-check   check that code execution does not leave the scope of
                         SECTIONs
  -fimplicit-goback-check
                         check that code execution does not end implicit at end of
                         PROCEDURE DIVISION
  -fwrite-after          use AFTER 1 for WRITE of LINE SEQUENTIAL
                         * default: BEFORE 1
  -fmfcomment            '*' in column 1 treated as comment with listing suppression
                         * FIXED/COBOL85/VARIABLE format only
  -facucomment           '$' in indicator area treated as '*',
                         '|' treated as floating comment
  -fno-trunc             allow numeric field overflow
                         * non-ANSI behaviour
  -fsingle-quote         use a single quote (apostrophe) for QUOTE
                         * default: double quote
  -foptional-file        treat all files as OPTIONAL
                         * unless NOT OPTIONAL specified
  -fstatic-call          output static function calls for the CALL statement
  -fno-gen-c-decl-static-call
                         disable generation of C function declarations
                         for subroutines with static CALL
  -fgen-c-line-directives
                         generate source location directives in C code;
                         * turned on by -g
  -fgen-c-labels         generate extra labels in C sources;
                         * turned on by -g
  -fno-theaders          suppress all headers and output of compilation
                         options from listing while keeping page breaks
  -fno-tsource           suppress source from listing
  -fno-tmessages         suppress warning and error summary from listing
  -ftsymbols             specify symbols in listing
  -fno-diagnostics-show-option
                         suppress output of option that directly
                         controls the diagnostic


Compiler dialect configuration options:
  -freserved-words=<value>
                         use of complete/fixed reserved words
  -ftab-width=1..12      number of spaces that are assumed for tabs
  -ftext-column=72..255  right margin column number for fixed-form reference format
  -fpic-length=<number>  maximum number of characters allowed in the PICTURE
                         character-string
  -fword-length=1..63    maximum word-length for COBOL (= programmer defined) words
  -fliteral-length=<number>
                         maximum literal size in general
  -fnumeric-literal-length=1..38
                         maximum numeric literal size
  -fdefaultbyte=<value>  default initialization for fields without VALUE, may be
                         one of
                         * character in quotes
                         * decimal 0..255 representing a character
                         * "init" to initialize to PICTURE/USAGE
                         * "none" to do no explicit initialization
                         * default: "init"
  -fformat=<value>       default reference-format, may be one of: FIXED, FREE,
                         COBOL85, VARIABLE, XOPEN, XCARD, CRT, TERMINAL, COBOLX
  -fbinary-size=<value>  binary byte size - defines the allocated bytes according to
                         PIC, may be one of: 2-4-8, 1-2-4-8, 1--8
  -fbinary-byteorder=<value>
                         binary byte order, may be one of: native, big-endian
  -fassign-clause=<value>
                         how to interpret 'ASSIGN word': as 'ASSIGN EXTERNAL word' or
                         'ASSIGN DYNAMIC word', may be one of: dynamic, external,
                         ibm (= external), mf (= dynamic)
  -fscreen-section-rules=<value>
                         which compiler's rules to apply to SCREEN SECTION item
                         clauses, may be one of: acu, gc, mf, rm, std, xopen
  -fdpc-in-data=<value>  whether DECIMAL-POINT IS COMMA has effect in XML/JSON
                         GENERATE, may be one of: none, xml, json, all
  -ffilename-mapping     resolve file names at run time using environment variables
  -fpretty-display       alternate formatting of numeric fields
  -fbinary-truncate      numeric truncation according to ANSI
  -fcomplex-odo          allow complex OCCURS DEPENDING ON
  -fodoslide             adjust items following OCCURS DEPENDING (implies complex-odo)
  -findirect-redefines   allow REDEFINES to other than last equal level number
  -frelax-syntax-checks  allow certain syntax variations (e.g. REDEFINES position)
  -fref-mod-zero-length  allow zero length reference-modification (only changed with
                         EC-BOUND-REF-MOD active)
  -frelax-level-hierarchy
                         allow non-matching level numbers
  -fselect-working       require ASSIGN USING items to be in WORKING-STORAGE
  -flocal-implies-recursive
                         LOCAL-STORAGE SECTION implies RECURSIVE attribute
  -fsticky-linkage       LINKAGE SECTION items remain allocated between invocations
  -fmove-ibm             MOVE operates as on IBM (left to right, byte by byte)
  -fperform-osvs         exit point of any currently executing perform is recognized
                         if reached
  -farithmetic-osvs      limit precision in intermediate results to precision of final
                         result (less accurate)
  -fconstant-folding     evaluate constant expressions at compile time
  -fhostsign             allow hexadecimal value 'F' for NUMERIC test of signed
                         PACKED DECIMAL field
  -fprogram-name-redefinition
                         program names don't lead to a reserved identifier
  -faccept-update        set WITH UPDATE clause as default for ACCEPT dest-item,
                         instead of WITH NO UPDATE
  -faccept-auto          set WITH AUTO clause as default for ACCEPT dest-item,
                         instead of WITH TAB
  -fconsole-is-crt       assume CONSOLE IS CRT if not set otherwise
  -fno-echo-means-secure	NO-ECHO
                         hides input with asterisks like SECURE
  -fline-col-zero-default
                         assume a field DISPLAY starts at LINE 0 COL 0 (i.e. at the
                         cursor), not LINE 1 COL 1
  -fdisplay-special-fig-consts
                         special behaviour of DISPLAY SPACE/ALL X'01'/ALL X'02'/ALL
                         X'07'
  -fbinary-comp-1        COMP-1 is a 16-bit signed integer
  -fnumeric-pointer      POINTER is a 64-bit unsigned integer
  -fmove-non-numeric-lit-to-numeric-is-zero
                         imply zero in move of non-numeric literal to numeric items
  -fimplicit-assign-dynamic-var
                         implicitly define a variable if an ASSIGN DYNAMIC does not
                         match any data item
  -fdevice-mnemonics     specifying device by mnemonic
  -fxml-parse-xmlss      XML PARSE XMLSS
  -fareacheck            check contents of Area A (when reference format supports
                         Area A enforcement),
                         enabled checks include:
                         * division, section, paragraph names, level indicators (FD,
                         SD, RD, and CD),
                           and toplevel numbers (01 and 77) must start in Area A;
                         * statements must not start in Area A; and
                         * separator periods must not be within Area A
  -fcomment-paragraphs=<support>
                         comment paragraphs in IDENTIFICATION DIVISION (AUTHOR,
                         DATE-WRITTEN, ...)
  -fcontrol-division=<support>
                         CONTROL DIVISION
  -fpartial-replace-when-literal-src=<support>
                         apply partial replacing with literal source operand even
                         when it replaces with spaces only;
                         * "skip" prevents such replacements
  -fmemory-size-clause=<support>
                         MEMORY-SIZE clause
  -fmultiple-file-tape-clause=<support>
                         MULTIPLE-FILE-TAPE clause
  -flabel-records-clause=<support>
                         LABEL-RECORDS clause
  -fvalue-of-clause=<support>
                         VALUE-OF clause
  -fdata-records-clause=<support>
                         DATA-RECORDS clause
  -ftop-level-occurs-clause=<support>
                         OCCURS clause on top-level
  -fsame-as-clause=<support>
                         SAME AS clause
  -ftype-to-clause=<support>
                         TYPE TO clause
  -fusage-type=<support>	USAGE type-name
  -fsynchronized-clause=<support>
                         SYNCHRONIZED clause
  -fsync-left-right=<support>
                         LEFT/RIGHT phrases in SYNCHRONIZED clause
  -fspecial-names-clause=<support>
                         SPECIAL-NAMES clause
  -fgoto-statement-without-name=<support>
                         GOTO statement without name
  -fstop-literal-statement=<support>
                         STOP-literal statement
  -fstop-identifier-statement=<support>
                         STOP-identifier statement
  -fstop-error-statement=<support>
                         STOP ERROR statement
  -fdebugging-mode=<support>
                         DEBUGGING MODE and debugging indicator
  -fuse-for-debugging=<support>
                         USE FOR DEBUGGING
  -fpadding-character-clause=<support>
                         PADDING CHARACTER clause
  -fnext-sentence-phrase=<support>
                         NEXT SENTENCE phrase
  -flisting-statements=<support>
                         listing-directive statements EJECT, SKIP1, SKIP2, SKIP3
  -ftitle-statement=<support>
                         listing-directive statement TITLE
  -fentry-statement=<support>
                         ENTRY statement
  -fmove-noninteger-to-alphanumeric=<support>
                         move noninteger to alphanumeric
  -fmove-figurative-constant-to-numeric=<support>
                         move figurative constants to numeric
  -fmove-figurative-space-to-numeric=<support>
                         move figurative constant SPACE to numeric
  -fmove-figurative-quote-to-numeric=<support>
                         move figurative constant QUOTE to numeric
  -fodo-without-to=<support>
                         OCCURS DEPENDING ON without to
  -fsection-segments=<support>
                         section segments
  -falter-statement=<support>
                         ALTER statement
  -fcall-overflow=<support>
                         OVERFLOW clause for CALL
  -fnumeric-boolean=<support>
                         boolean literals (B'1010')
  -fhexadecimal-boolean=<support>
                         hexadecimal-boolean literals (BX'A')
  -fnational-literals=<support>
                         national literals (N'UTF-16 string')
  -fhexadecimal-national-literals=<support>
                         hexadecimal-national literals (NX'265E')
  -fnational-character-literals=<support>
                         non-standard national literals (NC'UTF-16 string')
  -fhp-octal-literals=<support>
                         HP COBOL octal literals (%377)
  -facu-literals=<support>
                         ACUCOBOL-GT literals (#B #O #H #X)
  -fword-continuation=<support>
                         continuation of COBOL words
  -fnot-exception-before-exception=<support>
                         NOT ON EXCEPTION before ON EXCEPTION
  -faccept-display-extensions=<support>
                         extensions to ACCEPT and DISPLAY
  -frenames-uncommon-levels=<support>
                         RENAMES of 01-, 66- and 77-level items
  -flarger-redefines=<support>
                         allow larger REDEFINES items
  -fsymbolic-constant=<support>
                         constants defined in SPECIAL-NAMES
  -fconstant-78=<support>
                         constant with level 78 item (note: has left to right
                         precedence in expressions)
  -fconstant-01=<support>
                         constant with level 01 CONSTANT AS/FROM item
  -fperform-varying-without-by=<support>
                         PERFORM VARYING without BY phrase (implies BY 1)
  -freference-out-of-declaratives=<support>
                         references to sections not in DECLARATIVES from within
                         DECLARATIVES
  -fprogram-prototypes=<support>
                         CALL/CANCEL with program-prototype-name
  -fcall-convention-mnemonic=<support>
                         specifying call-convention by mnemonic
  -fcall-convention-linkage=<support>
                         specifying call-convention by WITH ... LINKAGE
  -fnumeric-value-for-edited-item=<support>
                         numeric literals in VALUE clause of numeric-edited items
  -fincorrect-conf-sec-order=<support>
                         incorrect order of CONFIGURATION SECTION paragraphs
  -fdefine-constant-directive=<support>
                         allow >> DEFINE CONSTANT var AS literal
  -ffree-redefines-position=<support>
                         REDEFINES clause not following entry-name in definition
  -frecords-mismatch-record-clause=<support>
                         record sizes does not match RECORD clause
  -frecord-delimiter=<support>
                         RECORD DELIMITER clause
  -fsequential-delimiters=<support>
                         BINARY-SEQUENTIAL and LINE-SEQUENTIAL phrases in
                         RECORD DELIMITER
  -frecord-delim-with-fixed-recs=<support>
                         RECORD DELIMITER clause on file with fixed-length records
  -fmissing-statement=<support>
                         missing statement (e.g. empty IF / PERFORM)
  -fmissing-period=<support>
                         missing period in PROCEDURE DIVISION (when reference format
                         supports Area A enforcement)
  -fzero-length-literals=<support>
                         zero-length literals, e.g. '' and ""
  -fxml-generate-extra-phrases=<support>
                         XML GENERATE's phrases other than COUNT IN
  -fcontinue-after=<support>
                         AFTER phrase in CONTINUE statement
  -fgoto-entry=<support>	ENTRY FOR GOTO and GOTO ENTRY statements
  -fassign-variable=<support>
                         ASSIGN [TO] variable in SELECT
  -fassign-using-variable=<support>
                         ASSIGN USING/VARYING variable in SELECT
  -fassign-ext-dyn=<support>
                         ASSIGN EXTERNAL/DYNAMIC in SELECT
  -fassign-disk-from=<support>
                         ASSIGN DISK FROM variable in SELECT
  -fvsam-status=<support>
                         VSAM status in FILE STATUS
  -fself-call-recursive=<support>
                         CALL to own PROGRAM-ID implies RECURSIVE attribute
  -frecord-contains-depending-clause=<support>
                         DEPENDING clause in RECORD CONTAINS
  -fpicture-l=<support>  PICTURE string with 'L' character
	where <support> is one of the following:
	'ok', 'warning', 'archaic', 'obsolete', 'skip', 'ignore', 'error',
	'unconformable'

	-fnot-reserved=<word>   word to be taken out of the reserved words list
 -freserved=<word>       word to be added to reserved words list
 -freserved=<word>:<alias>
                         word to be added to reserved words list as alias
 -fnot-register=<word>   special register to disable
 -fregister=<word> or <word>:<definition>
                         special register to enable


   Each file specified on the ‘cobc’ command constitutes a “Compilation
Unit”.  A compilation unit may be a single GnuCOBOL program -- with or
without nested subprograms(*note Independent vs Contained vs Nested
Subprograms::) -- or multiple GnuCOBOL programs, separated by ‘END
PROGRAM’ or ‘END FUNCTION’ marker lines, as appropriate.  *Note
Independent vs Contained vs Nested Subprograms::, for some examples of
these marker lines.

   A compilation unit may also be a C-language source program,
recognized as such by having a file extension of ‘.c’ or an
assembly-language program, recognized by its file extension of ‘.s’.  In
such a case, COBOL compilation of that file will be bypassed by the
‘cobc’ command; instead, the file will be passed directly to the C
compiler or assembler (executed automatically by ‘cobc’).

   A compilation unit may also be an object-code module (output from the
C compiler), recognized as such by having a file extension of ‘.o’.  In
these situations, all compilation will be bypassed, and the object code
will be "bound" into the generated executable by the linker (an ‘ld’
command executed internally by the ‘cobc’ command).

   Pre-compiled object-code subprograms may be automatically located by
the GnuCOBOL compiler and the loader by using the ‘LD_LIBRARY_PATH’
compilation-time environment variable (*note Compilation Time
Environment Variables::).  If they are locatable through that
environment variable, they need not be named on the ‘cobc’ command.

   The collection of compilation units supplied on a single ‘cobc’
execution constitute a “Compilation Group”.  All executable code
produced from a single compilation group will be collected together into
a single executable file, whose filename will be the same as that of the
first compilation unit specified on the ‘cobc’ command.

   The simplest mode of compilation is to generate a single executable
file from one or more GnuCOBOL source files:

               ‘cobc -x mainprog.cbl sub1.cbl sub2.cbl’

   The main program must be the first program found in the first
compilation unit (‘mainprog.cbl’).  The remainder of that compilation
unit as well as the rest of the files in the compilation group
(‘sub1.cbl’ and ‘sub2.cbl’) must be independent and/or contained
subprograms (*note Independent vs Contained vs Nested Subprograms::).

   This command assumes that all source files are in the directory from
which the ‘cobc’ command was executed.  You are, of course, free to
include full pathnames with any filename, if necessary.

   With the ‘-x’ switch on the compiler command, a single
directly-executable executable file (UNIX, Windows/Cygwin, OSX) or "exe"
file (Windows, Windows/MinGW) will be generated.  This executable file
has the compiled code for all COBOL programs contained within the
compilation group specified on the ‘cobc’ command included in the file.

   Any subroutines or user-defined functions that weren't included in
any of the source files comprising the compilation group will be treated
as dynamically loadable subprograms (*note Dynamic vs Static
Subprograms::).

   Optionally, the ‘-o’ switch may be used in addition to ‘-x’ to
specify the name of the generated executable file.  If ‘-o’ switch is
not specified, the filename of the 1st compilation unit will be used as
the name of the executable file.  The appropriate extension for the
generated file (‘.exe’, on a Windows computer, for example) will be
added to the filename that is explicitly specified or implicitly assumed
for the output file.

   Compilations may be performed to generate dynamically-loadable
modules (or dynamically-loadable libraries, as they are frequently
called).  These compilations are performed by using the ‘-m’ switch
instead of ‘-x’ switch:

               ‘cobc -m mainprog.cbl sub1.cbl sub2.cbl’

   When the ‘-m’ switch is used, an operating-system-specific
dynamically-loadable module is generated for each individual compilation
unit, using the filename of each compilation unit as its module filename
and either an extension of ‘.so’ (UNIX, Windows/Cygwin), ‘.dylib’ (OSX)
or ‘.dll’ (Windows, Windows/MinGW).

   You may compile GnuCOBOL subprograms into assembler source code which
can then be assembled and linked with a main program when that main
program is compiled.  To create such an assembler source file, compile
the subprogram(s) as follows:

                         ‘cobc -S sprog1.cbl’

   The above generates an assembler source file named ‘sprog1.s’.  If
you have multiple subprograms to compile this way, just string their
file names out on the command.  Each will be translated to its own
assembler source file.

   Later, when you wish to compile a calling program and combine any
needed assembly language subroutines in (as static subroutines -- *note
Dynamic vs Static Subprograms::), use a command such as this:

                    ‘cobc -x mainprog.cbl sprog1.s’


File: gnucobpg.info,  Node: cobc option -Xref an example,  Next: Cross Reference listing using cobxref,  Prev: cobc - The GnuCOBOL Compiler,  Up: Compiling Programs

10.1.2 cobc option -Xref an example
-----------------------------------

The following shows the output from using -Xref.

   Using the internal -Xref as extra options -X -t prog.list :

GnuCOBOL 3.1.2.0        prog.cbl             Thu Nov 25 15:31:52 2021  Page 0001

LINE    PG/LN  A...B............................................................

000001  000001 IDENTIFICATION   DIVISION.
000002  000002 PROGRAM-ID.      prog.
000003  000003 ENVIRONMENT DIVISION.
000004  000004 CONFIGURATION SECTION.
000005  000005 DATA             DIVISION.
000006  000006 WORKING-STORAGE  SECTION.
000007  000007 COPY 'values.cpy'.
000001C 000001 78  I   VALUE 20.
000002C 000002 78  J   VALUE 5000.
000003C 000003 78  M   VALUE 5.
000008  000008 01  SETUP-REC.
000009  000009     05  FL1       PIC X(04).
000010  000010     05  FL2       PIC ZZZZZ.
000011  000011     05  FL3       PIC 9(04).
000012  000012     05  FL4       PIC 9(08) COMP.
000013  000013     05  FL5       PIC 9(04) COMP-4.
000014  000014     05  FL6       PIC Z,ZZZ.99.
000015  000015     05  FL7       PIC S9(05) SIGN LEADING SEPARATE.
000016  000016     05  FL8       PIC X(04).
000017  000017     05  FL9 REDEFINES FL8 PIC 9(04).
000018  000018     05  FLA.
000019  000019         10  FLB OCCURS I TIMES.
000020  000020             15  FLC PIC X(02).
000021  000021         10  FLD   PIC X(20).
000022  000022     05  FLD1      PIC X(100).
000023  000025     05  FLD3      PIC X(3).
000024  000026     05  FLD4      PIC X(4).
000025  000023     05  FLD2 OCCURS M TO J TIMES DEPENDING ON FL5.
000026  000024         10  FILLER PIC X(01).
000027  000027 PROCEDURE        DIVISION.
000028  000028     STOP RUN.
GnuCOBOL 3.1.2.0        prog.cbl             Thu Nov 25 15:31:52 2021  Page 0002

NAME                           DEFINED                REFERENCES

SETUP-REC                      8      referenced by child
FL1                            9      not referenced
FL2                            10     not referenced
FL3                            11     not referenced
FL4                            12     not referenced
FL5                            13       25                             x1
FL6                            14     not referenced
FL7                            15     not referenced
FL8                            16     not referenced
FL9                            17     not referenced
FLA                            18     not referenced
FLB                            19     not referenced
FLC                            20     not referenced
FLD                            21     not referenced
FLD1                           22     not referenced
FLD3                           23     not referenced
FLD4                           24     not referenced
FLD2                           25     not referenced

GnuCOBOL 3.1.2.0        prog.cbl             Thu Nov 25 15:31:52 2021  Page 0003

LABEL                          DEFINED                REFERENCES

E prog                         27

0 warnings in compilation group
0 errors in compilation group


File: gnucobpg.info,  Node: Cross Reference listing using cobxref,  Next: Compilation Time Environment Variables,  Prev: cobc option -Xref an example,  Up: Compiling Programs

10.1.3 Cross Reference listing using cobxref
--------------------------------------------

This program is found in the contrib area or by itself in Sourceforge
under its own name (‘cobxref’).

   The following shows the output from using ‘cobxref’ with the same
program example.

   Note that cobxref also reports the COPY depth which can be up to 9
and includes the program being compiled as depth 1.

Using cobxref with command cobxref prog.cbl :

ACS Cobol Xref v2.02.03          Dictionary File for PROG    25/11/2021  15:22:00:04
                                  Page    1

     1  000001 IDENTIFICATION   DIVISION.
     2  000002 PROGRAM-ID.      prog.
     3  000003 ENVIRONMENT DIVISION.
     4  000004 CONFIGURATION SECTION.
     5  000005 DATA             DIVISION.
     6  000006 WORKING-STORAGE  SECTION.
     7  000007*COPY 'values.cpy'.
     8  000001 78  I   VALUE 20.
     9  000002 78  J   VALUE 5000.
    10  000003 78  M   VALUE 5.
    11  000008 01  SETUP-REC.
    12  000009     05  FL1       PIC X(04).
    13  000010     05  FL2       PIC ZZZZZ.
    14  000011     05  FL3       PIC 9(04).
    15  000012     05  FL4       PIC 9(08) COMP.
    16  000013     05  FL5       PIC 9(04) COMP-4.
    17  000014     05  FL6       PIC Z,ZZZ.99.
    18  000015     05  FL7       PIC S9(05) SIGN LEADING SEPARATE.
    19  000016     05  FL8       PIC X(04).
    20  000017     05  FL9 REDEFINES FL8 PIC 9(04).
    21  000018     05  FLA.
    22  000019         10  FLB OCCURS I TIMES.
    23  000020             15  FLC PIC X(02).
    24  000021         10  FLD   PIC X(20).
    25  000022     05  FLD1      PIC X(100).
    26  000025     05  FLD3      PIC X(3).
    27  000026     05  FLD4      PIC X(4).
    28  000023     05  FLD2 OCCURS M TO J TIMES DEPENDING ON FL5.
    29  000024         10  FILLER PIC X(01).
    30  000027 PROCEDURE        DIVISION.
    31  000028     STOP RUN.
    32        *>>>Info: Total Copy Depth Used = 02
ACS Cobol Xref v2.02.03          Dictionary File for PROG    25/11/2021  15:22:00:04
                                  Page    2
Symbols of Module: PROG (PROG)
------------------------------

Data Section (WORKING-STORAGE)  Defn     Locations
-------------------------------+---------------------------------------------------------------

FL1                             000012W
FL2                             000013W
FL3                             000014W
FL4                             000015W
FL5                             000016W  000028
FL6                             000017W
FL7                             000018W
FL8                             000019W  000020
FL9                             000020W
FLA                             000021W
FLB                             000022W
FLC                             000023W
FLD                             000024W
FLD1                            000025W
FLD2                            000028W
FLD3                            000026W
FLD4                            000027W
I                               000008W  000022
J                               000009W  000028
M                               000010W  000028
SETUP-REC                       000011W
ACS Cobol Xref v2.02.03          Dictionary File for PROG    25/11/2021  15:22:00:04
                                  Page    3
Symbols of Module: PROG (PROG)
------------------------------
Procedure                       Defn     Locations
-------------------------------+---------------------------------------------------------------

None


File: gnucobpg.info,  Node: Compilation Time Environment Variables,  Next: Predefined Compilation Variables,  Prev: Cross Reference listing using cobxref,  Up: Compiling Programs

10.1.4 Compilation Time Environment Variables
---------------------------------------------

The following are the various environment variables that can play a role
in the compilation of GnuCOBOL programs.
‘COB_CC’
     Set to the name of the C compiler you wish GnuCOBOL to use.

     Use this feature at your own risk - you should always use the c
     compiler your gnucobol build was generated for.

‘COB_CFLAGS’
     Set to any switches that you'd like to pass on to the C compiler
     from the ‘cobc’ compiler (in addition to any that ‘cobc’ will
     specify).

‘COB_CONFIG_DIR’
     Set to the path to the folder where GnuCOBOL config files are kept.

‘COB_COPY_DIR’
     If copybooks your program needs are not stored in the same
     directory as your program, set this environment variable to the
     folder in which the copybooks may be found (IBM mainframe
     programmers will recognize this as ‘SYSLIB’).

‘COB_LDADD’
     Set to any additional linker switches (‘ld’) that can specify where
     standard libraries that must be linked with the program can be
     found.  The default is "" (empty).

‘COB_LDFLAGS’
     Set to any linker (‘ld’) switches that you'd like to pass on to the
     C compiler from the ‘cobc’ compiler (in addition to any that cobc
     will specify).

‘COB_LIBS’
     Set to any linker switches (‘ld’) that specify where standard
     libraries that must be linked with the program can be found.

‘COBCPY’
     This environment variable provides an additional means of
     specifying where copybooks may be found by the compiler (see also
     COB_COPY_DIR, above).

‘LD_LIBRARY_PATH’
     If you are planning on using static-linked subroutine libraries,
     set this variable to the path of the directory containing your
     libraries.

‘TMPDIR’
‘TMP’
     Set to a directory/folder appropriate to create temporary files in.
     The intermediate working files created by the compiler will be
     created here (and deleted once they're no longer needed).

     The variable ‘TMPDIR’ is checked for a valid path first; if that
     isn't set, then ‘TMP’ is checked.

     On a Windows system, the ‘TMP’ environment variable is normally set
     for you when you logon.  If you wish to use a different temporary
     folder, you may set ‘TMPDIR’ yourself and have no fear of
     disrupting other Windows software that relies on TMP.
* The starred environment variables above have default values,
  established when the version of GnuCOBOL you are using was built.  To
  see these default values, as well as other build-specific
  information, execute the command:
  
       cobc -i


File: gnucobpg.info,  Node: Predefined Compilation Variables,  Next: Locating Copybooks,  Prev: Compilation Time Environment Variables,  Up: Compiling Programs

10.1.5 Predefined Compilation Variables
---------------------------------------

GnuCOBOL defines compilation variables when certain conditions are true.

   If the condition associated with a variable is false, the variable is
not defined during compilations.

‘DEBUG’
     The ‘-d’ debug flag is specified.

‘EXECUTABLE’
     The module being compiled contains the main program.

‘GCCOMP’
     The size of a ‘COMP’ item is determined according to the GnuCOBOL
     scheme, where for a ‘PICTURE’ of length:
     1-2
          item has 1 byte

     3-4
          item has 2 bytes

     5-9
          item has 4 bytes

     10-18
          item has 8 bytes.
‘GNUCOBOL’
     GnuCOBOL is compiling the source unit.

‘HOSTSIGNS’
     A signed packed-decimal item's value may be considered ‘NUMERIC’ if
     the sign has value ‘X"F"’.

‘IBMCOMP’
     The size of a ‘COMP’ item is determined according to the IBM
     scheme, where for a ‘PICTURE’ of length:

     1-4
          item has 2 bytes

     5-9
          item has 4 bytes

     10-18
          item has 8 bytes.

‘MODULE’
     The module being compiled does not contain the main program.

‘NOHOSTSIGNS’
     A signed packed-decimal item's value may not be considered

‘NUMERIC’
     if the sign has value ‘X"F"’.

‘NOIBMCOMP’
     The size of a ‘COMP’ item is not determined according to the IBM
     scheme.

‘NOSTICKYLINKAGE’
     Sticky-linkage (linkage-section items remaining allocated between
     invocations) is not enabled.

‘NOTRUNC’
     Numeric data items are truncated according to their internal
     representation.

‘P64’
     Pointers are greater than 32 bits long

‘STICKY-LINKAGE’
     Sticky-linkage (linkage-section items remaining allocated between
     invocations) is enabled.

‘TRUNC’
     Numeric data items are truncated according to their ‘PICTURE’
     clauses.

     While still supported, this may well be removed in the future and
     should not be used.  See ‘GCCOMP’ and ‘GNUCOBOL’ instead:

‘OCCOMP’
     The size of a ‘COMP’ ITEM is determined according to the GnuCOBOL
     scheme, where for a ‘PICTURE’ of length:
     1 - 2
          ITEM = 1 byte

     3 - 4
          ITEM = 2 bytes

     5 - 9
          ITEM = 4 bytes

     10 - 18
          ITEM = 8 bytes

‘OPENCOBOL’
     GnuCOBOL is compiling the source unit.


File: gnucobpg.info,  Node: Locating Copybooks,  Next: Compiler Configuration Files,  Prev: Predefined Compilation Variables,  Up: Compiling Programs

10.1.6 Locating Copybooks
-------------------------

The GnuCOBOL compiler will attempt to locate copybooks by searching for
them in the following folders.  The search will occur in the sequence
shown below, and will terminate once a copybook is found.
  1. The folder named as the LIBRARY-NAME-1 on the ‘COPY’ statement
     (*note COPY::).

  2. The folder in which the program being compiled resides.

  3. The folder named on the ‘-I’ switch.

  4. Each of the folders named on the ‘COB_CPY_DIR’ compilation-time
     environment variable (*note Compilation Time Environment
     Variables::) in order of presentation.

  5. Each of the folders named on the ‘COBCPY’ compilation-time
     environment variable (*note Compilation Time Environment
     Variables::) in order of presentation.

     A single folder may be named or multiple folders may be specified,
     separated by a system-appropriate delimiter character.  When
     multiple folders are specified, they will be searched in the order
     they are named on the environment variable.

     If the GnuCOBOL compiler you are using was built to utilize a
     native Windows environment, use a semicolon (‘;’) as the delimiter
     character.

     If, however, the GnuCOBOL compiler was built for a Unix, OSX or
     Linux environment, or was built for a Windows environment utilizing
     either the Cygwin or MinGW Unix emulators, use a colon character
     (‘:’) as the delimiter.

  6. For v1.1 only, the single folder specified on the COB_COPY_DIR
     environment variable.  (If not defined, for order see results of
     'cobc -info').

   As each of the above folders is searched for a copybook -- ‘COPY
XXXXXXXX.’, for example -- the GnuCOBOL compiler will attempt to locate
the copybook file by any of the following names, in the sequence shown:
     ‘XXXXXXXX.CPY’

     ‘XXXXXXXX.CBL’

     ‘XXXXXXXX.COB’

     ‘XXXXXXXX.cpy’

     ‘XXXXXXXX.cbl’

     ‘XXXXXXXX.cob’

     ‘XXXXXXXX’

   The ‘COPY’ statement is case-sensitive on UNIX systems; ‘COPY
copybookname’ and ‘COPY COPYBOOKNAME’ will both fail to locate the
‘CopyBookName’ copybook on a UNIX system.

   Windows implementations of GnuCOBOL may, or may not, be similarly
case sensitive with regard to copybook names, depending upon the Windows
version and GnuCOBOL build options -- it is safest to simply treat the
COPY command as case-sensitive in all environments.

   It is possible, however, to automatically cause all ‘COPY’ statements
to "fold" the names of all copybooks to upper-case by specifying the
‘-ffold-copy’ switch with the ‘upper’ option (i.e.  ‘--fold-copy=upper’)
to the GnuCOBOL compiler.  Similarly, names could be folded to
lower-case by using the ‘lower’ option (i.e.  ‘--fold-copy=lower’.  If
copybook libraries are maintained entirely using upper- or lower-case
file names and extensions, either of these options will allow copybooks
to be found regardless of how the programmer entered their names on
‘COPY’ statements.

   Case-folding may also be turned on and off within the program source
code using the CDF ‘>>SET’ statement (*note >>SET::).


File: gnucobpg.info,  Node: Compiler Configuration Files,  Prev: Locating Copybooks,  Up: Compiling Programs

10.1.7 Compiler Configuration Files
-----------------------------------

GnuCOBOL uses compiler configuration files to define various options
that will control the compilation process.  These configuration files
are specified using the ‘-conf’ switch compilation switch and are found
in the folder defined by the ‘COB_CONFIG_DIR’ compilation-time
environment variable (*note Compilation Time Environment Variables::).

   If this is not defined under *nix it will default to
‘/usr/local/share/gnucobol/config’.

   The following is a verbatim listing of the default configuration file
(the one used if you don't specify the ‘-conf’ switch), just to show you
the types of settings that may appear and taken from v3.1.2 :
# GnuCOBOL compiler configuration
#
# Copyright (C) 2001-2012, 2014-2020 Free Software Foundation, Inc.
# Written by Keisuke Nishida, Roger While, Simon Sobisch, Edward Hart,
# Ron Norman
#
# This file is part of GnuCOBOL.
#
# The GnuCOBOL compiler is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# GnuCOBOL is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GnuCOBOL.  If not, see <https://www.gnu.org/licenses/>.


# Value: any string
name: "GnuCOBOL"

# Value: enum
standard-define			0
#        CB_STD_GC = 0,
#        CB_STD_MF,
#        CB_STD_IBM,
#        CB_STD_MVS,
#        CB_STD_BS2000,
#        CB_STD_ACU,
#        CB_STD_85,
#        CB_STD_2002,
#        CB_STD_2014

# Value: int
tab-width:			8
text-column:			72
# Maximum word-length for COBOL words / Programmer defined words
# Be aware that GC checks the word length against COB_MAX_WORDLEN
# first (currently 63)
word-length:			63

# Maximum literal size in general
literal-length:			8191

# Maximum numeric literal size (absolute maximum: 38)
numeric-literal-length:		38

# Maximum number of characters allowed in the character-string (max. 255)
pic-length:			255

# Default assign type
# Value: 'dynamic', 'external'
assign-clause:			dynamic

# If yes, file names are resolved at run time using
# environment variables.
# For example, given ASSIGN TO "DATAFILE", the file name will be
#  1. the value of environment variable 'DD_DATAFILE' or
#  2. the value of environment variable 'dd_DATAFILE' or
#  3. the value of environment variable 'DATAFILE' or
#  4. the literal "DATAFILE"
# If no, the value of the assign clause is the file name.
#
filename-mapping:		yes

# Alternate formatting of numeric fields
pretty-display:			yes

# Allow complex OCCURS DEPENDING ON
complex-odo:			no

# Allow REDEFINES to other than last equal level number
indirect-redefines:		no

# Binary byte size - defines the allocated bytes according to PIC
# Value:         signed  unsigned  bytes
#                ------  --------  -----
# '2-4-8'        1 -  4    same        2
#                5 -  9    same        4
#               10 - 18    same        8
#
# '1-2-4-8'      1 -  2    same        1
#                3 -  4    same        2
#                5 -  9    same        4
#               10 - 18    same        8
#
# '1--8'         1 -  2    1 -  2      1
#                3 -  4    3 -  4      2
#                5 -  6    5 -  7      3
#                7 -  9    8 -  9      4
#               10 - 11   10 - 12      5
#               12 - 14   13 - 14      6
#               15 - 16   15 - 16      7
#               17 - 18   17 - 18      8
#
binary-size:			1-2-4-8

# Numeric truncation according to ANSI
binary-truncate:		yes

# Binary byte order
# Value: 'native', 'big-endian'
binary-byteorder:		big-endian

# Allow larger REDEFINES items
larger-redefines-ok:		no

# Allow certain syntax variations (eg. REDEFINES position)
relax-syntax-checks:		no

# Allow zero length reference-modification
# (only checked with active EC-BOUND-REF-MOD)
ref-mod-zero-length:		yes

# Perform type OSVS - If yes, the exit point of any currently
# executing perform is recognized if reached.
perform-osvs:			no

# Compute intermediate decimal results like IBM OSVS
arithmetic-osvs:		no

# MOVE like IBM (mvc); left to right, byte by byte
move-ibm:			no

# SELECT RELATIVE KEY and ASSIGN fields must be in WORKING-STORAGE
select-working:		no

# LOCAL-STORAGE SECTION implies RECURSIVE attribute
local-implies-recursive:		no

# If yes, LINKAGE SECTION items remain allocated
# between invocations.
sticky-linkage:			no

# If yes, allow non-matching level numbers
relax-level-hierarchy:		no

# If yes, evaluate constant expressions at compile time
constant-folding:		yes

# Allow Hex 'F' for NUMERIC test of signed PACKED DECIMAL field
hostsign:			no

# If yes, set WITH UPDATE clause as default for ACCEPT dest-item,
# except if WITH NO UPDATE clause is used
accept-update:			no

# If yes, set WITH AUTO clause as default for ACCEPT dest-item,
# except if WITH TAB clause is used
accept-auto:			no

# If yes, DISPLAYs and ACCEPTs are, by default, done on the CRT (i.e., using
# curses).
console-is-crt:			no

# If yes, allow redefinition of the current program's name. This prevents its
# use in a prototype-format CALL/CANCEL statement.
program-name-redefinition:	yes

# If yes, NO ECHO/NO-ECHO/OFF is the same as SECURE (hiding input with
# asterisks, not spaces).
no-echo-means-secure:		no

# If yes, the first item in a field screen ACCEPT/DISPLAY (e.g. DISPLAY x UPON
# CRT) is located after the previous ACCEPT/DISPLAY (as though LINE 0 COL 0 had
# been specified).
line-col-zero-default:		yes

# If yes, DISPLAY SPACES acts as ERASE EOS, DISPLAY X"01" acts as ERASE EOL,
# DISPLAY X"02" acts as BLANK SCREEEN and DISPLAY X"07" acts as BELL. Note
# DISPLAY LOW-VALUE is excluded from this; it will always just position the
# cursor.
display-special-fig-consts:	no

# If yes, COMP-1 is a signed 16-bit integer and any PICTURE clause is ignored.
binary-comp-1:			no

# If yes, POINTER is handled as BINARY-DOUBLE UNSIGNED instead of its own class
numeric-pointer:		no

# auto-adjust to zero like MicroFocus does
move-non-numeric-lit-to-numeric-is-zero: no

# If yes, implicitly define a variable for an ASSIGN DYNAMIC which does not
# match an existing data item.
implicit-assign-dynamic-var:	yes

# What rules to apply to SCREEN SECTION items clauses
screen-section-rules:		gc

# Whether DECIMAL-POINT IS COMMA has effect in XML/JSON GENERATE
dpc-in-data:			xml

# Dialect features
# Value: 'ok', 'warning', 'archaic', 'obsolete', 'skip', 'ignore', 'error',
#        'unconformable'

alter-statement:			obsolete
comment-paragraphs:			obsolete
call-overflow:				archaic
data-records-clause:			obsolete
debugging-mode:				ok
use-for-debugging:			ok
listing-statements:			skip	# may be a user-defined word
title-statement:			skip	# may be a user-defined word
entry-statement:			ok
goto-statement-without-name:		obsolete
label-records-clause:			obsolete
memory-size-clause:			obsolete
move-noninteger-to-alphanumeric:	error
move-figurative-constant-to-numeric:	archaic
move-figurative-space-to-numeric:	error
move-figurative-quote-to-numeric:	obsolete
multiple-file-tape-clause:		obsolete
next-sentence-phrase:			archaic
odo-without-to:				warning
padding-character-clause:		obsolete
section-segments:			ignore
stop-literal-statement:			obsolete
stop-identifier-statement:		obsolete
same-as-clause:				ok
type-to-clause:				ok
usage-type:					ok
synchronized-clause:			ok
special-names-clause:			ok
top-level-occurs-clause:		ok
value-of-clause:			obsolete
numeric-boolean:			ok
hexadecimal-boolean:			ok
national-literals:			ok
hexadecimal-national-literals:		ok
national-character-literals:		warning
# TO-DO: Add separate config option for H"..." to be unsupported,numeric,non-numeric(acu)
acu-literals:				unconformable
hp-octal-literals:			unconformable
word-continuation:			warning
not-exception-before-exception:		ok
accept-display-extensions:		ok
renames-uncommon-levels:		ok
symbolic-constant:			ok
constant-78:				ok
constant-01:				ok
perform-varying-without-by:		ok
reference-out-of-declaratives:		warning
program-prototypes:			ok
call-convention-mnemonic:		ok
call-convention-linkage:		ok
numeric-value-for-edited-item:		ok
incorrect-conf-sec-order:		ok
define-constant-directive:		archaic
free-redefines-position:		warning
records-mismatch-record-clause	warning
record-delimiter:			ok
sequential-delimiters:			ok
record-delim-with-fixed-recs:		ok
missing-statement:			warning
zero-length-literals:			ok
xml-generate-extra-phrases:		ok
continue-after:				ok
goto-entry:				warning
assign-variable:			ok
assign-using-variable:			ok
assign-ext-dyn:				ok
assign-disk-from:			ok
vsam-status:				ignore

# use complete word list; synonyms and exceptions are specified below
reserved-words:		default

# not-reserved:
# Value: Word to be taken out of the reserved words list
not-reserved:	TERMINAL
# reserved:
#   Entries of the form word-1=word-2 define word-1 as an alias for default
# reserved word word-2. No spaces are allowed around the equal sign.
reserved:	AUTO-SKIP=AUTO
reserved:	AUTOTERMINATE=AUTO
reserved:	BACKGROUND-COLOUR=BACKGROUND-COLOR
reserved:	BEEP=BELL
reserved:	BINARY-INT=BINARY-LONG
reserved:	BINARY-LONG-LONG=BINARY-DOUBLE
reserved:	CELLS=CELL
reserved:	COLOURS=COLORS
reserved:	EMPTY-CHECK=REQUIRED
reserved:	EQUALS=EQUAL
reserved:	FOREGROUND-COLOUR=FOREGROUND-COLOR
reserved:	HIGH-VALUES=HIGH-VALUE
reserved:	INITIALISE=INITIALIZE
reserved:	INITIALISED=INITIALIZED
reserved:	LENGTH-CHECK=FULL
reserved:	LOW-VALUES=LOW-VALUE
reserved:	ORGANISATION=ORGANIZATION
reserved:	PIXELS=PIXEL
reserved:	SYNCHRONISED=SYNCHRONIZED
reserved:	TIMEOUT=TIME-OUT
reserved:	VALUES=VALUE
reserved:	ZEROES=ZERO
reserved:	ZEROS=ZERO



File: gnucobpg.info,  Node: Running Programs,  Next: Binary Truncation,  Prev: Compiling Programs,  Up: Interfacing With The OS

10.2 Running Programs
=====================

Once GnuCOBOL programs have been compiled into either
directly-executable programs (created via the ‘-x’ switch) or
dynamically-loadable libraries (created via the ‘-m’ switch), those
programs may be executed from any shell environment.  The exact manner
in which the two are executed will differ, as described in the upcoming
sections.

* Menu:

* Direct Execution::
* Executing Dynamically-Loadable Libraries::
* Run Time Environment Variables::
* Program Arguments::


File: gnucobpg.info,  Node: Direct Execution,  Next: Executing Dynamically-Loadable Libraries,  Up: Running Programs

10.2.1 Direct Execution
-----------------------

GnuCOBOL programs compiled with the ‘-x’ switch will be generated as
directly-executable programs.  For example, a native Windows or
Windows/MinGW build of GnuCOBOL will generate an ‘.exe’ file when the
‘-x’ switch switch is specified to the compiler.

   On Unix, OSX, or Windows/Cygwin builds, the ‘-x’ switch switch will
generate an executable binary file, usually with no particular extension
unless one is explicitly requested of the compiler via the ‘-o’ switch.

   On a UNIX system this means the programs may be executed from a
command shell such as bash, csh, ksh and so forth.  When a GnuCOBOL
program runs on a Windows system, it runs within a console window (i.e.
‘cmd.exe’).  OSX versions of GnuCOBOL programs run within a
‘terminal.app’ window.

   Interactions between the program and the user will take place using
the standard input, standard output and standard error streams.  Any
screen section I/O performed by the program will take place within the
terminal window.

   Direct program execution syntax is ‘[PATH]PROGRAM [ARGUMENTS]’.

   For example:

     /usr/local/printaccount ACCT=6625378

   or

     C:\\Users\\Me\\Documents\\Programs\\printaccount.exe ACCT=6625378


File: gnucobpg.info,  Node: Executing Dynamically-Loadable Libraries,  Next: Run Time Environment Variables,  Prev: Direct Execution,  Up: Running Programs

10.2.2 Executing Dynamically-Loadable Libraries
-----------------------------------------------

As discussed previously, dynamically-loadable libraries are created via
the compiler's ‘-m’ switch.  Once so created, the program(s) in these
libraries are executed from the command line (via the GnuCOBOL ‘cobcrun’
utility), or as dynamically-loadable subprograms.

* Menu:

* cobcrun - Command-line Execution::
* Dynamically Loaded Subprograms::


File: gnucobpg.info,  Node: cobcrun - Command-line Execution,  Next: Dynamically Loaded Subprograms,  Up: Executing Dynamically-Loadable Libraries

10.2.2.1 cobcrun - Command-line Execution
.........................................

It is possible to generate executable modules for all GnuCOBOL programs,
not just subprograms, by choosing to use the ‘-m’ switch option to
specify the loader output format, even for main programs.

   Some may prefer to compile their GnuCOBOL main programs into these
dynamically-loadable modules in the interests of using the same general
compilation command for all programs without having to think "Is it a
main program or a subprogram?".

   Main programs compiled in this manner should be executed as follows:

     [path]cobcrun program [arguments]

   Do not specify the ‘.so’ or ‘.dll’ extension on the program name.
The program value must exactly match the primary entry-point name of the
main program (including upper- and lower-case letters), unless you are
planning on using Call Folding (*note Dynamically Loaded Subprograms::).

   The general usage and syntax of cobcrun is as follows as issued by
running cobcrun -h (or -help) :
GnuCOBOL module loader

Usage: cobcrun [options] PROGRAM [parameter ...]
  or:  cobcrun options

Options:
  -h, -help                      display this help and exit
  -V, -version                   display cobcrun and runtime version and exit
  -i, -info                      display runtime information (build/environment)
  -v, -verbose                   display extended output with --info
  -c <file>, -config=<file>      set runtime configuration from <file>
  -r, -runtime-config            display current runtime configuration
                                 (value and origin for all settings)
  -M <module>, -module=<module>  set entry point module name and/or load path
                                 where -M module prepends any directory to the
                                 dynamic link loader library search path
                                 and any basename to the module preload list
                                 (COB_LIBRARY_PATH and/or COB_PRELOAD)

   Here are two examples of using ‘cobcrun’.  First, on a Unix, OSX or
Windows/Cygwin system:

     cd /usr/local
     cobcrun printaccount acct=6625378

   Or, on a Native Windows or Windows/MinGW system:

     cd C:\Users\Me\Documents\Programs
     cobcrun printaccount.exe acct=6625378

   Note how the ‘cobcrun’ command does not allow a path to be specified
with the program name -- the directory in which the programs dynamically
loadable module exists must either be the current directory or must be
defined in the current ‘PATH’.


File: gnucobpg.info,  Node: Dynamically Loaded Subprograms,  Prev: cobcrun - Command-line Execution,  Up: Executing Dynamically-Loadable Libraries

10.2.2.2 Dynamically Loaded Subprograms
.......................................

Dynamically-loaded subprograms are executed (from a COBOL syntax point
of view) just like any other subprograms.  What makes them unique,
however, is that they are loaded into memory only when they are actually
used the first time during the execution of a program.

   When a dynamically-loadable module needs to be loaded (because it is
not already in memory from a previous subprogram execution), the
dynamically-loadable library will be sought by libcob in each directory
named in the library specified by the ‘COB_LIBRARY_PATH’ run-time
environment variable will be searched and if not found then.  Finally,
if it still cannot be located, execution will be terminated with an
error message (libcob: Cannot find module 'xxxxxxxx').  For speed
performance purposes all such should therefore be stored within the
directories pointed to by the environment variable ‘COB_LIBRARY_PATH’
run-time environment variable.

   The process of locating dynamically-loadable modules is case
sensitive on UNIX systems; ‘CALL "dynsub"’ and ‘CALL "DYNSUB"’ will both
fail to locate the ‘DynSub.so’ library on a UNIX system.

   Windows implementations of GnuCOBOL may, or may not, be similarly
case sensitive with regard to library names, depending upon the Windows
version and GnuCOBOL build options -- it is safest to simply treat
library names as case sensitive in all environments.

   It is possible, however, to automatically cause all library names to
'fold' to upper-case by specifying the ‘-ffold-call’ switch with the
"upper" option (i.e.  ‘--fold-call=upper’) to the GnuCOBOL compiler.
Similarly, library names could be folded to lower-case by using the
"lower" option (i.e.  ‘--fold-call=lower’.  If libraries are maintained
entirely using upper- or lower-case file names, either of these options
will allow libraries to be found regardless of how the programmer
entered their names on ‘CALL’ statements.

   *Note Sub-Programming::, for a complete discussion of
sub-programming.


File: gnucobpg.info,  Node: Run Time Environment Variables,  Next: Program Arguments,  Prev: Executing Dynamically-Loadable Libraries,  Up: Running Programs

10.2.3 Run Time Environment Variables
-------------------------------------

The following is a list of the various environment variables that can
play a role in the execution of GnuCOBOL programs.
‘COB_DISPLAY_WARNINGS’
     If set to a value of ‘Y’, any run-time warnings (such as noting the
     implicit closing of open files when a ‘GOBACK’ statement (*note
     GOBACK::) or ‘STOP’ statement (*note STOP::) with the ‘RUN’ option
     is executed) will be displayed.  Any other value for this
     environment variable (including not setting the variable at all)
     will suppress such messages.
‘COB_LIBRARY_PATH’
     At runtime, GnuCOBOL will attempt to locate and load any
     application dynamically loadable libraries used this variable that
     points to the directories specified, if it wasn't found there,
     using the ‘PATH’ environment variable.
‘COB_LOAD_CASE’
     If set to either ‘UPPER’ or ‘LOWER’, this environment variable will
     internally convert referenced entry point names to either upper- or
     lower-case before initiating searches for dynamically loadable
     modules.  The ‘UPPER’ and ‘LOWER’ values of the environment
     variable are actually case insensitive.
‘COB_PHYSICAL_CANCEL’
     If set to ‘Y’, ‘y’ or ‘1’, a ‘CANCEL’ statement (*note CANCEL::)
     will physically unload a subprogram dynamically loadable module.
     If set to anything else, a ‘CANCEL’ statement (*note CANCEL::)
     logically unloads a module so that subsequent use will
     re-initialize the module as if it had actually been reloaded, but
     the overhead of actually reloading the module will be avoided.
‘COB_PRE_LOAD’
     If set to any non-null value, this variable will cause all
     dynamically loadable libraries to be loaded when the program begins
     execution (rather than searching for and loading the module upon
     first use).
‘COB_SET_DEBUG’
     If a ‘USE FOR DEBUGGING’ (*note DECLARATIVES::) section exists, the
     code within it will be disabled unless this environment variable is
     set to a value of ‘Y’, ‘y’ or ‘1’.
‘COB_SET_TRACE’
     If the ‘-ftrace’ switch (trace procedures) or ‘-ftraceall’ switch
     (trace procedures and statements) was used when the program was
     compiled, setting this environment variable to a value of ‘Y’ will
     activate the trace at the point the program begins execution.
     Setting this environment variable to any other value (or never
     setting it to ANY value) will disable tracing.  Tracing, if
     configured by one of the two switches described above, can also be
     controlled via the the ‘READY TRACE’ statement (*note READY
     TRACE::) and ‘RESET TRACE’ statement (*note RESET TRACE::).  If
     COB_SET_TRACE is set to Y, then tracing will always occur
     regardless of the presence of READY TRACE or RESET TRACE so in
     effect they will have no action on program execution.
‘COB_SCREEN_ESC’
     If set to any non-blank value, this variable allows a ‘ACCEPT
     data-item’ statement (*note ACCEPT data-item::) to detect the ‘Esc’
     key.
‘COB_SCREEN_EXCEPTIONS’
     Setting this variable to any non-blank value will allow the ‘ACCEPT
     data-item’ statement (*note ACCEPT data-item::) to detect the
     pressing of the ‘Esc’, ‘PgUp’ and ‘PgDn’ keys.
‘COB_SORT_MEMORY’
     The value of this variable (an integer) will be used to define how
     much memory will be allocated for use in sorting.  If the value is
     1048576 or greater, that value will be used "as is" as the amount
     of memory (in bytes) to allocate.  If the value is less than
     1048576, the value will specify how many MB of memory will be
     allocated.  The default sort memory amount is 128 MB.
‘COB_SWITCH_n’
     (n=0 to 15); These environment variables correspond to ‘SWITCH-0’
     through ‘SWITCH-15’, defined in the ‘SPECIAL-NAMES’ (*note
     SPECIAL-NAMES::) paragraph.  Setting them to ‘ON’ will activate
     them; any other value turns them off.
‘COB_SYNC’
     If set to a value of upper- or lower-case ‘p’, this variable will
     force a file commit every time a file is written to (ensuring that
     data is immediately written to the file rather than retained in
     memory until a future commit occurs).  This will slow-down update
     access to files, but will provide for better integrity in the event
     of a program failure.
‘COB_TRACE_FILE’
     If set to any non-null value, this environment variable specifies
     the file to which all ‘-ftrace’ switch and ‘-ftraceall’ switch
     output will be written.  If this is NOT set to a value, all
     ‘-ftrace’ switch and ‘-ftraceall’ switch output will be written to
     STDERR, where it may be piped via a "2> filename" on the command
     that executes the program.
‘DB_HOME’
     If your GnuCOBOL build uses the Berkeley Database (BDB) package,
     use this environment variable to specify the folder in which the
     lock management files to be associated with all non-SORT files
     opened by the program will be stored.  ‘ORGANIZATION INDEXED’
     (*note ORGANIZATION INDEXED::) files will also have their data file
     allocated in the folder pointed to by this environment variable, if
     it exists..  Having this variable defined will activate record
     locking features on the ‘READ’ statement (*note READ::), ‘REWRITE’
     statement (*note REWRITE::) and ‘WRITE’ statement (*note WRITE::).
     Even with DB_HOME, locking will not work with ‘ORGANIZATION
     SEQUENTIAL’ (*note ORGANIZATION SEQUENTIAL::), ‘ORGANIZATION LINE
     SEQUENTIAL’ (*note ORGANIZATION LINE SEQUENTIAL::) or ORGANIZATION
     RELATIVE files with GnuCOBOL builds created for Windows/MinGW.
     ‘ORGANIZATION INDEXED’ locks will work with Windows/MinGW + BDB and
     all locks will work for all file organizations with UNIX GnuCOBOL
     builds.
‘PATH’
     The GnuCOBOL "bin" directory should be defined in the PATH.
‘TMPDIR’
‘TMP’
‘TEMP’
     One of these environment variables must be set to a
     directory/folder appropriate to create temporary files in.  They
     will be checked in the order shown.  This will be used by the
     ‘SORT’ statement (*note SORT::) and ‘MERGE’ statement (*note
     MERGE::) to create temporary work files.  You may also use this
     folder for any temporary files your application may require.
   Also used during execution of programs is runtime.cfg also found in
‘/usr/local/share/gnucobol/config’ for *nix and this file can also be
changed to match your environment if needed.  When viewing, note the
Default settings.

* Menu:

* General instructions::
* General Environment::
* Call Environment::
* File I/O::
* Screen I/O::
* Report I/O::
* File I/O Environment Variables and/or dictionary file::


File: gnucobpg.info,  Node: General instructions,  Next: General Environment,  Up: Run Time Environment Variables

10.2.3.1 General instructions
.............................

 The initial runtime.cfg file is found in the  $COB_CONFIG_DIR/config
 (  COB_CONFIG_DIR  defaults to  installdir/gnucobol  ).
 The environment variable  COB_RUNTIME_CONFIG  may define a different runtime
 configuration file to read.

 If settings are included in the runtime environment file multiple times
 then the last setting value is used, no warning occurs.

 Settings via environment variables always take precedence over settings
 that are given in runtime configuration files. And the environment is
 checked after completing processing of the runtime configuration file(s)

 All values set to string variables or environment variables are checked
 for  ${envvar}  and replacement is done at the time of the setting.

 Any environment variable may be set with the directive  setenv  .
 Example:  setenv COB_LIBRARY_PATH ${LD_LIBRARY_PATH}

 Any environment variable may be unset with the directive  unsetenv
 (one var per line).
 Example:  unsetenv COB_LIBRARY_PATH

 Runtime configuration files can include other files with the directive
 include.
 Example:  include my-runtime-configuration-file

 To include another configuration file only if it is present use the directive
 includeif.
 You can also use  ${envvar}  inside this.
 Example:  includeif ${HOME}/mygc.cfg

 If you want to reset a parameter to its default value use:
    reset parametername

 Most runtime variables have boolean values, some are switches, some have
 string values, integer values and some are size values.
 The boolean values will be evaluated as following:
       to true:          1, Y, ON, YES, TRUE  (no matter of case)
       to false:         0, N, OFF
 A 'size' value is an integer optionally followed by K, M, or G for kilo, mega
 or giga.

 For convenience a parameter in the runtime.cfg file may be defined by using
 either the environment variable name or the parameter name.
 In most cases the environment variable name is the parameter name (in upper
 case) with the prefix  COB_  .

 Note: If you want to *slightly* speed up a program's startup time, remove all
       of the comments from the actual real configuration file that is processed



File: gnucobpg.info,  Node: General Environment,  Next: Call Environment,  Prev: General instructions,  Up: Run Time Environment Variables

10.2.3.2 General Environment
............................


 Environment name:  COB_DISABLE_WARNINGS
   Parameter name:  disable_warnings
          Purpose:  turn off runtime warning messages
             Type:  boolean
          Default:  false
          Example:  DISABLE_WARNINGS  TRUE

 Environment name:  COB_ENV_MANGLE
   Parameter name:  env_mangle
          Purpose:  names checked in the environment would get non alphanumeric
                    change to '_'
             Type:  boolean
          Default:  false
          Example:  ENV_MANGLE  TRUE

 Environment name:  COB_SET_DEBUG
   Parameter name:  debugging_mode
          Purpose:  to enable USE ON DEBUGGING procedures that were active
                    during compile-time because of WITH DEBUGGING MODE,
                    otherwise the code generated will be skipped
             Type:  boolean
          Default:  false
          Example:  COB_SET_DEBUG  1

 Environment name:  COB_SET_TRACE
   Parameter name:  set_trace
          Purpose:  to enable COBOL trace feature
             Type:  boolean
          Default:  false
          Example:  SET_TRACE  TRUE

 Environment name:  COB_TRACE_FILE
   Parameter name:  trace_file
          Purpose:  to define where COBOL trace output should go
             Type:  string
          Default:  stderr
          Example:  TRACE_FILE  ${HOME}/mytrace.log

 Environment name:  COB_TRACE_FORMAT
   Parameter name:  trace_format
          Purpose:  to define format of COBOL trace output
             Type:  string
          Default:  "%P %S Line: %L"
                    %P is replaced by Program-Id/Function-Id minimal length 29
                       with prefix
                    %I is replaced by Program-Id/Function-Id variable length,
                       without prefix
                    %L is replaced by Line number, right justified, length 6
                    %S is replaced by statement type and name
                    %F is replaced by source file name
          Example:  TRACE_FORMAT  "Line: %L %S"
             Note:  format of GC2.2 and older:
                    "PROGRAM-ID: %I    Line: %L        %S"

For v4.0+
 Environment name:  COB_TRACE_IO
  Parameter name:  trace_io
         Purpose:  define if I/O details should be added to trace
            Type:  boolean
         Default:  false
         Example:  TRACE_IO true

 Environment name:  COB_DUMP_FILE
   Parameter name:  dump_file
          Purpose:  to define where COBOL dump output should go
             Note:  The -fdump=all compile option prepares for dump
             Type:  string       : $$ is replaced by process id
          Default:  stderr
          Example:  DUMP_FILE  ${HOME}/mytrace.log

 Environment name:  COB_DUMP_WIDTH
   Parameter name:  dump_width
          Purpose:  to define COBOL dump line length
             Type:  integer
          Default:  100
          Example:  dump_width 120

For v4.0+
 Environment name:  COB_STATS_RECORD
  Parameter name:  stats_record
         Purpose:  define if I/O statistics should be written
            Type:  boolean
         Default:  false
         Example:  STATS_RECORD true

For v4.0+
 Environment name:  COB_STATS_FILE
  Parameter name:  stats_file
         Purpose:  to define where COBOL I/O statistics should be written
                   The file is appended to
            Type:  string
         Default:  stderr
         Example:  STATS_FILE  ${HOME}/mystats.txt

 Environment name:  COB_CURRENT_DATE
   Parameter name:  current_date
          Purpose:  specify an alternate Date/Time to be returned to ACCEPT
                    clauses this is used for testing purposes or to tweak
                    a missing offset partial setting is allowed
             Type:  numeric string in format YYYYDDMMHH24MISS or date string
          Default:  the operating system date is used
          Example:  COB_CURRENT_DATE "2016/03/16 16:40:52"
                    current_date YYYYMMDDHHMMSS+01:00


File: gnucobpg.info,  Node: Call Environment,  Next: File I/O,  Prev: General Environment,  Up: Run Time Environment Variables

10.2.3.3 Call Environment
.........................


 Environment name:  COB_LIBRARY_PATH
   Parameter name:  library_path
          Purpose:  paths for dynamically-loadable modules
             Type:  string
             Note:  the default paths .:/installpath/extras are always
                    added to the given paths
          Example:  LIBRARY_PATH    /opt/myapp/test:/opt/myapp/production

 Environment name:  COB_PRE_LOAD
   Parameter name:  pre_load
          Purpose:  modules that are loaded during startup, can be used
                    to CALL COBOL programs or C functions that are part
                    of a module library
             Type:  string
             Note:  the modules listed should NOT include extensions, the
                    runtime will use the right ones on the various platforms,
                    COB_LIBRARY_PATH is used to locate the modules
          Example:  PRE_LOAD      COBOL_function_library:external_c_library

 Environment name:  COB_LOAD_CASE
   Parameter name:  load_case
          Purpose:  resolve ALL called program names to UPPER or LOWER case
             Type:  Only use  UPPER  or  LOWER
          Default:  if not set program names in CALL are case sensitive
          Example:  LOAD_CASE  UPPER

 Environment name:  COB_PHYSICAL_CANCEL
   Parameter name:  physical_cancel
          Purpose:  physically unload a dynamically-loadable module on CANCEL,
                    this frees some RAM and allows the change of modules during
                    run-time but needs more time to resolve CALLs (both to
                    active and not-active programs)
            Alias:  default_cancel_mode, LOGICAL_CANCELS (0 = yes)
             Type:  boolean (evaluated for true only)
          Default:  false
          Example:  PHYSICAL_CANCEL  TRUE



File: gnucobpg.info,  Node: File I/O,  Next: Screen I/O,  Prev: Call Environment,  Up: Run Time Environment Variables

10.2.3.4 File I/O
.................


 Environment name:  COB_VARSEQ_FORMAT
   Parameter name:  varseq_format
          Purpose:  declare format used for variable length sequential files
                    - different types and lengths precede each record
                    - 'length' is the data length, does not include the prefix
             Type:  0   means 2 byte record length (big-endian) + 2 NULs
                    1   means 4 byte record length (big-endian)
                    2   means 4 byte record length (local machine int)
                    3   means 2 byte record length (big-endian)
          Default:  0
          Example:  VARSEQ_FORMAT 1

For v4.0+
 Environment name: COB_VARREL_FORMAT
  Parameter name: varrel_format
         Purpose: declare format to be used for variable length relative files
            Type: gc  means 'size_t' record length (local machine) precedes
                            maxiumum length data record
                  mf  means file is in Micro Focus format
                 b32  means Big-Endian 32-bit 'int' record length precedes data
                 b64  means Big-Endian 64-bit 'int' record length precedes data
                 l32  means Little-Endian 32-bit 'int' record length precedes data
                 l64  means Little-Endian 64-bit 'int' record length precedes data
         Default: gc
            NOTE: 'gc' results in files which cannot be used if copied between
                       machines of different hardware archeticture
         Example: VARREL_FORMAT mf

For v4.0+
 Environment name:  COB_FIXREL_FORMAT
  Parameter name:  fixrel_format
         Purpose:  declare format to be used for fixed length relative
                   files (different types and lengths preceding each record)
            Type:  b32 means 4 byte record length (big-endian)
                   l32 means 4 byte record length (little-endian)
                   b64 means 8 byte record length (big-endian)
                   l64 means 8 byte record length (little-endian)
                   mf  means Micro Focus default
                   gc  means GnuCOBOL default (local 'size_t')
         Default:  gc  fixed size with no record length prefix
         Example:  FIXREL_FORMAT B32

For v4.0+
 Environment name: COB_VARFIX_FORMAT
  Parameter name: varfix_format
         Purpose: declare format to be used for fixed length relative files
            Type: gc  means 'size_t' record length (local machine) precedes
                            fixed length data record
                  mf  means file is in Micro Focus format
                 b32  means Big-Endian 32-bit 'int' record length precedes data
                 b64  means Big-Endian 64-bit 'int' record length precedes data
                 l32  means Little-Endian 32-bit 'int' record length precedes data
                 l64  means Little-Endian 64-bit 'int' record length precedes data
         Default: gc
            NOTE: 'gc' results in files which cannot be used if copied between
                       machines of different hardware archeticture
         Example: VARFIX_FORMAT mf

 Environment name:  COB_FILE_PATH
   Parameter name:  file_path
          Purpose:  define default location where data files are stored
             Type:  file path directory
          Default:  .  (current directory)
          Example:  FILE_PATH ${HOME}/mydata

 Environment name:  COB_LS_FIXED
   Parameter name:  ls_fixed
          Purpose:  Defines if LINE SEQUENTIAL files should be fixed length
                    (or variable, by removing trailing spaces)
            Alias:  STRIP_TRAILING_SPACES  (0 = yes)
             Type:  boolean
          Default:  false
          Example:  LS_FIXED TRUE

 Environment name:  COB_LS_NULLS
   Parameter name:  ls_nulls
          Purpose:  Defines for LINE SEQUENTIAL files what to do with data
                    which is not DISPLAY type.  This could happen if a LINE
                    SEQUENTIAL record has BINARY/COMP data fields in it.
                    For v4.0+ (may change before its release candidate)
                    This option is only for GnuCOBOL format files
             Type:  boolean
          Default:  false
             Note:  The TRUE setting will insert a null character x"00" before
                    those values to escape them, and redo on read-in.
          Example:  LS_NULL = TRUE

For v4.0+
Environment name:  COB_LS_SPLIT
  Parameter name:  ls_split
         Purpose:  Defines for LINE SEQUENTIAL files what to do when a record
                   is longer than the program handles. If 'ls_split=true' then
                   the data is returned as multiple records
            Type:  boolean
         Default:  false
                   The record is truncated and the file skips to the next LF
         Example:  LS_SPLIT = TRUE

For v4.0+
Environment name:  COB_LS_VALIDATE
  Parameter name:  ls_validate
         Purpose:  Defines for LINE SEQUENTIAL files that the data should be
                   validated. If any record has non-DISPLAY characters then
                   an error status of 34 is returned
                   For v4.0+ (may change before its release candidate)
                   This option is only for GnuCOBOL format files
            Type:  boolean
         Default:  true
            Note:  The TRUE setting does data validation
                   The FALSE setting lets non-DISPLAY characters be written
                   If LS_NULLS is set, then LS_VALIDATE is not checked
         Example:  LS_VALIDATE = FALSE

For v4.0+ (may be replaced before its release candidate)
 Environment name: COB_MF_FILES
  Parameter name: mf_files
         Purpose:  Declares that all files in the program should be in
                   Micro Focus compatible format.
            Type:  boolean (evaluated for true only)
         Default:  false
         Example:  mf_files True

For v4.0+ (may be replaced before its release candidate)
 Environment name:  COB_MF_LS_NULLS
  Parameter name:  mf_ls_nulls
         Purpose:  Defines for Micro Focus compatible LINE SEQUENTIAL files
                   what to do with data which is not DISPLAY type.
                   This could happen if a LINE SEQUENTIAL record has
                   BINARY/COMP data fields in it.
            Type:  boolean
         Default:  true
            Note:  The TRUE setting will handle files that contain COMP data
                   in a similar manner to the method used by Micro Focus COBOL
         Example:  MF_LS_NULLS = TRUE

For v4.0+ (may be replaced before its release candidate)
 Environment name:  COB_MF_LS_INSTAB
   Parameter name:  mf_ls_instab
          Purpose:  Defines for LINE SEQUENTIAL files that multiple spaces
                    should be replaced by a TAB character, assuming a 'tab set'
                    value of 8. Each TAB means to skip to the next column that
                    is a multiple of 8
                    Similar to Micro Focus INSERTTAB=ON option
             Type:  boolean
          Default:  false
          Example:  MF_LS_INSTAB = TRUE

For v4.0+ (may be replaced before its release candidate)
 Environment name:  COB_MF_LS_SPLIT
  Parameter name:  mf_ls_split
         Purpose:  Defines for Micro Focus compatible LINE SEQUENTIAL files what
                   to do when a record is longer than the program handles.
                   If 'mf_ls_split=true' then
                   the data is returned as multiple records
            Type:  boolean
         Default:  true
         Example:  MF_LS_SPLIT = FALSE

For v4.0+ (may be replaced before its release candidate)
 Environment name:  COB_MF_LS_VALIDATE
  Parameter name:  mf_ls_validate
         Purpose:  Defines for Micro Focus compatible LINE SEQUENTIAL files
                   that the data should be validated.
                   If any record has non-DISPLAY characters then
                   an error status of 34 is returned
            Type:  boolean
         Default:  false
            Note:  The TRUE setting does data validation
                   The FALSE setting lets non-DISPLAY characters be written
                   If MF_LS_NULLS is set, then MF_LS_VALIDATE is not checked
         Example:  MF_LS_VALIDATE = FALSE

For v4.0+
 Environment name:  COB_SHARE_MODE
  Parameter name:  share_mode
         Purpose:  Defines what file sharing option should be used
            Type:  -- choice of values ---
                   none - nothing overrides application code
                   read - files opened as SHARE READ ONLY
                   all  - files opened as SHARE ALL OTHERS
                   no   - files opened as SHARE NO OTHERS
         Default:  none
         Example:  share_mode = ALL

For v4.0+
 Environment name:  COB_RETRY_MODE
  Parameter name:  retry_mode
         Purpose:  Defines what I/O retry sharing option should be used
            Type:  --- choice of values ---
                   none    - nothing overrides application code
                   never   - I/O is never retried
                   forever - I/O will be retried until success
         Default:  none
         Example:  retry_mode = never

For v4.0+
 Environment name:  COB_RETRY_TIMES
  Parameter name:   retry_times
         Purpose:   Defines how many times I/O should be retried
            Type:   integer
         Default:   0
         Example:   retry_times = 10

For v4.0+
 Environment name:  COB_RETRY_SECONDS
  Parameter name:   retry_seconds
         Purpose:   Defines how many seconds I/O should be retried
            Type:   integer
         Default:   0
         Example:   retry_seconds = 6

For v4.0+
 Environment name:  COB_KEYCHECK
  Parameter name:   keycheck
         Purpose:   Must INDEXED file keys match COBOL SELECT exactly
            Type:   boolean
         Default:   true
         Example:   keycheck = off

 Environment name:  COB_SYNC
   Parameter name:  sync
          Purpose:  Should the file be synced to disk after each write/update
             Type:  boolean
          Default:  false
          Example:  SYNC: TRUE

 Environment name:  COB_SORT_MEMORY
   Parameter name:  sort_memory
          Purpose:  Defines how much RAM to assign for sorting data
                    if this size is exceeded the  SORT  will be done
                    on disk instead of memory
             Type:  size  but must be more than 1M
          Default:  128M
          Example:  SORT_MEMORY 64M

 Environment name:  COB_SORT_CHUNK
   Parameter name:  sort_chunk
          Purpose:  Defines how much RAM to assign for sorting data in chunks
             Type:  size  but must be within 128K and 16M
          Default:  256K
          Example:  SORT_CHUNK 1M



File: gnucobpg.info,  Node: Screen I/O,  Next: Report I/O,  Prev: File I/O,  Up: Run Time Environment Variables

10.2.3.5 Screen I/O
...................


 Environment name:  COB_BELL
   Parameter name:  bell
          Purpose:  Defines how a request for the screen to beep is handled
             Type:  FLASH, SPEAKER, FALSE, BEEP
          Default:  BEEP
          Example:  BELL SPEAKER

 Environment name:  COB_HIDE_CURSOR
   Parameter name:  hide_cursor
          Purpose:  hide the cursor; 0=visible, 1=hidden
             Type:  boolean
          Default:  false
          Example:  hide_cursor Y

 Environment name:  COB_REDIRECT_DISPLAY
   Parameter name:  redirect_display
          Purpose:  Defines if DISPLAY output should be sent to 'stderr'
             Type:  boolean
          Default:  false
          Example:  redirect_display Yes

 Environment name:  COB_SCREEN_ESC
   Parameter name:  screen_esc
          Purpose:  Enable handling of ESC key during ACCEPT
             Type:  boolean
          Default:  false
             Note:  is only evaluated if COB_SCREEN_EXCEPTIONS is active
          Example:  screen_esc Yes

 Environment name:  COB_SCREEN_EXCEPTIONS
   Parameter name:  screen_exceptions
          Purpose:  enable exceptions for function keys during ACCEPT
             Type:  boolean
          Default:  false
          Example:  screen_exceptions Yes

 Environment name:  COB_TIMEOUT_SCALE
   Parameter name:  timeout_scale
          Purpose:  specify translation in milliseconds for ACCEPT clauses
                    BEFORE TIME value / AFTER TIMEOUT
             Type:  integer
                    0 means 1000 (Micro Focus COBOL compatible), 1 means 100
                    (ACUCOBOL compatible), 2 means 10, 3 means 1
          Default:  0
          Example:  timeout_scale 3

 Environment name:  COB_INSERT_MODE
   Parameter name:  insert_mode
          Purpose:  specify default insert mode for ACCEPT; 0=off, 1=on
             Type:  boolean
          Default:  false
             Note:  also sets the cursor type (if available)
          Example:  insert_mode Y

 Environment name:  COB_MOUSE_FLAGS
  Parameter name:   mouse_flags
         Purpose:   specify which mouse events will be sent as function key
                    to the application during ACCEPT and how they will be
                    handled
            Type:   int (by bits)
         Default:   1
            Note:   0 disables the mouse cursor, any other value enables it,
                    any value containing 1 will enable internal handling (click
                    to position, double-click to enter).
                    See copy/screenio.cpy for list of events and their values.
           Alias:   MOUSE_FLAGS
         Example:   11 (enable internal handling => 1, left press => 2,
                        double-click => 8; 1+2+8=11)

 Environment name:  COB_MOUSE_INTERVAL
  Parameter name:   mouse_interval
         Purpose:   specifies the maximum time (in thousands of a second)
                    that can elapse between press and release events for them
                    to be recognized as a click.
            Type:   int (0 - 166)
         Default:   100
            Note:   0 disables the click resolution (instead press + release
                    are recognized), also disables positioning by mouse click

 Environment name:  COB_DISPLAY_PRINT_PIPE
  Parameter name:   display_print_pipe
         Purpose:   Defines command line used for sending output of
                    DISPLAY UPON PRINTER to (via pipe)
                    This is very similar to Micro Focus COBPRINTER
            Note:   Each executed DISPLAY UPON PRINTER statement causes a
                    new invocation of command-line (= new process start).
                    Each invocation receives the data referenced in
                    the DISPLAY statement and is followed by an
                    end-of-file condition.
                    COB_DISPLAY_PRINT_FILE, if set, takes precedence
                    over COB_DISPLAY_PRINT_PIPE.
           Alias:   COBPRINTER
            Type:   string
         Default:   not set
         Example:   print 'cat >>/tmp/myprt.log'

 Environment name:  COB_DISPLAY_PRINT_FILE
  Parameter name:   display_print_file
         Purpose:   Defines file to be appended to by DISPLAY UPON PRINTER
            Note:   Each DISPLAY UPON PRINTER opens, appends and closes the file.
            Type:   string       : $$ is replaced by process id
         Default:   not set
         Example:   display_printer '/tmp/myprt.log'

 Environment name:  COB_DISPLAY_PUNCH_FILE
  Parameter name:   display_punch_file
         Purpose:   Defines file to be created on first
                    DISPLAY UPON SYSPUNCH/SYSPCH
            Note:   The file will be only be closed on runtime exit.
            Type:   string       : $$ is replaced by process id
         Default:   not set
         Example:   display_punch './punch_$$.out'

 Environment name:  COB_LEGACY
   Parameter name:  legacy
          Purpose:  keep behaviour of former runtime versions, currently only
                    for setting screen attributes for non input fields
             Type:  boolean
          Default:  not set
          Example:  legacy true

 Environment name:  COB_EXIT_WAIT
   Parameter name:  exit_wait
          Purpose:  to wait on main program exit if an extended screenio
                    DISPLAY was issued without an ACCEPT following
             Type:  boolean
          Default:  true
          Example:  COB_EXIT_WAIT off

 Environment name:  COB_EXIT_MSG
   Parameter name:  exit_msg
          Purpose:  string to display if COB_EXIT_WAIT is processed, set to '@w{}'
                    if no actual display but an ACCEPT should be done
             Type:  string
          Default:  'end of program, please press a key to exit' (localized)
          Example:  COB_EXIT_MSG '@w{}'



File: gnucobpg.info,  Node: Report I/O,  Next: File I/O Environment Variables and/or dictionary file,  Prev: Screen I/O,  Up: Run Time Environment Variables

10.2.3.6 Report I/O
...................


 Environment name:  COB_COL_JUST_LRC
   Parameter name:  col_just_lrc
          Purpose:  If true, then COLUMN defined as LEFT, RIGHT or CENTER
                    will have the data justified within the field limits
                    If false, then the data is just copied into the column as is
             Type:  boolean
          Default:  TRUE
          Example:  col_just_lrc True



File: gnucobpg.info,  Node: File I/O Environment Variables and/or dictionary file,  Prev: Report I/O,  Up: Run Time Environment Variables

10.2.3.7 File I/O Environment Variables and/or dictionary file
..............................................................


GnuCOBOL 4.+ only!

Before a file is opened a check is done for environment variables that
may define various attributes of the file
First a check is made for attributes for files of the same ORGANIZATION
IX_OPTIONS for INDEXED, SQ_OPTIONS for SEQUENTIAL, RL_OPTIONS for RELATIVE
LS_OPTIONS for LINE SEQUENTIAL, LA_OPTIONS for LINE ADVANCING SEQUENTIAL
If none of these are present, it then checks for IO_OPTIONS

Then an additional check is done for IO_asgnmame where 'asgname' was
the ASSIGN EXTERNAL name used in the program

The environment variable (or dictionary file) may contain any of the
following keywords, separated by spaces and/or commas

You can specify just the keyword and it is assumed to mean set to true,
or no-keyword (or no_keyword or nokeyword) which means set to false,
or keyword=true or keyword=false.  The valid keywords are:
Keyword          Meaning
=========        ======================================================
type=xx          Set file organization where 'xx' is one of
                 IX = INDEXED, SQ = SEQUENTIAL, RL = RELATIVE
                 LS = LINE SEQUENTIAL, LA = LINE ADVANCING
mf               Set file to Micro Focus compatible format
gc               Set to original GnuCOBOL default format
recsz            The size for fixed size record file
maxsz            Maximum record size for variable length records
minsz            Minimum record size for variable length records
ls_nulls         Do NUL insertion before characters less than a SPACE,
                 Default: false
ls_validate      Validate data for LINE Sequential Files, Default: true
crlf             Lines end with CR LF (Windows format for text files)
lf               Lines end with LF (Unix format for text files)
sync             Sync all writes to disk
B32              Use 32-bit Big-Endian format 'int' as record length
L32              Use 32-bit Little-Endian format 'int' as record length
B64              Use 64-bit Big-Endian format 'int' or 'size_t' as record length
L64              Use 64-bit Little-Endian format 'int' or 'size_t' as record length
trace            Enable I/O trace when program execution tracing is enabled
stats            Write I/O statistic information on file close
retry_times      Default number of times to retry I/O
retry_seconds    Number of seconds between I/O retry attempts
retry_forever    Retry I/O forever
retry_never      Never retry I/O operations
ignore_lock      Ignore record locks
advancing_lock   Advance to the next record if lock condition
share_all        Share file with ALL others
share_read       Share file for READ only
share_no         Share file with NO others

 ---- For INDEXED files -----
format=ixhandler INDEXED file format: CISAM,DISAM,VBISAM,BDB,LMDB
format=auto      INDEXED file format is determined by inspecting the file
nkeys=n          number of indexes
key1=(loc:len)   loc (zero relative) of key, len of key
key2=(loc:len,loc:len ...)
                 define composite index
dupn=Y           index allows dups

  ---- For INDEXED BDB files -----
big_endian       Set internal 'int' byte order to BIG ENDIAN
little_endian    Set internal 'int' byte order to LITTLE ENDIAN



File: gnucobpg.info,  Node: Program Arguments,  Prev: Run Time Environment Variables,  Up: Running Programs

10.2.4 Program Arguments
------------------------

Regardless of the manner in which a main program is executed (i.e.
directly or via ‘cobcrun’), any arguments specified to the program may
be retrieved via any of the following:
   • ‘ACCEPT FROM COMMAND-LINE’ (*note ACCEPT FROM COMMAND-LINE::)
   • ‘PROCEDURE DIVISION CHAINING’ (*note PROCEDURE DIVISION CHAINING::)


File: gnucobpg.info,  Node: Binary Truncation,  Prev: Running Programs,  Up: Interfacing With The OS

10.3 Binary Truncation
======================

By default, the GnuCOBOL compiler will truncate binary data items to the
precision indicated by their ‘PICTURE’ (*note PICTURE::) clause, if they
have one.  This applies to COMP, BINARY and COMP-4 items Only.
The fact is, however, that binary truncation has a significant effect on
the performance of GnuCOBOL programs.  When binary truncation is in
effect, arithmetic operations performed against all types of numeric
data items (even ‘USAGE DISPLAY’) are slowed down.

   Before continuing, it's worth making the point that we're not talking
about astronomical performance degradations here.  Today's computers are
fast, and a user sitting at the keyboard, running a GnuCOBOL program is
unlikely to notice.  But, if you have a GnuCOBOL program that has to
process large amounts of data, performing some significant "number
crunching" against that data as it goes, the impact of truncation could
become noticeable.

   The following program compares the performance of performing
arithmetic operations (in a totally non-scientific, non-rigorous way)
against data items with a ‘USAGE’ (*note USAGE::) of ‘DISPLAY’, ‘COMP’
and ‘BINARY-LONG’.  It was actually my intent when I first wrote the
program to merely demonstrate the relative performance differences
between different types of numeric data storage, and it certainly met
that objective.

     IDENTIFICATION DIVISION.
     PROGRAM-ID. DEMOMATH.
     DATA DIVISION.
     WORKING-STORAGE SECTION.
     01  Begin-Time.
         05 BT-HH                    PIC 9(2).
         05 BT-MM                    PIC 9(2).
         05 BT-SS                    PIC 9(2).
         05 BT-HU                    PIC 9(2).
     01  Binary-Item         BINARY-LONG SIGNED VALUE 0.
     01  Comp-Item           COMP    PIC S9(9)  VALUE 0.
     01  Display-Item        DISPLAY PIC S9(9)  VALUE 0.
     01  End-Time.
         05 ET-HH                    PIC 9(2).
         05 ET-MM                    PIC 9(2).
         05 ET-SS                    PIC 9(2).
         05 ET-HU                    PIC 9(2).
     78  Repeat-Count                VALUE 10000000.
     01  Time-Diff                   PIC ZZ9.99.
     PROCEDURE DIVISION.
     010-Test-Usage-DISPLAY.
         ACCEPT  Begin-Time FROM TIME
         PERFORM Repeat-Count TIMES
             ADD 7 TO Display-Item
         END-PERFORM
         PERFORM 100-Determine-Time-Diff
         DISPLAY 'USAGE DISPLAY: ' Time-Diff ' SECONDS'
         .
     020-Test-Usage-COMP.
         ACCEPT Begin-Time FROM TIME
         PERFORM Repeat-Count TIMES
             ADD 7 TO Comp-Item
         END-PERFORM
         PERFORM 100-Determine-Time-Diff
         DISPLAY 'USAGE COMP:    ' Time-Diff ' SECONDS'
         .
     040-Test-Usage-BINARY.
         ACCEPT Begin-Time FROM TIME
         PERFORM Repeat-Count TIMES
             ADD 7 TO Binary-Item
         END-PERFORM
         PERFORM 100-Determine-Time-Diff
         DISPLAY 'USAGE BINARY:  ' Time-Diff ' SECONDS'
         .
     099-Done.
         STOP RUN
         .
     100-Determine-Time-Diff.
         ACCEPT End-Time FROM TIME
         COMPUTE Time-Diff =
           ( (ET-HH * 360000 + ET-MM * 6000 + ET-SS * 100 + ET-HU)
           - (BT-HH * 360000 + BT-MM * 6000 + BT-SS * 100 + BT-HU) )
           / 100
         .

   Each data item has 7 added to it ten million times.

   The time (to one-one-hundredth of a second) will be retrieved before
and after each test and the difference between the two is displayed.
This is why the computations were done so many times -- it was to make
sure the timing was measurable with only a 1/100 second "stopwatch".

   I also ran the tests multiple times, just to make sure I had
consistent results (I did).  Like I mentioned earlier, this is not a
rigorous, scientific benchmark of numeric performance; it's just a
quick-and-dirty comparison.

   Here are the results:

     Test 1:
     USAGE DISPLAY:   1.72 SECONDS
     USAGE COMP:      0.62 SECONDS
     USAGE BINARY:    0.02 SECONDS

     Test 2:
     USAGE DISPLAY:   1.69 SECONDS
     USAGE COMP:      0.61 SECONDS
     USAGE BINARY:    0.02 SECONDS

     Test 3:
     USAGE DISPLAY:   1.69 SECONDS
     USAGE COMP:      0.65 SECONDS
     USAGE BINARY:    0.02 SECONDS

   The results I saw here were consistent with those that would have
been obtained from most of the COBOL implementations I have ever worked
with -- ‘USAGE COMP’ has a significant performance advantage over ‘USAGE
DISPLAY’ and ‘USAGE BINARY-LONG’ (and presumably the other ‘BINARY-xxx’
usages as well) perform identically, within the measurement tolerances
of the test.

   Imagine my surprise, however, when I discovered that the use of
‘-fnotrunc’ switch also made a difference:

     Test 4:
     USAGE DISPLAY:   1.72 SECONDS
     USAGE COMP:      0.07 SECONDS
     USAGE BINARY:    0.02 SECONDS

     Test 5:
     USAGE DISPLAY:   1.72 SECONDS
     USAGE COMP:      0.07 SECONDS
     USAGE BINARY:    0.02 SECONDS

     Test 6:
     USAGE DISPLAY:   1.73 SECONDS
     USAGE COMP:      0.06 SECONDS
     USAGE BINARY:    0.02 SECONDS

   As you can see, there was a huge drop in ‘USAGE COMP’ timings by
turning off truncation.  As a result, I see absolutely no reason
whatsoever why the ‘-fnotrunc’ switch option shouldn't be used on all
GnuCOBOL compilations.

   If you want to squeeze every last bit of performance out of your
GnuCOBOL programs, don't forget to investigate the ‘-O’ switch, ‘-O2’
switch and the ‘-Os’ switch, all of which influence the optimization of
compiled code.  Actually run programs using various optimization
switches (or not) and compare execution times against those of
unoptimized compiled versions of your programs.  Don't just compare the
generated C code because sometimes the differences can't be seen at the
C source-code level.

     Test 7:
     cobc -x demomath.cbl -O2;demomath
     USAGE DISPLAY:   1.68 SECONDS
     USAGE COMP:      0.60 SECONDS
     USAGE BINARY:    0.00 SECONDS

     Test 8:
     cobc -x demomath.cbl -fnotrunc -O2;demomath
     USAGE DISPLAY:   1.67 SECONDS
     USAGE COMP:      0.01 SECONDS
     USAGE BINARY:    0.00 SECONDS

   All tests above carried out under Linux with a AMD FX8350 under very
low loading prior to the test.  I would have also tried on a i7-7700 but
that is under Windows 10 and I do not have a GC version on it - Vince.


File: gnucobpg.info,  Node: Sub-Programming,  Next: Programming Style Suggestions,  Prev: Interfacing With The OS,  Up: Top

11 Sub-Programming
******************

* Menu:

* Subprogram Types.
* Independent vs Contained vs Nested Subprograms.
* Alternate Entry Points.
* Dynamic vs Static Subprograms.
* Subprogram Execution Flow.
* Subroutine Execution Flow.
* User-Defined Function Execution Flow.
* Sharing Data Between Calling and Called Programs.
* Subprogram Arguments.
* Calling Program Considerations.
* Called Program Considerations.
* GLOBAL Data Items.
* EXTERNAL Data Items.
* Recursive Subprograms.
* Combining GnuCOBOL and C Programs.
* GnuCOBOL Run-Time Library Requirements.
* String Allocation Differences Between GnuCOBOL and C.
* Matching C Data Types with GnuCOBOL USAGE's.
* GnuCOBOL Main Programs CALLing C Subprograms.
* C Main Programs Calling GnuCOBOL Subprograms.


File: gnucobpg.info,  Node: Subprogram Types,  Next: Independent vs Contained vs Nested Subprograms,  Up: Sub-Programming

11.1 Subprogram Types
=====================

Simply stated, a “Subprogram” is a program that is invoked by another
program; the subprogram performs whatever its designed operations are
and -- when complete -- typically returns control back to the program
that invoked it.  There are two different types of subprograms supported
by GnuCOBOL, subroutines and user-defined functions.  The distinction
between these two subprogram types lies in the manner in which they are
executed.

   When program A invokes subprogram B as a “Subroutine”, it does so
using a special statement dedicated to that function (the ‘CALL’
statement (*note CALL::), just as if B were one of the built-in system
subroutines.

   When program A invokes program B as a “User-Defined Function”, it
does so in a manner identical to how B would have been invoked had it
been one of the many built-in intrinsic functions.

   In either instance, program A is referred to as the “Calling Program”
while program B is known as the “Called Program”.  GnuCOBOL programs may
be a calling program, a called program or both.

   A program written in the C programming language may serve as either
the calling or called program too.  A called program may act as a
calling program to another called program.  When a calling program does
not serve as a called program to any program, that calling program is
known as a “Main Program”.

   Both subroutines and user-defined functions may return a value.  The
value they return must be an integer in the range -2147483648 to
+2147483647.  This value will be available in the ‘RETURN-CODE’ special
register (*note Special Registers::) and also as the value of the data
item specified on the ‘RETURNING’ (*note CALL::) clause of a
subroutine's ‘CALL’.


File: gnucobpg.info,  Node: Independent vs Contained vs Nested Subprograms,  Next: Alternate Entry Points,  Prev: Subprogram Types,  Up: Sub-Programming

11.2 Independent vs Contained vs Nested Subprograms
===================================================

Subprograms (either subroutines or user-defined functions) can be
implemented in three different ways.

“Independent Subprograms”
     These are subprograms that are coded as the only COBOL program in
     their Compilation Unit (*note Compilation Unit::).

“Contained Subprograms”
     These are subprograms which occur in the same Compilation Unit as a
     main program and/or other subprograms.  Each contained subprogram
     is separated from the next via an ‘END PROGRAM’ marker line.  As an
     example...

          IDENTIFICATION DIVISION.
          PROGRAM-ID. SUB1.
          ...
          END PROGRAM SUB1.
          IDENTIFICATION DIVISION.
          PROGRAM-ID. SUB2.
          ...
          END PROGRAM SUB2.

     Program source code may be concatenated as shown here, provided an
     ‘END PROGRAM’ marker naming the ‘PROGRAM-ID’ of the just-completed
     program is used to separate one program from another.

     There's no reason that user-defined functions cannot be included
     too -- they'll just have ‘FUNCTION-ID’s and will be ended by ‘END
     FUNCTION’ markers.

     The last program in any GnuCOBOL source file need not have an ‘END’
     marker.

     When multiple programs occur in a source file, it is assumed that
     the programs are related to one another in that they will be
     ‘CALL’ed or executed as functions from the others.

“Nested Subprograms”
     It is also possible to create source files where GnuCOBOL programs
     are nested inside each other.  Take for example these four GnuCOBOL
     programs:

          IDENTIFICATION DIVISION.
          PROGRAM-ID. PROG1.
          ...
          IDENTIFICATION DIVISION.
          PROGRAM-ID. PROG2.
          ...
          IDENTIFICATION DIVISION.
          PROGRAM-ID. PROG3.
          ...
          END PROGRAM PROG3.
          END PROGRAM PROG2.
          IDENTIFICATION DIVISION.
          PROGRAM-ID. PROG4.
          ...
          END PROGRAM PROG4.
          END PROGRAM PROG1.

     Here we see that ‘PROG2’ is nested inside of ‘PROG1’ because there
     is no ‘END PROGRAM’ marker separating them.  This means that data
     items or files defined within ‘PROG1’ can be used within ‘PROG2’
     simply by attaching the ‘GLOBAL’ (*note GLOBAL::) attribute to them
     back in ‘PROG1’ when they are defined.

     Similarly, since there is no ‘END PROGRAM’ marker separating
     ‘PROG3’ from ‘PROG2’, it is possible for ‘PROG3’ to access ‘GLOBAL’
     files and data items defined within ‘PROG2’.  Since ‘PROG2’ is
     nested within ‘PROG1’, any ‘GLOBAL’ resources defined within
     ‘PROG1’ will be available to ‘PROG3’ as well.

     The two ‘END PROGRAM’ markers for ‘PROG3’ and ‘PROG2’ (note their
     sequence) mean that PROG4 is nested within ‘PROG1’ only.  It will
     not have access to any ‘GLOBAL’ resources defined within either
     ‘PROG2’ or ‘PROG3’.

     The ‘END PROGRAM PROG1.’ marker, since it is the last line in the
     source file, is entirely optional.


File: gnucobpg.info,  Node: Alternate Entry Points,  Next: Dynamic vs Static Subprograms,  Prev: Independent vs Contained vs Nested Subprograms,  Up: Sub-Programming

11.3 Alternate Entry Points
===========================

Any subroutine may have multiple entry-points defined within it.  This
means the subroutine could be called either via a ‘CALL 'PROGRAM-ID'’ or
a ‘CALL 'ENTRY-POINT'’ statement.  There may be any number of alternate
entry-points defined within a subroutine.

   Alternate entry-points provide multiple ways in which the same
subroutine may be called; presumably, each entry-point will provide some
different functionality to the calling program.  For example, if you
wished to write a subroutine that manipulates "student" records in a
database, you might have the primary entry-point name retrieve a student
record from the database, while the alternate entry points
‘Add-Student’, ‘Update-Student’ and ‘Delete-Student’ could provide the
alternate functions implied by their entry-point names.

   The alternative to using multiple entry points in your subroutine, by
the way, would be to include an additional argument to the primary (and
only) entry point of the subroutine; this new argument might be named
‘STUDENT-FUNCTION’ and might have values of ‘FETCH’, ‘ADD’, ‘UPDATE’ or
‘DELETE’.

   The primary entry-point for any subroutine is always the first
executable statement following any ‘DECLARATIVES’ (*note DECLARATIVES::)
in the procedure division.  The name of that entry-point (the name that
will be called) is the subroutine's ‘PROGRAM-ID’ (*note IDENTIFICATION
DIVISION::).

   An alternate entry point is added to a subroutine using the ‘ENTRY’
statement (*note ENTRY::).

   When an alternate entry-point is called, execution within the
subroutine will begin at the first executable statement following the
‘ENTRY’ statement.


File: gnucobpg.info,  Node: Dynamic vs Static Subprograms,  Next: Subprogram Execution Flow,  Prev: Alternate Entry Points,  Up: Sub-Programming

11.4 Dynamic vs Static Subprograms
==================================

Any subprogram may be either statically or dynamically loaded into
memory.

   A “Static Subprogram” is one which was in the same Compilation Unit
(*note Compilation Unit::) as the other program(s) which call it,
therefore meaning that its executable object code is part of the same
executable file as its calling program.  The static subprogram was
therefore loaded into memory as part of and at the same time as the
calling program.

   A “Dynamic Subprogram” is one whose executable object code exists as
an executable file separate from that containing the calling program;
these two programs were therefore each compiled in their own separate
Compilation Group (*note Compilation Group::).  Dynamic subprograms are
located and loaded into memory the first time they are executed.
Dynamic subprograms may be unloaded from memory via the ‘CANCEL’
statement (*note CANCEL::), if desired.

   GnuCOBOL subprograms may be created as either static or dynamic
subprograms, as desired by the programmer.

   To demonstrate, assume that a GnuCOBOL Main Program (whose code
resides in the file ‘M.cbl’) will be calling three subprograms, named A,
B and C (these are the ‘PROGRAM-ID’s of the three subprograms, and their
source code may be found in the files ‘A.cbl’, ‘B.cbl’ and ‘C.cbl’,
respectively.

   Here is how these four programs would be compiled if the three
subprograms are to be static:

     cobc -x M.cbl A.cbl B.cbl C.cbl

   This command informs the compiler (cobc) that four programs are to be
compiled (the first named on the command must always be the main
program), and a single executable file is to be created (due to the ‘-x’
switch).

   Here is how the main program and the three subprograms could be
compiled if the three subprograms are to be dynamic:

     cobc -x M.cbl
     cobc -m A.cbl B.cbl C.cbl

   These commands will create an executable file for the main program
(‘-x’ switch) and three separate dynamically-loadable libraries (see
‘-m’ switch), one for each of the three subprograms.  Had we wished, we
could have created a single dynamically-loadable library containing all
three subprograms by adding the ‘-b’ switch to their compilation:

     cobc -m -b A.cbl B.cbl C.cbl

   Dynamically-loadable libraries are also known by the term
dynamically-loadable modules.  The two terms are synonymous.

   Here are the rules about GnuCOBOL dynamically-loadable modules:
  1. There may be multiple GnuCOBOL subprograms contained within a
     single dynamically-loadable library if the ‘-b’ switch is used in
     addition to ‘-m’.  If not, each subprogram will be compiled to a
     separate dynamically-loadable library.

  2. Dynamically-loadable modules will be named ‘XXXXXXXX.dll’ on a
     Windows system, ‘XXXXXXXX.so’ on a Unix system or ‘XXXXXXXX.dylib’
     on an OSX system, where ‘XXXXXXXX’ exactly matches, including the
     usage of upper- and lower-case letters, the primary entry-point
     name (‘PROGRAM-ID’ or ‘FUNCTION-ID’) or an alternate entry point
     name defined via the ‘ENTRY’ statement (*note ENTRY::) of any one
     of the GnuCOBOL programs included in that module.

  3. The first time any of the GnuCOBOL subprograms in a
     dynamically-loadable module are invoked, the entry-point referenced
     must be the one for which the ‘.dll’, ‘.so’ or ‘.dylib’ file is
     named.

  4. When a dynamically-loadable module needs to be loaded (because it
     is not already in memory from a previous subprogram execution), the
     dynamically-loadable library will be sought in the same directory
     from which the main program was loaded.  If it cannot be found
     there, each directory named in the ‘PATH’ run-time environment
     variable (*note Run Time Environment Variables::) will be searched.
     If it was not located in any of those directories, the library
     specified by the ‘COB_LIBRARY_PATH’ run-time environment variable
     will be searched.  Finally, if it still cannot be located,
     execution will be terminated with an error message (libcob: Cannot
     find module 'xxxxxxxx').

  5. Once the dynamically-loadable module has been successfully loaded,
     any of the entry-points contained within it are now available for
     reference.

  6. Dynamically-loadable modules may be removed from memory via the
     ‘CANCEL’ statement (*note CANCEL::).

  7. Once a dynamically-loadable module is actually loaded into memory,
     even if it is subsequently unloaded (via the ‘CANCEL’ statement),
     its list of entry-points remain available to the GnuCOBOL run-time
     library and subsequent re-executions of any of those entry points
     will be able to bypass the search (rule #4) as well as the
     first-execution rule (rule #3).

   Consult the documentation on the ‘COB_PRE_LOAD’ run-time environment
variable, ‘COB_PHYSICAL_CANCEL’ run-time environment variable and
‘COB_LOAD_CASE’ run-time environment variable run-time environment
variables (*note Run Time Environment Variables::) for additional
options when using dynamically-loadable modules.


File: gnucobpg.info,  Node: Subprogram Execution Flow,  Next: Sharing Data Between Calling and Called Programs,  Prev: Dynamic vs Static Subprograms,  Up: Sub-Programming

11.5 Subprogram Execution Flow
==============================

When a subprogram is invoked, the flow of execution will differ slightly
depending on whether the subprogram is a subroutine or a user-defined
function.
* Menu:

* Subroutine Execution Flow.
* User-Defined Function Execution Flow.


File: gnucobpg.info,  Node: Subroutine Execution Flow,  Next: User-Defined Function Execution Flow,  Up: Subprogram Execution Flow

11.5.1 Subroutine Execution Flow
--------------------------------

When a subroutine is ‘CALL’ed:

  1. The calling program issues a statement of the form ‘CALL
     'ENTRY-POINT' USING ...’ to transfer control to the subroutine.

  2. The executable for the called program will be located and loaded
     into memory:
       A. If it is a static subroutine, it will already be part of the
          executable program issuing the ‘CALL’ (*note CALL::).

       B. If it is a dynamic subroutine, the GnuCOBOL run-time system
          will check to see if a dynamically-loadable module containing
          the subprogram's entry point was already located.  If it was,
          no further "location" activity is needed.  If not, the
          dynamically-loadable module will be located (*note Locating
          Dynamically-Loadable Modules::).

       C. Once the module has been located (if location was needed), it
          will be loaded into memory (if not already loaded).
  3. Execution of the calling program is suspended and control will
     transfer to the called program, as follows:
       A. If the ‘PROGRAM-ID’ (*note IDENTIFICATION DIVISION::) clause
          of the subprogram included the ‘INITIAL’ clause, the program
          will be reinitialized back to its compile-time state.  This
          will happen regardless of the ‘INITIAL’ clause the first time
          the subprogram is executed.

       B. Local-storage, if any, will be allocated and initialized.

       C. Execution will begin at the first executable statement
          following the subprograms entry-point.  The entry point will
          be either the first executable statement following any
          ‘DECLARATIVES’ (*note DECLARATIVES::) that might be present
          (if the subprogram was invoked using its primary entry-point
          name) or the first executable statement following the ‘ENTRY’
          statement (*note ENTRY::) naming the entry-point specified on
          the ‘CALL’ if the subprogram was invoked using an alternate
          entry point.
  4. The flow of execution will then progress through the coding of the
     subprogram as it would with any other program.

  5. If the subprogram issues a ‘STOP’ statement (*note STOP::) with the
     ‘RUN’ option, program execution ceases and control returns to the
     operating system or whatever execution shell invoked the main
     program.

  6. If the subprogram wishes to return control back to the calling
     program, it will do so using either the ‘GOBACK’ statement (*note
     GOBACK::) or the ‘EXIT PROGRAM’ statement (*note EXIT::).  At this
     time:
       A. If the subprograms procedure division header or ‘ENTRY’
          statement included a ‘RETURNING’, the value of the data item
          found on that clause is moved to the ‘RETURN-CODE’ special
          register (*note Special Registers::); this behaviour can be
          altered utilizing the ‘CALL-CONVENTION’ (*note
          SPECIAL-NAMES::) feature to leave ‘RETURN-CODE’ unchanged.

       B. Local-storage, if any, is de-allocated.

       C. If the calling program included a ‘RETURNING’ clause on the
          ‘CALL’ statement that invoked the subprogram, the value of the
          ‘RETURNING’ data item in the subroutine is moved to that data
          item.  If there was no ‘RETURNING’ specified in the
          subroutine, the value of the ‘RETURN-CODE’ special register is
          moved to that data item.

       D. Execution will resume back in the calling program with the
          first executable statement following the ‘CALL’ that invoked
          the subprogram.


File: gnucobpg.info,  Node: User-Defined Function Execution Flow,  Prev: Subroutine Execution Flow,  Up: Subprogram Execution Flow

11.5.2 User-Defined Function Execution Flow
-------------------------------------------

When a user-defined function is executed:

  1. The object code for the called program (the user-defined function)
     will be located, as follows:
       A. If it is a static user-defined function, it will already be
          part of the executable file containing the calling program.

       B. If it is a dynamic user-defined function, the GnuCOBOL
          run-time system will check to see if a dynamically-loadable
          module containing the function's entry point was already
          located.  If it was, no further "location" activity is needed.
          If not, the dynamically-loadable module will be located (*note
          Locating Dynamically-Loadable Modules::).

       C. Once the module has been located (if location was needed), it
          will be loaded into memory (if not already loaded).
  2. Execution of the calling program is suspended and control will
     transfer to the called program, as follows:
       A. Local-storage, if any, will be allocated and initialized.

       B. Execution will begin with the first executable statement in
          the procedure division following any ‘DECLARATIVES’ (*note
          DECLARATIVES::) that might be present.
  3. The flow of execution will then progress through the coding of the
     function as it would with any other program.

  4. If the function issues a ‘STOP’ statement (*note STOP::) with the
     ‘RUN’ option, program execution ceases and control returns to the
     operating system or whatever execution shell invoked the main
     program.

  5. If the function wishes to return control back to the calling
     program, it will do so using either the ‘GOBACK’ statement (*note
     GOBACK::) or the ‘EXIT FUNCTION’ statement (*note EXIT::).  At this
     time:
       A. The value of the data item found on the user-defined functions
          ‘PROCEDURE DIVISION RETURNING’ (*note PROCEDURE DIVISION
          RETURNING::) clause is moved to the ‘RETURN-CODE’ special
          register (*note Special Registers::).

       B. Local-storage, if any, is de-allocated.

       C. Execution will resume back in the calling program at the point
          where the returned value of the function is needed.  At that
          point, the value in the ‘RETURN-CODE’ special register will be
          used for the function's value.


File: gnucobpg.info,  Node: Sharing Data Between Calling and Called Programs,  Next: Recursive Subprograms,  Prev: Subprogram Execution Flow,  Up: Sub-Programming

11.6 Sharing Data Between Calling and Called Programs
=====================================================

* Menu:

* Subprogram Arguments.
* Calling Program Considerations.
* Called Program Considerations.
* GLOBAL Data Items.
* EXTERNAL Data Items.


File: gnucobpg.info,  Node: Subprogram Arguments,  Next: GLOBAL Data Items,  Up: Sharing Data Between Calling and Called Programs

11.6.1 Subprogram Arguments
---------------------------

* Menu:

* Calling Program Considerations.
* Called Program Considerations.


File: gnucobpg.info,  Node: Calling Program Considerations,  Next: Called Program Considerations,  Up: Subprogram Arguments

11.6.1.1 Calling Program Considerations
.......................................

Data items defined in a calling program may be passed to either type of
called program (subroutine or user-defined function) as arguments.

   Arguments must be described in both the calling and called programs,
and while they don't need to have the same names in both programs, they
should be described in an identical manner with regard to the following
characteristics:

   • ‘PICTURE’ (*note PICTURE::) (including both type and length)

   • ‘SIGN’ (*note SIGN::)

   • ‘SYNCHRONIZED’ (*note SYNCHRONIZED::)

   • ‘USAGE’ (*note USAGE::)

   A subroutine may be passed a maximum of 251 arguments; if you build
the GnuCOBOL software yourself from the distributed source, you CAN
change this value by altering the defined value of
‘COB_MAX_FIELD_PARAMS’ in the ‘call.h’ header file but also see 7.8.5.11
for more information.  There is no built-in GnuCOBOL limit to how many
arguments a user-defined function may be passed.

   Whether or not changes made to an argument within a subroutine will
be "visible" to the calling program depends on how the argument was
passed.  There are three ways in which arguments may be passed from a
calling program to a subroutine, as defined by the use of optional ‘BY’
clauses in the ‘CALL’ (*note CALL::) statement's list of arguments.

   As an example, the following statement passes three arguments to a
subroutine -- each argument is passed differently.

     CALL "subroutine" USING BY REFERENCE arg-1
                             BY CONTENT arg-2
                             BY VALUE arg-3
     END-CALL

   The three ways arguments are passed are as follows.

‘BY REFERENCE’

     When a subroutine argument is passed ‘BY REFERENCE’, the subroutine
     is passed the address of the actual data item being passed as an
     argument.  The item may be anything defined within the data
     division of the program.  If the subroutine modifies the contents
     of this argument, the calling program will "see" the results of
     that change when the subroutine returns control.  This is the
     default manner in which GnuCOBOL passes arguments to a subroutine,
     should no ‘BY’ clauses be included on the ‘CALL’.

‘BY CONTENT’

     When a subroutine is passed an argument ‘BY CONTENT’, the
     subroutine is passed the address of a copy of the actual data being
     passed as an argument.  The item may be anything defined within the
     data division of the program.  The copy is made each time the
     ‘CALL’ statement is executed, immediately before the ‘CALL’
     actually takes place.  If the subroutine modifies the contents of
     this argument, it will be the copy that is modified, not the
     original data item; the calling program will therefore not "see"
     the results of that change when the subroutine returns control.

‘BY VALUE’

     Passing a subroutine argument ‘BY VALUE’ passes the actual value of
     the data being passed as an argument.  The item may be any
     elementary binary numeric item defined within the data division of
     the program.  If the subroutine modifies the contents of this
     argument, the calling program will not "see" the results of that
     change when the subroutine returns control.

   The first two ways in which arguments may be passed (‘BY REFERENCE’
and ‘BY CONTENT’) are intended for use when a GnuCOBOL program is being
called, while the first and third (‘BY REFERENCE’ and ‘BY VALUE’) are
intended for use when a C program is being called.  You can use ‘BY
VALUE’ arguments when calling GnuCOBOL subroutines, but remember that
those arguments are limited to being a numeric binary data item.

   Arguments to user-defined functions are always passed ‘BY REFERENCE’.


File: gnucobpg.info,  Node: Called Program Considerations,  Prev: Calling Program Considerations,  Up: Subprogram Arguments

11.6.1.2 Called Program Considerations
......................................

When coding a GnuCOBOL subprogram (a subroutine or user-defined
function), all arguments to the subprogram must be defined in the
subprogram's linkage section.

   These arguments must be explicitly included on the ‘PROCEDURE
DIVISION USING’ (*note PROCEDURE DIVISION USING::) clause that lists the
arguments in the sequence in which they will be passed to the
subprogram.

   These arguments described in the ‘PROCEDURE DIVISION USING’ clause
may each be defined as either ‘BY REFERENCE’, if the calling program is
passing them either ‘BY REFERENCE’ or ‘BY CONTENT’, or as ‘BY VALUE’ if
they are being passed ‘BY VALUE’.

   By default, all arguments are assumed to be ‘BY REFERENCE’ unless
explicitly stated otherwise on the procedure division header.

   Arguments to a user-defined function are always to be specified as
‘BY REFERENCE’ (either explicitly or by not using any ‘BY’).

   If the subprogram returns a value, the data item in which the value
is returned must also be defined in the subprogram's linkage section,
with a ‘USAGE’ (*note USAGE::) of ‘BINARY-LONG SIGNED’, or its
equivalent.


File: gnucobpg.info,  Node: GLOBAL Data Items,  Next: EXTERNAL Data Items,  Prev: Subprogram Arguments,  Up: Sharing Data Between Calling and Called Programs

11.6.2 GLOBAL Data Items
------------------------

Another way in which a data item may be shared between a calling program
(A) and a called program (B) is by defining the data item in the calling
program and attaching the ‘GLOBAL’ (*note GLOBAL::) clause to it so that
it may be used within the called program.  In order for this to work,
program B (the one called by program A) must be a nested subprogram
within program A.

   Here's a small example:

     IDENTIFICATION DIVISION.
     PROGRAM-ID. DemoGLOBAL.
     ENVIRONMENT DIVISION.
     DATA DIVISION.
     WORKING-STORAGE SECTION.
     01  Arg GLOBAL                     PIC X(10).
     PROCEDURE DIVISION.
     000-Main.
         MOVE ALL "X" TO Arg
         CALL "DemoSub" END-CALL
         DISPLAY "DemoGLOBAL: " Arg END-DISPLAY
         GOBACK
         .
     IDENTIFICATION DIVISION.
     PROGRAM-ID. DemoSub.
     PROCEDURE DIVISION.
     000-Main.
         MOVE ALL "*" TO Arg.
         GOBACK
         .
     END PROGRAM DemoSub.
     END PROGRAM DemoGLOBAL.

   When the program runs, it produces the output:

     DemoGLOBAL: **********


File: gnucobpg.info,  Node: EXTERNAL Data Items,  Prev: GLOBAL Data Items,  Up: Sharing Data Between Calling and Called Programs

11.6.3 EXTERNAL Data Items
--------------------------

The final way in which a data item may be shared between a calling
program (A) and a called program (B) is by defining the data item (with
the same name) in both programs and attaching the ‘EXTERNAL’ (*note
EXTERNAL::) clause to it (again, in both programs).  This approach works
regardless of whether the called program is nested within the calling
program or not.  It also works even if the two programs are compiled
separately.

   Here's a demonstration:

     IDENTIFICATION DIVISION.
     PROGRAM-ID. DemoEXTERNAL.
     ENVIRONMENT DIVISION.
     DATA DIVISION.
     WORKING-STORAGE SECTION.
     01  Arg EXTERNAL                PIC X(10).
     PROCEDURE DIVISION.
     000-Main.
         MOVE ALL "X" TO Arg
         CALL "DemoSub" END-CALL
         DISPLAY "DemoEXTERNAL: " Arg END-DISPLAY
         GOBACK
         .
     END PROGRAM DemoEXTERNAL.
     IDENTIFICATION DIVISION.
     PROGRAM-ID. DemoSub.
     DATA DIVISION.
     WORKING-STORAGE SECTION.
     01  Arg EXTERNAL                PIC X(10).
     PROCEDURE DIVISION.
     000-Main.
         MOVE ALL "*" TO Arg.
         GOBACK
         .
     END PROGRAM DemoSub.

   When the program runs, it produces the output:

     DemoEXTERNAL: **********


File: gnucobpg.info,  Node: Recursive Subprograms,  Next: Combining GnuCOBOL and C Programs,  Prev: Sharing Data Between Calling and Called Programs,  Up: Sub-Programming

11.7 Recursive Subprograms
==========================

A subroutine may ‘CALL’ itself, either directly or indirectly from
another subroutine or user-defined function that it ‘CALL’s.  Any
subroutine that indulges in this sort of behaviour (called recursion) is
called a “Recursive Subprogram”.

   Any GnuCOBOL subroutine can be recursively invoked only if it is
defined to the GnuCOBOL compiler as being a recursive subroutine.  This
is accomplished by adding the ‘RECURSIVE’ attribute to its ‘PROGRAM-ID’
(*note IDENTIFICATION DIVISION::).

   All User-defined functions are automatically capable of being
executed recursively.

   Here is an example of a main program (DEMOFACT) that calls both a
subprogram (SUB) and a user-defined function (FUNC) to compute the
factorial value of a number.

     IDENTIFICATION DIVISION.
     PROGRAM-ID. DEMOFACT.
     ENVIRONMENT DIVISION.
     CONFIGURATION SECTION.
     REPOSITORY.
         FUNCTION RECURSIVEFUNC.
     DATA DIVISION.
     WORKING-STORAGE SECTION.
     01  Result    USAGE BINARY-LONG.
     01  Arg       USAGE BINARY-LONG.
     PROCEDURE DIVISION.
     000-Main.
         MOVE 6 TO Arg
         CALL "RECURSIVESUB"
             USING BY CONTENT Arg
             RETURNING Result
         DISPLAY Arg "! = "
                 Result
         DISPLAY Arg "! = "
                 RECURSIVEFUNC(Arg)
         GOBACK
         .
     END PROGRAM DEMOFACT.
     IDENTIFICATION DIVISION.
     PROGRAM-ID. SUB RECURSIVE.
     DATA DIVISION.
     WORKING-STORAGE SECTION.
     01  Result      USAGE BINARY-LONG.
     01  Next-Arg    USAGE BINARY-LONG.
     01  Next-Result USAGE BINARY-LONG.
     LINKAGE SECTION.
     01  Arg         USAGE BINARY-LONG.
     PROCEDURE DIVISION USING Arg
                    RETURNING Result.
     000-Main.
         DISPLAY "Entering SUB"
                 " Arg=" Arg
         IF Arg = 1
           MOVE 1 TO Result
           DISPLAY "Leaving SUB"
                   " Returning " Result
         ELSE
           SUBTRACT 1 FROM Arg
               GIVING Next-Arg
           CALL "SUB"
                USING BY CONTENT Next-Arg
                RETURNING Next-Result
           COMPUTE Result =
                   Arg * Next-Result
           DISPLAY "Leaving SUB"
                   " Returning "
                   Result "=" Arg "*"
                   Next-Result
         END-IF
         GOBACK
         .
     END PROGRAM SUB.
     IDENTIFICATION DIVISION.
     FUNCTION-ID. FUNC.
     ENVIRONMENT DIVISION.
     CONFIGURATION SECTION.
     REPOSITORY.
         FUNCTION RECURSIVEFUNC.
     DATA DIVISION.
     WORKING-STORAGE SECTION.
     LINKAGE SECTION.
     01  Arg     USAGE BINARY-LONG.
     01  Result  USAGE BINARY-LONG
                 SIGNED.
     PROCEDURE DIVISION USING Arg
                    RETURNING Result.
     000-Main.
         DISPLAY "Entering FUNC"
                 " Arg=" Arg
         IF Arg = 1
           MOVE 1 TO Result
         ELSE
           COMPUTE Result = Arg *
                   FUNC(Arg - 1)
         END-IF
         DISPLAY "Leaving FUNC"
                 " Returning " Result
         GOBACK
         .
     END FUNCTION FUNC.

   When DEMOFACT is executed, the output shown below is generated.

     E:\Programs\Demos>demofact
     Entering RECURSIVESUB Arg=+0000000006
     Entering RECURSIVESUB Arg=+0000000005
     Entering RECURSIVESUB Arg=+0000000004
     Entering RECURSIVESUB Arg=+0000000003
     Entering RECURSIVESUB Arg=+0000000002
     Entering RECURSIVESUB Arg=+0000000001
     Leaving RECURSIVESUB Returning +0000000001
     Leaving RECURSIVESUB Returning +0000000002=+0000000002*+0000000001
     Leaving RECURSIVESUB Returning +0000000006=+0000000003*+0000000002
     Leaving RECURSIVESUB Returning +0000000024=+0000000004*+0000000006
     Leaving RECURSIVESUB Returning +0000000120=+0000000005*+0000000024
     Leaving RECURSIVESUB Returning +0000000720=+0000000006*+0000000120
     +0000000006! = +0000000720
     Entering RECURSIVEFUNC Arg=+0000000006
     Entering RECURSIVEFUNC Arg=+0000000005
     Entering RECURSIVEFUNC Arg=+0000000004
     Entering RECURSIVEFUNC Arg=+0000000003
     Entering RECURSIVEFUNC Arg=+0000000002
     Entering RECURSIVEFUNC Arg=+0000000001
     Leaving RECURSIVEFUNC Returning +0000000001
     Leaving RECURSIVEFUNC Returning +0000000002
     Leaving RECURSIVEFUNC Returning +0000000006
     Leaving RECURSIVEFUNC Returning +0000000024
     Leaving RECURSIVEFUNC Returning +0000000120
     Leaving RECURSIVEFUNC Returning +0000000720
     +0000000006! = +0000000720


File: gnucobpg.info,  Node: Combining GnuCOBOL and C Programs,  Prev: Recursive Subprograms,  Up: Sub-Programming

11.8 Combining GnuCOBOL and C Programs
======================================

The upcoming sections deal the issues pertaining to calling C language
programs from GnuCOBOL programs, and vice versa.  Two additional
sections provide samples illustrating specifics as to how those issues
are overcome in actual program code.
* Menu:

* GnuCOBOL Run-Time Library Requirements.
* String Allocation Differences Between GnuCOBOL and C.
* Matching C Data Types with GnuCOBOL USAGE's.
* GnuCOBOL Main Programs CALLing C Subprograms.
* C Main Programs Calling GnuCOBOL Subprograms.


File: gnucobpg.info,  Node: GnuCOBOL Run-Time Library Requirements,  Next: String Allocation Differences Between GnuCOBOL and C,  Up: Combining GnuCOBOL and C Programs

11.8.1 GnuCOBOL Run-Time Library Requirements
---------------------------------------------

Like most other implementations of the COBOL language, GnuCOBOL utilizes
a run-time library.  When the first program executed in a given
execution sequence is a GnuCOBOL program, any run-time library
initialization will be performed by the compiled COBOL code in a manner
that is transparent to the C-language programmer.  If, however, a C
program is the first to execute, the burden of performing GnuCOBOL
run-time library initialization falls upon the C program.  *Note C Main
Programs Calling GnuCOBOL Subprograms::, for an example of how to do
this.


File: gnucobpg.info,  Node: String Allocation Differences Between GnuCOBOL and C,  Next: Matching C Data Types with GnuCOBOL USAGE's,  Prev: GnuCOBOL Run-Time Library Requirements,  Up: Combining GnuCOBOL and C Programs

11.8.2 String Allocation Differences Between GnuCOBOL and C
-----------------------------------------------------------

Both languages store strings as a fixed-length continuous sequence of
characters.

   COBOL stores these character sequences up to a specific quantity
limit imposed by the ‘PICTURE’ (*note PICTURE::) clause of the data
item.  For example: ‘01 LastName PIC X(15).’.

   There is never an issue of exactly what the length of a string
contained in a ‘USAGE DISPLAY’ (*note USAGE::) data item is -- there are
always exactly how ever many characters as were allowed for by the
‘PICTURE’ clause.  In the example above, ‘LastName’ will always contain
exactly fifteen characters; of course, there may be anywhere from 0 to
15 trailing SPACES as part of the current LastName value.

   C actually has no "string" data type; it stores strings as an array
of ‘char’ data type items where each element of the array is a single
character.  Being an array, there is an upper limit to how many
characters may be stored in a given "string".  For example:

     char lastName[15]; /* 15 chars: lastName[0] through lastName[14] */

   C provides a robust set of string-manipulation functions to copy
strings from one char array to another, search strings for certain
characters, compare one char array to another, concatenate char arrays
and so forth.  To make these functions possible, it was necessary to be
able to define the logical end of a string.  C accomplishes this via the
expectation that all strings (char arrays) will be terminated by a NULL
character (‘x'00'’).  Of course, no one forces a programmer to do this,
but if [s]he ever expects to use any of the C standard functions to
manipulate that string they had better be null-terminating their
strings!

   So, GnuCOBOL programmers expecting to pass strings to or receive
strings from C programs had best be prepared to deal with the
null-termination issue, as follows:
  1. Pass a quoted literal string from GnuCOBOL to C as a zero-delimited
     string literal (‘Z'STRING'’).

  2. Pass alphanumeric (‘PIC X’) or alphabetic (‘PIC A’) data items to C
     subroutines by appending an ASCII ‘NUL’ character (‘X'00'’) to
     them.  For example, to pass the 15-character ‘LastName’ data item
     described above to a C subroutine:

          01  LastName-Arg-to-C     PIC X(16).
          ...
              MOVE FUNCTION CONCATENATE(LastName,X'00') TO LastName-Arg-to-C

     And then pass ‘LastName-Arg-to-C’ to the C subprogram!

  3. When a COBOL program needs to process string data prepared by a C
     program, the embedded null character must be accounted for.  This
     can easily be accomplished with an ‘INSPECT’ statement (*note
     INSPECT::) such as the following:

          INSPECT Data-From-a-C-Program
              REPLACING FIRST X'00' BY SPACE
                        CHARACTERS BY SPACE AFTER INITIAL X'00'


File: gnucobpg.info,  Node: Matching C Data Types with GnuCOBOL USAGE's,  Next: GnuCOBOL Main Programs CALLing C Subprograms,  Prev: String Allocation Differences Between GnuCOBOL and C,  Up: Combining GnuCOBOL and C Programs

11.8.3 Matching C Data Types with GnuCOBOL USAGE's
--------------------------------------------------

Matching up GnuCOBOL numeric Usage's with their C language data type
equivalents is possible via the following chart:

COBOL                                C
--------------------------------------------------------------------------
BINARY-CHAR UNSIGNED                 unsigned char
BINARY-CHAR [ SIGNED ]               signed char
BINARY-SHORT UNSIGNED                unsigned
                                     unsigned int
                                     unsigned short
                                     unsigned short int
BINARY-SHORT [ SIGNED ]              int
                                     short
                                     short int
                                     signed int
                                     signed short
                                     signed short int
BINARY-LONG UNSIGNED                 unsigned long
                                     unsigned long int
BINARY-LONG [ SIGNED ]               long
BINARY-INT                           long int
                                     signed long
                                     signed long int
BINARY-C-LONG [ SIGNED ]             long
BINARY-DOUBLE UNSIGNED               unsigned long long
                                     unsigned long long int
BINARY-DOUBLE [ SIGNED ]             long long int
BINARY-LONG-LONG                     signed long long int
COMPUTATIONAL-1                      float
COMPUTATIONAL-2                      double
N/A (no GnuCOBOL equivalent)         long double
   These sizes conform to the COBOL standard and the minimum sizes of
the COBOL types are the same as the minimum sizes of the corresponding C
data types.  There's no official compatibility between them.  Note that
values in square braces '[]' are the defaults.


File: gnucobpg.info,  Node: GnuCOBOL Main Programs CALLing C Subprograms,  Next: C Main Programs Calling GnuCOBOL Subprograms,  Prev: Matching C Data Types with GnuCOBOL USAGE's,  Up: Combining GnuCOBOL and C Programs

11.8.4 GnuCOBOL Main Programs CALLing C Subprograms
---------------------------------------------------

Here's a sample of a GnuCOBOL program that CALLs a C subprogram.
COBOL Calling Program               C Called Program
==================================  ===============================
IDENTIFICATION DIVISION.            #include <stdio.h>
PROGRAM-ID. maincob.                int subc(char *arg1,
DATA DIVISION.                               char *arg2,
WORKING-STORAGE SECTION.                     unsigned long *arg3) {
01  Arg1     PIC X(7).                char nu1[7]="New1";
01  Arg2     PIC X(7).                char nu2[7]="New2";
01  Arg3     USAGE BINARY-LONG.       printf("Starting subc\n");
PROCEDURE DIVISION.                   printf("Arg1=%s\n",arg1);
000-Main.                             printf("Arg2=%s\n",arg2);
    DISPLAY 'Starting maincob'        printf("Arg3=%d\n",*arg3);
    MOVE Z'Arg1'   TO Arg1            arg1[0]='X';
    MOVE Z'Arg2'   TO Arg2            arg2[0]='Y';
    MOVE 123456789 TO Arg3            *arg3=987654321;
    CALL 'subc'                       return 2;
        USING BY CONTENT   Arg1,    }
              BY REFERENCE Arg2,
              BY REFERENCE Arg3
    DISPLAY 'Back'
    DISPLAY 'Arg1=' Arg1
    DISPLAY 'Arg2=' Arg2
    DISPLAY 'Arg3=' Arg3
    DISPLAY 'Returned value='
            RETURN-CODE
    STOP RUN
    .

   The idea is to pass two string and one full-word unsigned arguments
to the subprogram, have the subprogram print them out, change all three
and pass a return code of 2 back to the caller.  The caller will then
re-display the three arguments (showing changes only to the two ‘BY
REFERENCE’ arguments), display the return code and halt.

   While simple, these two programs illustrate the techniques required
quite nicely.

   Note how the COBOL program ensures that a null end-of-string
terminator is present on both string arguments.

   Since the C program is planning on making changes to all three
arguments, it declares all three as pointers in the function header and
references the third argument as a pointer in the function body.  It
actually had no choice for the two string (char array) arguments -- they
must be defined as pointers in the function even though the function
code references them without the leading ‘*’ that normally signifies
pointers.

   These programs are compiled and executed as follows.

     $ cobc -x maincob.cbl subc.c
     $ maincob
     Starting maincob
     Starting subc
     Arg1=Arg1
     Arg2=Arg2
     Arg3=123456789
     Back
     Arg1=Arg1
     Arg2=Yrg2
     Arg3=+0987654321
     Returned value=+000000002
     $

   Remember that the null characters are actually in the GnuCOBOL ‘Arg1’
and ‘Arg2’ data items.  They don't appear in the output, but they are
there.

   Did you notice the output showing the contents of ‘Arg1’ after the
subroutine was called?  Those contents were unchanged!  The subroutine
definitely changed that argument, but since the COBOL program passed
that argument ‘BY CONTENT’, the change was made to a copy of the
argument, not to the ‘Arg1’ data item itself.


File: gnucobpg.info,  Node: C Main Programs Calling GnuCOBOL Subprograms,  Prev: GnuCOBOL Main Programs CALLing C Subprograms,  Up: Combining GnuCOBOL and C Programs

11.8.5 C Main Programs Calling GnuCOBOL Subprograms
---------------------------------------------------

Now, the roles of the two languages in the previous section will be
reversed, having a C main program execute a GnuCOBOL subprogram.
C Calling Program                              GNU-COBOL Called Program
=============================================  =================================
#include <libcob.h> /* COB RUN-TIME */         IDENTIFICATION DIVISION.
#include <stdio.h>                             PROGRAM-ID. subcob.
int main (int argc, char **argv) {             DATA DIVISION.
   int returnCode;                             LINKAGE SECTION.
   char arg1[7] = "Arg1";                      01  Arg1      PIC X(7).
   char arg2[7] = "Arg2";                      01  Arg2      PIC X(7).
   unsigned long arg3 = 123456789;             01  Arg3      USAGE BINARY-LONG.
   printf("Starting mainc...\n");              PROCEDURE DIVISION USING
   cob_init (argc, argv); /* COB RUN-TIME */       BY VALUE     Arg1,
   returnCode = subcob(arg1,arg2,&arg3);           BY REFERENCE Arg2,
   printf("Back\n");                               BY REFERENCE Arg3.
   printf("Arg1=%s\n",arg1);                   000-Main.
   printf("Arg2=%s\n",arg2);                       DISPLAY 'Starting cobsub.cbl'
   printf("Arg3=%d\n",arg3);                       DISPLAY 'Arg1=' Arg1
   printf("Returned value=%d\n",returnCode);       DISPLAY 'Arg2=' Arg2
   return returnCode;                              DISPLAY 'Arg3=' Arg3
}                                                  MOVE 'X' TO Arg1 (1:1)
                                                   MOVE 'Y' TO Arg2 (1:1)
                                                   MOVE 987654321 TO Arg3
                                                   MOVE 2 TO RETURN-CODE
                                                   GOBACK
                                                   .

   Since the C program is the one that will execute first, before the
GnuCOBOL subroutine, the burden of initializing the GnuCOBOL run-time
environment lies with that C program; it will have to invoke the
‘cob_init’ function, which is part of the ‘libcob’ library.  The two
required C statements are shown highlighted.

   The arguments to the ‘cob_init’ routine are the argument count and
value parameters passed to the main function when the program began
execution.  By passing them into the GnuCOBOL subprogram, it will be
possible for that GnuCOBOL program to retrieve the command line or
individual command-line arguments.  If that won't be necessary,
‘cob_init(0,NULL);’ could be specified instead.

   Since the C program wants to allow ‘arg3’ to be changed by the
subprogram, it prefixes it with a ‘&’ to force a ‘CALL BY REFERENCE’ for
that argument.  Since ‘arg1’ and ‘arg2’ are strings (char arrays), they
are automatically passed by reference.

   Here's the output of the compilation process as well as the program's
execution.  The example assumes a Windows system with a GnuCOBOL build
that uses the GNU C compiler on that system; the technique works equally
well regardless of which C compiler and which operating system you're
using.

     C:\Users\Gary\Documents\Programs> cobc -S subcob.cbl
     C:\Users\Gary\Documents\Programs> gcc mainc.c subcob.s -o mainc.exe -llibcob
     C:\Users\Gary\Documents\Programs> mainc.exe
     Starting mainc...
     Starting cobsub.cbl
     Arg1=Arg1
     Arg2=Arg2
     Arg3=+0123456789
     Back
     Arg1=Xrg1
     Arg2=Yrg2
     Arg3=987654321
     Returned value=2
     C:\Users\Gary\Documents\Programs>

   Note that even though we told GnuCOBOL that the 1st argument was to
be ‘BY VALUE’, it was treated as if it were ‘BY REFERENCE’ anyway.
String (char array) arguments passed from C callers to GnuCOBOL
subprograms will be modifiable by the subprogram.  It's best to pass a
copy of such data if you want to ensure that the subprogram doesn't
change it.

   The third argument is different, however.  Since it's not an array
you have the choice of passing it either ‘BY REFERENCE’ or ‘BY VALUE’.


File: gnucobpg.info,  Node: Programming Style Suggestions,  Next: Programming for XFD,  Prev: Sub-Programming,  Up: Top

12 Programming Style Suggestions
********************************

This chapter deals with a variety of stylistic issues that may be of
interest to someone who is just starting out learning and using COBOL.
Much of this chapter makes recommendations and suggestions for how to
write your own programs.  The sample programs in the Sample Programs
document (*note Top: (gnucobsp)Top.) were coded using almost all of
these recommendations.

   There's no particular order of importance to the topics presented
here.
* Menu:

* Marking Changes in Programs.
* Data Item Coding and Naming Conventions.
* Table Subscripting versus Table Indexing.
* Copybook Naming Conventions and Usage.
* PROCEDURE DIVISION Sections Versus Paragraphs.
* COMPUTE Versus ADD-SUBTRACT-MULTIPLY-DIVIDE.


File: gnucobpg.info,  Node: Marking Changes in Programs,  Next: Data Item Coding and Naming Conventions,  Up: Programming Style Suggestions

12.1 Marking Changes in Programs
================================

Historically in the early 60's programs were first punched on to paper
tape and by the mid 60's that was replaced almost totally, by punched
cards although paper tape was still used by programmers for the odd few
changes to their sources held on magnetic tape or disk as a portable
paper tape punch could be put in your pocket.  Now the problem with
punched cards were there was 2,000 cards per box and that they could and
did, get dropped.  So, cc (column) 1 through 6 had the card sequence
number in and that way if a box was dropped they could be feed in to a
card sorter to be fixed.  This was after the cards was cleaned up so
that they were all in the same direction which one corner cut out
helped.

   In the late 70's cards was also on its way out to the point where
P.C's started being used (and no they were not made by IBM), so these
columns could be used for other purposes including cc 73 - 80 instead of
indicating the 8 character program name which was the maximum size
allowed on a IBM system.

   For quite a while now (back to the late 1970's), the sequence number
area' of a COBOL statement (columns 1-6) has come to be used as a change
indicator area.  Programmers would place a code in columns 1-6 of every
line they changed in a program.  The author works in a COBOL shop where
change indicators of the form "xxmmyy" are required on every altered
line of a program -- "xx" is the initials of the programmer while "mmyy"
are the month and two-digit year of the date the change was made.  This
is frequently accompanied by a comment block at or near the top of a
COBOL program providing general documentation of what changes were made
and what change indicator was used to mark that change.

   The GCic sample program source listing (*note GCic: (gnucobsp)GCic.)
provides an excellent example of such documentation.

   This technique of using columns 1-6 as a change indicator will only
work if fixed source-record format is in effect.

   Some COBOL shops prefer to use the eight-character Program Name Area
(columns 73-80) as a change code area.

   Marking changes becomes more of a challenge when free-format source
code is in effect.  Creating a top-of-program comment block to
generically describe changes that have been made isn't difficult, even
in free-form.  What is difficult, however, is coming up with a scheme
for per-statement mark up of changes that doesn't introduce a
ridiculously excessive number of source lines to the program.  I'm not
sure there is a good answer to this problem (if a reader has one, please
let me know).  Generally, I've noticed that shops using free-format
conventions for their COBOL source tend to stick with just the
top-of-program comment block combined with minimal comment blocks
sprinkled throughout the program noting areas that underwent major
changes.


File: gnucobpg.info,  Node: Data Item Coding and Naming Conventions,  Next: Table Subscripting versus Table Indexing,  Prev: Marking Changes in Programs,  Up: Programming Style Suggestions

12.2 Data Item Coding and Naming Conventions
============================================

When programs get very large, it becomes more and more challenging to
keep track of the data items that will be used in the program.  Here, in
no particular order of importance, are a variety of conventions that can
simplify that problem.

   Remember that the points described here are intended to make things
easier for you, the programmer.  No COBOL compiler cares one way or
another whether any of these suggestions are followed.
  1. Avoid the use of level 77 data items in new programs.  Once (1968
     and before) there were valid reasons for creating level-77 data
     items, but since the 1974 ANSI standard of COBOL there really
     hasn't been any reason why an elementary level-01 data item
     couldn't have been used instead of a level-77 item.

  2. Allocate level-01 data items in alphabetical sequence in the
     program source wherever practical.  This will make it vastly easier
     to locate the definitions of 01-level items in the program source
     without having to resort to a compilation cross-reference listing
     and/or text editor "find" command to locate them.

  3. Consider prefixing data items with an indication of where in the
     program structure they were created.  For example:
        • Start everything defined in the file section with "F-"

        • Start everything defined in working-storage with "WS-"

        • Start everything defined in local-storage with "LS-"

        • Start everything defined in the linkage section with "L-"

        • Start everything defined in the screen section with "S-"

        • Start everything defined in the report section with "R-"

     A convention such as this makes it simple, when you're reviewing
     code in the procedure division, to know in which section of the
     data division you should look in when locating the detailed
     description of a data item.  Once you're in the right division,
     coding convention #2 will assist in locating the data item
     definition.

  4. Consider including a trailing descriptor of the nature of all data
     items in their names.  The following chart presents a variety of
     such descriptors the author has encountered and used through the
     years.
     ‘-ADDR’
          The data item contains all or a part of an Address
          (‘City-ADDR’, ‘State-ADDR’, ‘Street-ADDR’, ...)

     ‘-BOOL’
          A level-88 data item (which only has the value ‘TRUE’ or
          ‘FALSE’)

     ‘-CD’
          A code whose value denotes information content above and
          beyond that of the mere value itself.  Some examples could be
          ‘Error-CD’, ‘Status-CD’, ‘Billing-CD’

     ‘-CHR’
          A data item containing a single character of data.

     ‘-CONST’
          A constant, specified as a level-78 data item, a level-01 item
          with the ‘CONST’ attribute

     ‘-DT’
          The data item contains a complete or partial date (‘Birth-DT’,
          ‘ Birth-Month-DT’, ‘ Birth-Year-DT’, ...)

     ‘-DTTM’
          A data item containing both a date and a time

     ‘-FILE’
          A file name.  Note that these items would probably also have a
          "F-" prefix.

     ‘-IDX’
          A data item used as a table index (see section 12.3)

     ‘-NM’
          All or a portion of a person's name.  These could be extended
          to include business names, product names, etc.

     ‘-PTR’
          A data item whose ‘USAGE’ is ‘POINTER’

     ‘-NUM’
          A generic numeric data item that doesn't fit into any of the
          other categories

     ‘-QTY’
          A count of something

     ‘-REC’
          An 01-level item defined in the ‘FILE SECTION’ (constituting
          the layout of a record within a file).  Note that these items
          would probably also have a "F-" prefix.

     ‘-SCR’
          The data item contains a complete or partial screen
          description (appropriate for SCREEN SECTION 01-level data
          items).

     ‘-SUB’
          A numeric item used as a table subscript (see section 12.3)

     ‘-TEL’
          All or part of a telephone number

     ‘-TM’
          The data item contains a complete or partial time value

     ‘-TXT’
          The data item contains generic alphanumeric text that doesn't
          fit into any of the other categories.

     The above is by no means an exhaustive list, but good programmers
     will use as few of these descriptors as possible as having too many
     defeats any benefits of such classification/documentation efforts.

  5. Consider including an acronym to be inserted into the name of any
     data item defined directly or indirectly subordinate to an 01-level
     item, typically to be specified after any section-level tag, if
     you're using them.  For example, consider the names used in the
     following structure:

          01  WS-File-Status-Message-TXT.
              05 FILLER                     PIC X(13) VALUE 'Status Code: '.
              05 WS-FSM-Status-CD           PIC 9(2).
              05 FILLER                     PIC X(11) VALUE ', Meaning: '.
              05 WS-FSM-Msg-TXT             PIC X(25).
          ....
          01  WS-OI-SUB                     PIC 99  COMP.
          01  WS-OI-IDX                     PIC 99  COMP.

     The "-FSM-" acronyms make it easier to locate the description of
     the 01-item the status code and message text items belong to.


File: gnucobpg.info,  Node: Table Subscripting versus Table Indexing,  Next: Copybook Naming Conventions and Usage,  Prev: Data Item Coding and Naming Conventions,  Up: Programming Style Suggestions

12.3 Table Subscripting versus Table Indexing
=============================================

The elements of a table may be referenced either using a subscript or an
index.  Syntactically, this is coded using parenthesis, as per the
following three examples, all of which store the letter ‘A’ into the
17th occurrence of a data item named WS-Output-Image-TXT:
  1. MOVE 'A' TO WS-Output-Image-TXT (17)

  2. MOVE 17 TO WS-OI-SUB
     MOVE 'A' TO WS-Output-Image-TXT (WS-OI-SUB)

  3. SET WS-OI-IDX TO 17
     MOVE 'A' TO WS-Output-Image-TXT (WS-OI-IDX)

   The 1st and 2nd examples are referred to as “Subscripting” while the
3rd is known as “Indexing”.  The distinction is fairly simple.

   Indexing is the process of referencing an element of a table
utilizing a data item with an explicitly or implicitly defined ‘USAGE’
(*note USAGE::) of ‘INDEX’ to select the desired occurrence, while ...

   Subscripting is the process of referencing an element of a table
utilizing either a numeric constant or an unedited numeric data item to
select the desired occurrence.

   Various implementations of COBOL generate object code that is quite
different in each of these three situations, and GnuCOBOL is no
exception.

   In general, table references such as example #1 (constant subscript)
generate the smallest, simplest and fastest object code while table
references such as example #2 (numeric data item subscript) generate the
largest, most-complicated and slowest object code.

   Table references such as example #3 (table indexing) generate object
code that falls in the middle of the other two but is far closer in
efficiency to example #1 than #2.

   Some COBOL statements (‘SEARCH’ (*note SEARCH::), ‘SEARCH ALL’ (*note
SEARCH ALL::) and the table-based ‘SORT’ (*note Table SORT::)) require
you to index the affected table and to utilize that index with those
statements.  With any other references to tables, the choice is left to
the programmer as to which approach should be used.  In general, follow
these rules:
  1. Use constant subscripts (example #1) wherever possible/practical.

  2. If references to table elements are going to be performed many,
     many times (tens or hundreds of thousands of times or more) during
     program execution, you will probably see a noticeable reduction in
     program execution time if you use indexing versus subscripting.

   It's impossible to perform any arithmetic operation against an index
data item directly (other than a simple incrementation or decremental
operation via the ‘SET UP/DOWN’ statement (*note SET UP/DOWN::)).
Situations where any non-trivial computations are required to calculate
the effective occurrence number for a table reference will require you
to use a conventional unedited numeric data item as the receiving field
for the calculation.  That calculated value would then need to be saved
into the index data item via a ‘SET Index’ statement.

   If you only need to use the computed occurrence number once, you
might as well just use the computed occurrence number data item as a
subscript.  If, however, you will need to use a computed "subscript"
many more times than once, the run-time overhead of converting that
occurrence value to an index (via ‘SET Index’) will be worth the coding
effort.

   Whew!

   If references to table elements are not going to be performed many,
many times it probably won't make much difference whether you use
indexing or subscripting.

   If you are comfortable with the C programming language, you might
find the following simple GnuCOBOL program useful in exploring the
differences between subscripting and indexing:

     IDENTIFICATION DIVISION.
     PROGRAM-ID.  SUBVSINDEX.
     DATA DIVISION.
     WORKING-STORAGE SECTION.
     01  WS-TABLE-SUB                BINARY-LONG.
     01  WS-TABLE.
         05 WS-TABLE-ENTRY           OCCURS 20 TIMES
                                     INDEXED BY WS-TABLE-IDX
                                     PIC X(1).
     PROCEDURE DIVISION.
     000-Main SECTION.
     E1. MOVE 'A' TO WS-TABLE-ENTRY (17)
         .
     E2. MOVE 17 TO WS-TABLE-SUB
         MOVE 'A' TO WS-TABLE-ENTRY (WS-TABLE-SUB)
         .
     E3. SET WS-TABLE-IDX TO 17
         MOVE 'A' TO WS-TABLE-ENTRY (WS-TABLE-SUB)
         .

   Compile this program as follows (the assumption is made that you are
executing the ‘cobc’ command from the directory in which the above
program source code (subvsindex.cbl) exists.

     cobc -C -save-temps subvsindex.cbl\

   After this command is executed, the file ‘subvsindex.c’ will contain
the procedure division C code and ‘subvsindex.c.1.h’ will contain the
working-storage C code.  Compare the generated C code for each of the
three ‘MOVE’ statements.


File: gnucobpg.info,  Node: Copybook Naming Conventions and Usage,  Next: PROCEDURE DIVISION Sections Versus Paragraphs,  Prev: Table Subscripting versus Table Indexing,  Up: Programming Style Suggestions

12.4 Copybook Naming Conventions and Usage
==========================================

Since the intent of a copybook is to introduce COBOL code into a
particular spot in a program via the ‘COPY’ statement (*note COPY::), it
is always a good idea to prefix copybook names with a character sequence
that identifies where in a program its contents are intended to be
‘COPY’ed.

   For example:
‘IDxxxxxxxx’
     Copybooks containing code intended for the identification division.
     These will be rare as you almost never encounter copied code in the
     identification division.

‘EDxxxxxxxx’
     Copybooks containing code intended for use in the environment
     division.  These copybooks are generally used for predefined
     ‘SPECIAL-NAMES’ (*note SPECIAL-NAMES::) or ‘FILE-CONTROL’ (*note
     INPUT-OUTPUT SECTION::) syntax,

‘DDxxxxxxxx’
     Copybooks that contain data definitions.

‘PDxxxxxxxx’
     Copybooks that contain executable instructions.


File: gnucobpg.info,  Node: PROCEDURE DIVISION Sections Versus Paragraphs,  Next: COMPUTE Versus ADD-SUBTRACT-MULTIPLY-DIVIDE,  Prev: Copybook Naming Conventions and Usage,  Up: Programming Style Suggestions

12.5 PROCEDURE DIVISION Sections Versus Paragraphs
==================================================

The issue of whether to use section and/or paragraph names (collectively
referred to as procedure names) within the procedure division is one of
near religious significance with many COBOL programmers.

   COBOL programming standards used by many organizations that use the
language generally call for procedure names to:
  1. Contain a leading numeric component (for example:
     ‘2000-Update-Customer’), AND...

  2. Be defined in the procedure division in non-decreasing sequence of
     that numeric component.

   When you are looking at or editing any large COBOL program that has
been created with programming standards that include these two rules, it
is always a simple thing to know whether a reference to a procedure is
being made to code that exists before or after your current location in
the program, simply by comparing the numeric component of the current
procedure's name with the one in question.

   Technically, GnuCOBOL does not require ANY procedure names be defined
unless:
  1. You are using the ‘ALTER’ statement (*note ALTER::) (the use of
     which should be avoided at all costs)

  2. You are using a procedural ‘PERFORM’ statement (*note Procedural
     PERFORM::)

  3. You are using a ‘GO TO’ statement (*note GO TO::)

  4. You are using a ‘MERGE’ statement (*note MERGE::) with an ‘OUTPUT
     PROCEDURE’

  5. You are using a ‘SORT’ statement (*note SORT::) with either (or
     both) an ‘INPUT PROCEDURE’ or ‘OUTPUT PROCEDURE’

  6. You are using ‘DECLARATIVES’ (*note DECLARATIVES::)

   Since it is difficult to write any non-trivial COBOL program that
uses none of the above, lets assume you will be including at least one
section or paragraph in your GnuCOBOL programs.

   I like to use procedure division paragraphs and sections as follows:
  1. The very first procedure defined in the procedure division of my
     programs, assuming no ‘DECLARATIVES’ (*note DECLARATIVES::) are
     defined, will be a section named ‘000-Main’.  The declaration of
     this procedure will immediately follow the procedure division
     header (or ‘END DECLARATIVES’ if ‘DECLARATIVES’ are used).

  2. Any procedures referenced by ‘MERGE’, ‘PERFORM’, or ‘SORT’
     statements will be defined as sections.

  3. Any procedures referenced by ‘GO TO’ statements will be defined as
     paragraphs, and those paragraphs will be defined in the same
     section as the ‘GO TO’ statements that reference them.  In other
     words, ‘GO TO’ statements may not be used to transfer control to a
     point in a different section.  This is not a GnuCOBOL rule -- this
     is my own personal programming practice intended to improve the
     readability and maintainability of my programs.

  4. I always include a numeric prefix to all procedure names I define,
     for the reasons stated earlier.

  5. I do not use ‘THRU’ on any ‘MERGE’, ‘PERFORM’ or ‘SORT’ statement
     unless the programming standards of the shop in which I am working
     require it.  My reasoning for this is that it is too easy to
     accidentally introduce a new procedure into the scope of a ‘THRU’.


File: gnucobpg.info,  Node: COMPUTE Versus ADD-SUBTRACT-MULTIPLY-DIVIDE,  Prev: PROCEDURE DIVISION Sections Versus Paragraphs,  Up: Programming Style Suggestions

12.6 COMPUTE Versus ADD-SUBTRACT-MULTIPLY-DIVIDE
================================================

Over the years, there has been much debate over the efficiency and
arithmetic accuracy of using the ‘COMPUTE’ statement (*note COMPUTE::)
rather than the four basic arithmetic operation statements.

   Here are the facts -- draw your own conclusions as to which approach
is more appropriate under which circumstances.
  1. The ‘COMPUTE’ statement supports exponentiation (via the ‘**’
     operator) -- there is no equivalent basic arithmetic statement.
     Although you could simulate integral exponentiation (raising a
     value to the third power, for example) using ‘MULTIPLY’ statements,
     and you may use the ‘SQRT’ intrinsic function (*note SQRT::) to
     find a square root, there's just no (easy) way to find the
     cube-root of a value without using the ‘COMPUTE’ statement.

  2. For non-trivial computations, ‘COMPUTE’ statements "read" better.
     Take this, for example:

          COMPUTE R = (A + B * C) / D

     As compared to:

          MULTIPLY B BY C GIVING TEMP
          ADD A TO TEMP
          DIVIDE TEMP BY D GIVING R

     For non-trivial computations, ‘COMPUTE’ statements may execute
     faster than the equivalent chain of basic arithmetic statements.
     For example, the COMPUTE statement shown above executes about 25%
     faster on my computer using GnuCOBOL than does the
     MULTIPLY-ADD-DIVIDE sequence.

  3. For trivial computations, on the other hand, I prefer the inherent
     readability of a statement such as this:

          ADD 1 TO WSS-Input-Trans-QTY

     to this:

          COMPUTE WS-Input-Trans-QTY = WS-Input-Trans-QTY + 1


File: gnucobpg.info,  Node: Programming for XFD,  Next: Glossary of Terms,  Prev: Programming Style Suggestions,  Up: Top

13 Programming for XFD
**********************

This chapter deals with the initial support for ODBC and OCI as
file-handlers (so far PostgrSQL, MySQL, SQLite, MSSQL) and OCI, along
with new directory COB_SCHEMA_DIR containing the necessary internal
schema files to match the file definition to the database table all
though usage of $XDF.

* Menu:

* GnuCobol use SQL for files.


File: gnucobpg.info,  Node: GnuCobol use SQL for files,  Up: Programming for XFD

13.1 GnuCobol use SQL for files
===============================

The ACUCOBOL compiler has a defined syntax for describing records that
can be stored in SQL tables.  This is referred to as XFD (extended file
descriptor).  The various XFD directives are intermixed in the record
description of a data file as either $XFD (similar to $SET) or as
comments *((XFD … )).  Each directive precedes the data item it is
affecting.  When a program is compiled that has these directives and the
compiler is directed by a compile option, then the record layout is
written out to a text file which is later used at run-time to process
the data records.  i.e., facilitate mapping the COBOL data fields
to/from SQL columns.

   The goal of this project is for GnuCOBOL to accept directives similar
in syntax to the ACUCOBOL XFD syntax1 (plus a few additions as required)
and develop run-time modules to handle all of the COBOL I/O verbs while
the data is stored in a SQL table.

   The purpose for doing this is to allow legacy COBOL to have data
stored in SQL tables without rewriting the COBOL code.  If a COBOL based
application is already using EXEC SQL this feature of having INDEXED
files stored in SQL tables is really not of any use.  Once the data is
in SQL tables it may be accessed by other SQL tools.  To get access to
more advanced SQL features, the COBOL code will need to be recoded to
use EXEC SQL, but this can be done at points which provide the most
advantage.

   At present both INDEXED and RELATIVE files are supported using either
an ODBC or OCI (Oracle Call Interface) interface.  RELATIVE files are
supported by adding a special column that gets a unique number as the
RELATIVE KEY. The intention is that you could store the data for the
‘master data files’ of an application in an SQL database.  Often COBOL
based applications have intermediate data files and it would be a waste
of time to place these into the database.  Also keep in mind that the
performance of ISAM will be much better than using an SQL database.
However, SQL provides the opportunity to use ‘ad hoc inquiry’ and other
third party tools to process your data.

   When directed by the XFD directives, the GnuCOBOL compiler will write
out the CREATE TABLE statements that could be used to represent the
file.  The GnuCOBOL compiler will also write out a data description file
which is read at runtime and used to manage the conversion of data
between the COBOL record view and the SQL column view.  The format of
this data description file is not exactly the same as what ACUCOBOL had
used since the file is easily regenerated.  The more important feature
is to accept similar XFD directives intermixed in the record
description.

   XFD Directives

   The following directives are accepted intermixed in the COBOL record
description.  The KEY IS clauses from SELECT statements will be used to
generate SQL INDEX statements.

$XFD Name      XFD Directive Descriptions
--------------------------------------------------------------------------
ALL            Indicates this is a special module defining all files in
               an application system so all files in this module should
               be defined for use via SQL
FILE           Name to be used for SQL table, filename.ddl and
               filename.xd instead of guessing from the SELECT/ASSIGN.
               If FILE is not provided then if ASSIGN “filename” is
               used that is taken, other wise the SELECT name is used
               for the table name and the .ddl and .xd files.
ALPHA          Next field is handled as a single CHAR type.  If a group
               item the entire group is a single CHAR column.  May
               optionally have alternate name.
BINARY         Next field handled as BINARY (RAW) so arbitrary hex data
               is stored.  If a group item the entire group becomes a
               single BINARY column.  May optionally have alternate
               name
CHAR           Next field is handled as a single CHAR type.  If a group
               item the entire group is a single CHAR column.  May
               optionally have alternate name.
DATE           Next field is a date in the defined format
               M - month (01 – 12), Y - year (2 or 4 digit), D - day of
               month (01-31)
               H - hour (00 -23), N – minute, S – second, T -
               hundredths of a second
               J - Julian day, E - day of year
               YY%nn – ‘nn’ is the pivot year
               YYY+nnnn – ‘nnnn’ is added to YYY to compute the actual
               year
GROUP type     The next field or group item is taken as a single SQL
               column of the declared type
NAME           Name to be used for the next SQL column
NUMERIC        Next field is handled as NUMERIC, may optionally have
               alternate name
USE type       The word ‘USE’ is essentially ignore and the next word
               defines the field type
VARCHAR        Emit next field as VARCHAR instead of CHAR
VAR-LENGTH     Emit next field as VARCHAR instead of CHAR
WHEN fld op    ‘fld’ is some previous field in the record, ‘val’ is a
val            numeric value of alpha value in quotes, op is one of =,
               !=, >, >=, <, <=.  ‘val’ may be ‘other’ to indicate
               other cases.  If the condition is true then the
               following field/group format is used.
AND fld op     A continuation of the previous WHEN logically connect as
val            an AND condition
OR fld op      A continuation of the previous WHEN logically connect as
val            an OR condition

Name           GnuCOBOL Compile time Option Descriptions
--------------------------------------------------------------------------
-fsqldb=name   ’name’ indicates which database is to be used.  Choose
               one of ODBC, MySQL, MSSQL, OCI, Oracle10, Oracle11,
               Oracle12.
-fsqlschema=name’name’ is sub-directory into which the filename.ddl
               holding CREATE TABLE is written as well as the
               filename.xd holding the data mapping information.  If
               omitted then the ddl/xd files are written to the base
               ‘schema_dir’ directory.


Environment
Variable         runtime.cfg  GnuCOBOL Run time Option Descriptions

COB_SCHEMA_DIR   schema_dir   Define location where the filename.xd files are
                              stored. Default: $COB_CONFIG_DIR/schema
COB_SCHEMA_NAME  schema_name  Database schema name
COB_SCHEMA_UID   schema_uid   Database User-id for connecting to the database
COB_SCHEMA_PWD   schema_pwd   Password for database User-Id
COB_SCHEMA_DSN   schema_dsn   DSN name for database
COB_DEBUG_LOG                 Parameters for GnuCOBOL logging feature.
                              Module type is ‘db’

   Implementation Plan - GnuCOBOL Developer Notes

   To support $XFD directives changes were made to pplex.l, ppparse.y
and scanner.l.  Also codegen.c and field.c will need changes.

   Additional flags may have to be added to cb_field to retain the XFD
directive information.

   In codegen.c (output_file_initialization) depending on use of XFD and
compile options is the location to emit the CREATE TABLE and the data
description file.  The cob_file will get some new flags for io_routine
to indicate the file is really handled by ODBC/OCI.

   A new fileio routine (fodbc.c and later foci.c) were developed
following the recently developed interface for multiple I/O handlers.
The cob_load_xfd routine loads the data description file into internal
structures.  Multiple schemas could have the same table name/structure
for development, QA, production, etc.  This could be indicated via
runtime.cfg options and/or environment variables.  IO_asgname may have
format=odbc or format=oci to indicate which method is used to access the
SQL table for the file.  You may also specify table=sql_table_name to
override the default SQL table.

   At run-time when the file is opened the file description is loaded
into memory for fast access and conversion of the data between COBOL
data type and SQL column data.  Since SQL tables are usually collected
under a database schema we’ll need a compile option to generate the
external file description under either a default directory or under a
given ‘schema’ name.  At run-time an environment variable and/or
runtime.cfg option could be used to define which database schema is to
be used along with the database user-id and password.  Often a database
user-id has a default schema associated with it.

   The module fsqlxfd.c contains routines common to both fodbc.c and
foci.c such as loading of the filename.xd information and conversion of
the data between SQL and COBOL data types.  When the file is OPENed and
the table is found to not exist, then cob_load_ddl loads the
filename.ddl into memory for the OCI/ODBC routine to submit the CREATE
TABLE/INDEX statements as required.  As the table is loaded, if it
contains column types not supported by the current database then there
is a translation done during the load process.

   Format of filename.xd

   GnuCOBOL has its own format instead of using what ACUCOBOL had.  The
first character on each line indicates what the line is.  Lines starting
with # or * are comments.  Each field is separated by a comma.

Name        Header Line Description
--------------------------------------------------------------------------
H           Is a header
1           Version number
table       SQL table name
‘,’         For character used as decimal, default ‘,’
‘.’         For character used as comma, default ‘.’
Hex         Indicate how numeric signs are handled
num         File type, 3 for INDEXED, 2 for RELATIVE

Name        Label Description
--------------------------------------------------------------------------
L           Is a Label
Num         Numeric label, may be referenced by ‘goto’ or ‘condition’

Name        Goto Description
--------------------------------------------------------------------------
G           Is a Goto
Num         Numeric label to transfer to

Name        Condition Description
--------------------------------------------------------------------------
C           Is a Condition to be tested (Appear in postfix sequence)
            Complex WHEN clauses become multiple Condition tests
Label       If condition test is true, then goto this label, 0
            indicates more coming, non-zero indicates end of the WHEN
            condition to be tested
Opcode      >=, >, <=, <, =, !=, &&, ||, !
Operand     Usually the data field
Value       String in quotes or numeric value

Name        Date Format Description
--------------------------------------------------------------------------
D           Date format definition
num         Unique number for this format
‘date’      Date format string
num         Total number of digits in this date field
num         1 if DATE present else 0
num         1 if TIME present else 0
yy rule     + means add yyAdj to YY, % defines pivot point
num         Value for adjusting the Year
P:L         Year Position and Length within field
P:L         Month Position and Length within field
P:L         Day Position and Length within field
P:L         Hours Position and Length within field
P:L         Minutes Position and Length within field
P:L         Seconds Position and Length within field
P:L         Century date Position and Length within field

   You may define how your application stores DATE information.  The
database will always expect dates to be in a full YYYYMMDD format and
date/time to be in YYYYMMDDHHMISS format.  Date fields could be defined
like the following:


     $XFD  DATE "YYYYMMDD"
     $XFD  DATE "YY%60MMDD"
     $XFD  DATE "YYY+1800MMDD"
     $XFD  DATE "YYMMDDCC"

   The Y is a place holder for YEAR, MM for month, DD for day, HH hour,
MI minutes, SS seconds, CC for century.  If the Ys are followed by ‘%’
then the digits after the ‘%’ defines a pivot year used to map the YY
value into a 4 digit year.  In the above example if the YY value is
below 60 then it is 19YY else 20YY

   If the Y's are followed by ‘+’ then the digits after the ‘+’ are
added to the Y value.  In above example, the year is 1800 + YYY value.
There is a limit of 16 different DATE formats per record.

   If the day is defined like DDD (3 Ds) then it is taken to be the day
of the year.  For example:


     $XFD DATE "YYYYDDD"

Name        Data Description
--------------------------------------------------------------------------
F           Define data Field
num         Offset from record to start of COBOL data field
num         Bytes occupied by COBOL data field
num         Type of data field
            1 Arbitrary Binary Data
            2 PIC S9 COMP-5
            3 PIC 9 COMP-5
            4 PIC 9 COMP-6
            5 PIC S9 BINARY/COMP/COMP-4
            6 PIC 9 BINARY/COMP/COMP-4
            7 PIC x COMP-X
            8 COMP-1/COMP-2
            9 PIC S9 COMP-3/PACKED DECIMAL
            10 PIC 9 COMP-3/PACKED DECIMAL
            11 PIC S9 SIGN LEADING
            12 PIC S9 SIGN LEADING SEPARATE
            13 PIC S9
            14 PIC 9 SIGN TRAILING
            15 PIC 9 SIGN TRAILING SEPARATE
            16 PIC 9
            17 PIC A
            18 PIC X National characters
            19 PIC X Wide characters
            20 PIC X
            21 PIC X - VARCHAR
num         Bytes needed to store as SQL data
num         Digits in numeric field
num         Scale (or decimal places)
num         Unique id of date format (see D)
num         COBOL level number
name        SQL Column name used for data field

Name        Key Definitions Description
--------------------------------------------------------------------------
K           Define an index
num         Index number (1 – 16)
dup         Y if duplicates allowed, else N
sup         Y if key may be suppressed, else N
char        Suppress character either as ‘c’ or 0xHH or “string”
columns     Comma separate list of column names in order that make up
            the index


Example Records to Table With the following:

           SELECT OPTIONAL TSPFILE
           ASSIGN TO "testsql"
           ORGANIZATION INDEXED ACCESS DYNAMIC
           RECORD KEY IS PRIME-KEY
           SOURCE IS CM-CUST-NUM

           ALTERNATE RECORD KEY IS SPLIT-KEY2
           SOURCE IS CM-TELEPHONE,CM-MACHINE WITH DUPLICATES
                SUPPRESS WHEN "900"

           ALTERNATE RECORD KEY IS SPLIT-KEY3
           SOURCE IS CM-DISK,CM-DP-MGR,CM-MACHINE WITH DUPLICATES
                SUPPRESS WHEN ALL "*"
           FILE STATUS IS CUST-STAT
           .

           SELECT FLATFILE ASSIGN "relfile"
           ORGANIZATION RELATIVE
           ACCESS IS RANDOM RELATIVE KEY IS REC-NUM
           FILE STATUS IS CUST-STAT.

           SELECT FLATSEQ ASSIGN "relfile"
           ORGANIZATION RELATIVE
           ACCESS IS SEQUENTIAL RELATIVE KEY IS REC-NUM
           FILE STATUS IS CUST-STAT.

Note that FLATFILE and FLATSEQ are the same file called “relfile” with a different
ACCESS. Given the following record description:


      $XFD ALL
       FD  FLATFILE
           BLOCK CONTAINS 5 RECORDS.

       01  FLAT-RECORD.
           10  RL-CUST-NUM                     PICTURE X(8).
           10  RL-COMPANY                      PICTURE X(25).
           10  RL-TRAILER                      PICTURE X(16).

       FD  FLATSEQ
           BLOCK CONTAINS 5 RECORDS.

       01  RS-RECORD.
           10  RS-CUST-NUM                     PICTURE X(8).
           10  RS-COMPANY                      PICTURE X(25).
           10  RS-TRAILER                      PICTURE X(16).

       FD  TSPFILE
           BLOCK CONTAINS 5 RECORDS.

      $XFD NAME=tspfilex
       01  TSPFL-RECORD.
           05  TSPFL-REC.
      $XFD USE GROUP CUSTNUM
           10  CM-CUST-NUM.
             15  CM-CUST-PRE                   PICTURE X(3).
             15  CM-CUST-NNN                   PICTURE X(5).
           10  CM-STATUS                       PICTURE X.
           10  CM-COMPANY                      PICTURE X(25).
      $XFD USE GROUP VAR_LENGTH custaddr
           10  CM-ADDRESS.
             15  CM-ADDRESS-1                  PICTURE X(25).
             15  CM-ADDRESS-2                  PICTURE X(25).
             15  CM-ADDRESS-3                  PICTURE X(25).
           10  CM-TELEPHONE                    PICTURE 9(10).
           10  CM-DP-MGR                       PICTURE X(25).
           10  CM-MACHINE                      PICTURE X(8).
           10  CM-MEMORY                       PICTURE X(4).
      $XFD WHEN (CM-STATUS = 'A' && CM-TELEPHONE > 100)
      $XFD AND CM-MACHINE = 'B' || CM-COMPANY = ' '
           10  CM-MEMORYX REDEFINES CM-MEMORY.
             15  CM-MEMSZ                      PICTURE 9(2).
             15  CM-MEMUNIT                    PICTURE X(2).
           10  CM-DISK                         PICTURE X(8).
           10  CM-TAPE                         PICTURE X(8).
      $XFD WHEN CM-STATUS = 'X'
           10  CM-TAPEX REDEFINES CM-TAPE      PICTURE 9(8).
      $XFD WHEN CM-STATUS = 'Y'
           10  CM-TAPEY REDEFINES CM-TAPE      PICTURE 9(6)V99.
           10  CM-NO-TERMINALS                 PICTURE 9(5) BINARY.
           10  CM-COMPX                        PICTURE XXX COMP-X.
           10  CM-COMP5                        PICTURE 9(7) COMP-5.
           10  CM-COMP1                        COMP-1.
           10  CM-COMP2                        COMP-2.
           10  CM-PRICE                        PICTURE 9(3)V99 COMP-3.
           10  CM-PRICES                       PICTURE S9(5)V99.
      $XFD DATE "MMDDYYYY"
           10  CM-DATE                        PICTURE 9(8) COMP-3.
      $XFD DATE "YYMMDDCC"
           10  CM-DATE2                        PICTURE 9(8) COMP-3.


And  the resulting SQL table(s) would look like:

tspfilex.ddl --

CREATE TABLE tspfilex (
   custnum                                  CHAR(8) NOT NULL,
   status                                   CHAR(1),
   company                                  CHAR(25),
   custaddr                                 VARCHAR(75),
   telephone                                DECIMAL(10) NOT NULL,
   dp_mgr                                   CHAR(25) NOT NULL,
   machine                                  CHAR(8) NOT NULL,
   memory                                   CHAR(4),
   memsz                                    DECIMAL(2),
   memunit                                  CHAR(2),
   disk                                     CHAR(8) NOT NULL,
   tape                                     CHAR(8),
   tapex                                    DECIMAL(8),
   tapey                                    DECIMAL(8,2),
   no_terminals                             DECIMAL(5),
   compx                                    DECIMAL(8),
   comp5                                    DECIMAL(7),
   comp1                                    FLOAT(23),
   comp2                                    FLOAT(53),
   price                                    DECIMAL(5,2),
   prices                                   DECIMAL(7,2),
   date_x                                   DATE,
   date2                                    DATE
);
CREATE UNIQUE INDEX pk_tspfilex ON tspfilex (custnum);
CREATE INDEX k1_tspfilex ON tspfilex (telephone,machine);
CREATE INDEX k2_tspfilex ON tspfilex (disk,dp_mgr,machine);

relfile.ddl --

CREATE TABLE relfile (
   cust_num                                 CHAR(8),
   company                                  CHAR(25),
   trailer                                  CHAR(16),
   rid_relfile                              BIGINT PRIMARY KEY
);


The tspfilex.xd description for this follows:

H,1,tspfilex,2,',','.',0,3
D,1,'MMDDYYYY',8,1,0,,0,4:4,0:2,2:2,0:0,0:0,0:0,0:0
D,2,'YYMMDDCC',8,1,0,,0,0:2,2:2,4:2,0:0,0:0,0:0,6:2
F,0000,0008,20,0009,0,0,,10,custnum
F,0008,0001,20,0002,0,0,,10,status
F,0009,0025,20,0026,0,0,,10,company
F,0034,0075,21,0076,0,0,,10,custaddr
F,0109,0010,16,0013,10,0,,10,telephone
F,0119,0025,20,0026,0,0,,10,dp_mgr
F,0144,0008,20,0009,0,0,,10,machine
C,0,=,status,'A'
C,0,>,telephone,100
C,0,&&
C,0,=,machine,'B'
C,0,=,company,' '
C,0,||
C,2,&&
F,0152,0004,20,0005,0,0,,10,memory
G,3
L,2
F,0152,0002,16,0005,2,0,,15,memsz
F,0154,0002,20,0003,0,0,,15,memunit
L,3
F,0156,0008,20,0009,0,0,,10,disk
C,5,=,status,'X'
C,6,=,status,'Y'
F,0164,0008,20,0009,0,0,,10,tape
G,7
L,5
F,0164,0008,16,0011,8,0,,10,tapex
G,7
L,6
F,0164,0008,16,0011,8,2,,10,tapey
L,7
F,0172,0004,06,0013,5,0,,10,no_terminals
F,0176,0003,07,0011,8,0,,10,compx
F,0179,0004,03,0013,7,0,,10,comp5
F,0183,0004,08,0036,15,8,,10,comp1
F,0187,0008,08,0036,34,17,,10,comp2
F,0195,0003,10,0008,5,2,,10,price
F,0198,0007,13,0010,7,2,,10,prices
F,0205,0005,10,0032,8,0,1,10,date_x
F,0210,0005,10,0032,8,0,2,10,date2
K,0,N,N,,custnum
K,1,Y,Y,"900",telephone,machine
K,2,Y,Y,0x2A,disk,dp_mgr,machine


The relfile.xd description for this follows:

H,1,relfile,0,',','.',0,2
F,0000,0008,20,0009,0,0,,10,cust_num
F,0008,0025,20,0026,0,0,,10,company
F,0033,0016,20,0017,0,0,,10,trailer
F,0049,0004,03,0015,12,0,,00,rid_relfile
K,0,N,N,,rid_relfile

   Application Schema

   Sometimes COBOL programs will have local views of the data by copying
a record to some other group item which redefines the data differently.
In some cases these “hidden” redefines will cause problems for SQL
columns.  For example, if a field is defined as PIC 9(x) but sometimes
the same location in the record contains non-numeric data, then SQL will
reject the storing of such data as it violates the strict data typing.
By using the $XFD WHEN you are able to define which a portion of the
record has one view other another.  The I/O logic will then only copy
the valid column of data.

   It may therefore be a good idea to collect all of the file
definitions into a single module, verify that all possible redefines are
identified.  The $XFD ALL directives indicates that such a module is
being compiled.  Think of this module as defining all of the master data
files in an application which will be migrated into SQL tables.

   Check the DDL

   It is a good idea to check the DDL generated by the GnuCOBOL compiler
and make sure it suits your local database guidelines.  You may also
need to add local directives such as a STORAGE clause for Oracle.  You
should then use the appropriate tool (eg.  Mysql or sqlplus) and
manually create all of the tables to be used by an application.  There
may also be considerations for what database user-id has permission to
create tables, read/write tables etc.

   Automatic Table Creation

   At OPEN time, the filename.xd is processed and if not present that is
considered a serious error (30) is returned.

   At OPEN time, a check is done to see if the table exists and if not,
the run-time code then reads the filename.ddl and submits it to the
database to create the table and indexes.  If the filename.ddl is not
present then OPEN is given an error (30).  If runtime.cfg option
create_table is ‘true’ then the runtime will attempt to recreate
filename.ddl from the information in filename.xd.

   Taken from Development Notes by Ron Norman February 2020.


File: gnucobpg.info,  Node: Glossary of Terms,  Next: Reserved Word List,  Prev: Programming for XFD,  Up: Top

Appendix A Glossary of Terms
****************************

“Alphabetic Data Item”
     A data item whose ‘PICTURE’ clause allows it to contain only upper-
     and/or lower-case letters.  *Note PICTURE::.

“Alphanumeric Data Item”
     A data item whose ‘PICTURE’ clause allows it to contain absolutely
     any character whatsoever.  *Note PICTURE::.  Group items (*note
     Structured Data::) are also implicitly considered to be
     alphanumeric data items.

“Alphanumeric Literal”
     A string of characters enclosed within a pair of quotation marks
     (‘"’) or apostrophes (‘'’).  *Note Alphanumeric Literals::.

“Called Program”
     Another way to refer to a subprogram.  Note that a called program
     may also be a calling program.

“Calling Program”
     A program that executes a subprogram.  Note that a calling program
     may also be a called program.

“Collating Sequence”
     The sequence in which the characters that are acceptable to a
     computer are ordered for purposes of all types of sorting, merging,
     comparing, and processing.  GnuCOBOL programs may utilize standard
     character-set collating sequences (such as that defined by the
     ASCII or EBCDIC character sets) or programmer-defined custom
     sequences as specified in the OBJECT-COMPUTER paragraph (section
     4.1.2) and defined in the SPECIAL-NAMES paragraph (section 4.1.4).

“Compilation Group”
     The collection of all compilation units being compiled by a single
     execution of the GnuCOBOL compiler.

“Compilation Unit”
     A single source file being compiled by the GnuCOBOL compiler.  A
     compilation unit may contain one or more programs.

“Control Break”
     An event that is triggered when a control field on an
     RWCS-generated report changes value.  It is these events that
     trigger the generation of control heading and control footing
     groups.

“Control Field”
     A field of data being presented within a detail group; as the
     various detail groups that comprise the report are presented, they
     are presumed to appear in sorted sequence of the control fields
     contained within them.  As an example, a department-by-department
     sales report for a chain of stores would probably be sorted by
     store number and - within like store numbers - be further sorted by
     department number.  The store number will undoubtedly serve as a
     control field for the report, allowing control heading groups to be
     presented before each sequence of detail groups for the same store
     and control footing groups to be presented after each such
     sequence.

“Control Footing”
     A report group that appears immediately after one or more detail
     groups of an RWCS-generated report.  Such are produced
     automatically as a result of a control break.  This type of group
     typically serves as a summary of the detail group(s) that precede
     it, as might be the case on a sales report for a chain of stores,
     where the detail groups documenting sales for each department (one
     department per detail group) from the same store might be followed
     by a control footing that provides a summation of the
     department-by-department sales for that store.

“Control Heading”
     A report group that appears immediately before one or more detail
     groups of an RWCS-generated report.  Such are produced
     automatically as a result of a control break.  This type of group
     typically serves as an introduction to the detail group(s) that
     follow, as might be the case on a sales report for a chain of
     stores, where the detail groups documenting sales for each
     department (one department per detail group) from the same store
     might be preceded by a control heading that states the full name
     and location of the store.

“Control Hierarchy”
     The natural hierarchy of control breaks within a RWCS-controlled
     report based upon the manner in which the data the report is being
     generated from is sorted.

“Copybook”
     A segment of program code that may be utilized by multiple programs
     simply by having that program use the ‘COPY’ statement to import
     that code into the program.  Although similar to the "include"
     facility present in many other programming languages, the COBOL
     copybook mechanism is actually considerably more powerful.  *Note
     Copybooks::, for a general discussion.  *Note COPY::, for the
     specifics of the ‘COPY’ statement.

“Data Item”
     A contiguous area of storage within the memory space of a program
     that may be referenced, by name, in a COBOL program.  Other
     programming languages use the term variable, property or attribute
     to describe the same concept.  *Note Structured Data::.

“Detail Group”
     A report group that contains the detailed data being presented for
     the report.

“Detail Report”
     An RWCS-generated report to which at least one type of detail group
     is presented.

“Division”
     A collection of zero, one, or more sections of paragraphs, called
     the division body, that are formed and combined in accordance with
     a specific set of rules.  Each division consists of the division
     header and the related division body.  There are four divisions in
     a GnuCOBOL program: Identification, Environment, Data, and
     Procedure (coded in that sequence).  *Note Program Structure::.

“Dynamic Subprogram”
     A subprogram whose executable object code is contained in a
     different executable file as its calling program.  Dynamic
     subprograms are therefore loaded into memory as needed.

“Elementary Item”
     A data item that isn't itself comprised of other data items.  *Note
     Structured Data::.

“Entry-point”
     A spot in the procedure division where a program may begin
     execution when it is executed from the operating system, invoked as
     a user-defined function or called by another program.

     Every program has at least one entry-point -- known as the primary
     entry-point -- which corresponds to the first executable statement
     in the procedure division following the declaratives area, if any.

     Additional entry-points may be defined via the ‘ENTRY’ statement
     (*note ENTRY::).

“Entry-point Name”
     Every entry-point has a name.  That name must be unique for all
     programs that comprise an executable program.  Entry-point names
     are defined using a subroutine's ‘PROGRAM-ID’ paragraph, a
     user-defined function's ‘FUNCTION-ID’ paragraph or via ‘ENTRY’
     (*note ENTRY::) statements coded in a subprogram's procedure
     division.

“Executable File”
     The GnuCOBOL compiler can create operating-system appropriate files
     that may be executed directly from the operating system
     environment.  On Windows systems, these will be ‘.exe’ files
     whereas on UNIX systems they will have no specific extensions.  The
     compiler's ‘-x’ switch is used to create executable files.  Only
     main programs should be compiled in this manner.

“Execution Thread”
     The complete set of executable code that is run during the
     execution of a program.  This includes the main program as well as
     all executed subprograms, including those that are both dynamically
     and statically loaded.

“Figurative Constants”
     GnuCOBOL, like other COBOL implementations, supports a number of
     reserved words that may be used to represent a specific literal
     value.  These are known as figurative constants.  *Note Figurative
     Constants::, for more information.

“Fixed Format Mode”
     A mode of the GnuCOBOL compiler's operation where source statements
     are constrained to meeting the pre-2002 standard of limiting COBOL
     statements to 80 columns, with various columns having limitations
     as to what sort of COBOL syntax could be specified in them.  *Note
     Format of Program Source Lines::, for more information.

“Free Format Mode”
     A mode of the GnuCOBOL compiler's operation where source statements
     are allowed to be as long as 255 characters, with no restrictions
     or requirements as to in which columns various syntax elements must
     appear.  *Note Format of Program Source Lines::, for more
     information.

“Group Item”
     A hierarchical data structure where the group item -- itself a data
     item -- actually consists of two or more other contiguously
     allocated data items.  For example, ‘Employee-Name’ could be a
     35-character data item consisting of a 20-character ‘Last-Name’
     data item followed by a 14-character ‘First-Name’ and a 1-character
     ‘Middle-Initial’.  *Note Structured Data::.

“Hexadecimal Alphanumeric Literal”
     These are alphanumeric literals whose character sequence is
     specified by hexadecimal value.  These literals are formed by a
     quote- or apostrophe-delimited sequence of an even number of
     hexadecimal digits (upper- or lower-case), prefixed with the letter
     ‘X’ (also upper- or lower-case).  For example, the character string
     "‘Demo’" could be specified as the hexadecimal alphanumeric literal
     ‘X'44656D6F'’, assuming the ASCII character set.  *Note
     Alphanumeric Literals::.

“Hexadecimal Numeric Literal”
     A numeric literal whose value is specified by hexadecimal value.
     These literals are formed by a quote- or apostrophe-delimited
     sequence of from 1 to 16 hexadecimal digits (upper- or lower-case),
     prefixed with the letter ‘H’ (also upper- or lower-case).  For
     example, the number 123456 could be specified as the hexadecimal
     numeric literal ‘H'01E240'’.  *Note Numeric Literals::.

“Identifiers”
     These are data items a COBOL program will be working with.  The
     vast majority of identifiers are defined by the user (programmer)
     while a few are pre-defined by the GnuCOBOL compiler.  Identifiers
     pre-defined by the compiler are referred to as special registers.
     Other programming languages generally refer to identifiers as
     "variables".

“Imperative Statement”
     Either a statement that begins with a non decision-making verb and
     specifies an unconditional action to be taken or a conditional verb
     such as ‘IF’ or ‘EVALUATE’, delimited by its explicit scope
     terminator (such as ‘END-IF’ or ‘END-EVALUATE’).  An imperative
     statement can consist of a sequence of imperative statements.

“Intrinsic Function”
     A built-in routine that accepts arguments and returns a value;
     syntactically, these may be used most places where GnuCOBOL
     identifiers are valid.  *Note List of Intrinsic Functions::, for
     documentation on all the GnuCOBOL intrinsic functions.

“Level Number”
     A 1- or 2-digit number that indicates the hierarchical position of
     a data item in a group item or the special properties of a data
     description entry.

     Level numbers in the range 1 through 49 indicate the position of a
     data item in the hierarchical structure of a logical record.  Level
     numbers in the range 1 through 9 can be written either as a single
     digit or as a zero followed by the significant digit.

     Level numbers 66, 77, 78 and 88 identify special properties of a
     data description entry.

“Literal”
     A generic term used for a constant value coded in a program that
     may be either a numeric literal or an alphanumeric literal.

“Main program”
     A program that is executed directly from an operating system or
     shell event.  Main programs are not executed from other programs
     (i.e.  they are not called programs).

“National Character set”
     A character set that supports symbols using other than the
     traditional Roman alphabet symbols used by the ASCII character set.
     Typically, such a character set uses a UTF-16 (i.e.  16
     bits-per-character) encoding of the Unicode character set.

     Support for national character sets in GnuCOBOL is currently only
     partially implemented, and the compile- and run-time effect of
     using the ‘N’ symbol in a ‘PICTURE’ (*note PICTURE::) clause to
     define a field as containing national characters is the same as if
     ‘X(2)’ had been coded, with the additional effect that such a field
     will qualify as a ‘NATIONAL’ or ‘NATIONAL-EDITED’ field on an
     ‘INITIALIZE’ (*note INITIALIZE::) statement.

“Numeric Data Item”
     A data item whose ‘PICTURE’ clause allows it to contain only the
     numeric digit characters ‘0’-‘9’ (signed or unsigned), or a data
     item whose ‘PICTURE’/‘USAGE’ combination allow it to contain actual
     binary numbers in integer, fixed-point, floating-point or
     packed-decimal format.  Numeric data items are the only ones that
     may be used as table subscripts or as source arguments on
     arithmetic statements.  ‘PICTURE’ (*note PICTURE::), or ‘USAGE’
     (*note USAGE::).

“Numeric Edited Data Item”
     An otherwise numeric data item whose ‘PICTURE’ (*note PICTURE::)
     clause also contains any of the editing symbols ‘$’, ‘*’, ‘+’, ‘,’,
     ‘-’, ‘.’, ‘/’, ‘0’ (zero), ‘B’, ‘CR’, ‘DB’ or ‘Z’.  Numeric edited
     data items are not eligible to serve as table subscripts or source
     arguments on arithmetic statements.

“Numeric Literal”
     A numeric constant.  *Note Numeric Literals::.

“Page Footing”
     A report group that appears at the bottom of every page of an
     RWCS-generated report.  Information typically found within such a
     report group might be:

        • The date the report was generated
        • The current page number of the report

“Page Heading”
     A report group that appears at the top of every page of an
     RWCS-generated report.  Information typically found within such a
     report group might be:

        • A title for the report
        • The date the report was generated
        • The current page number of the report
        • Column headings describing the fields within the detail
          group(s)

“Primary Entry-Point”
     See entry-point.

“Procedure”
     All executable code statements within a single procedure division
     paragraph or section.

“Procedure name”
     A programmer-defined section or paragraph name in the procedure
     division assigned to a procedure.  Procedure names serve as a means
     by which a statement may refer to the statements that follow the
     procedure name.

“Program”
     A GnuCOBOL main program or subprogram.

“Qualification”
     The process of establishing a unique reference to a data item whose
     name is duplicated in a program.  This takes the form of using the
     duplicated data name and the name of any of its parent data items,
     connected by ‘OF’ or ‘IN’ such that the combination of those two
     data names is unique within the program.

“Record”
     A group item that is not part of a higher-level group item.  *Note
     Data Definition Principles::.  An elementary item with a level
     number of 01 can also be referred to as a record if its definition
     occurs in the file section, provided that its definition does not
     include the ‘CONSTANT’ attribute.  *Note FILE-SECTION-Data-Item::.

“Report Footing”
     A report group that occurs only once in an RWCS-generated report --
     as the very last presented report group of the report.  These
     typically serve as a visual indication that the report is finished.

“Report Group”
     One or more consecutive lines on a report that serve a common
     informational purpose or function.  For example, lines of text that
     are displayed at the top or bottom of every printed page of a
     report.

“Report Heading”
     A report group that occurs only once in an RWCS-generated report --
     as the very first presented report group of the report.  These
     typically serve as an introduction to the report.

“Reserved Word”
     A word coded in a GnuCOBOL program without any quote or apostrophe
     characters around it (which would have transformed that sequence of
     characters into a literal string) which has a very specific meaning
     to the compiler.  *Note Language Reserved Words::, for a general
     discussion of the concept.  Appendix C for a complete list of
     GnuCOBOL reserved words.

“Sentence”
     An arbitrarily long sequence of statements terminated by a period.

“Special Registers”
     Special data items that are automatically defined for your use by
     the GnuCOBOL compiler.  *Note Special Registers::, for a complete
     list.

“Statement”
     A single executable COBOL instruction.  All statements start with a
     verb (‘DISPLAY’, ‘IF’, ‘MOVE’, ...)  which is followed by the
     operands and additional syntax elements that describe the actions
     to be performed.

“Static Subprogram”
     A subprogram whose executable object code is part of the same
     executable file as its calling program.  Static subprograms are
     therefore loaded into memory at the same time as their caller.

“Subprogram”
     A program invoked directly by another program in such a manner that
     it may return control back to the other program, directly back to
     the point where the subprogram was invoked.

“Subroutine”
     A subprogram executed from another via a GnuCOBOL ‘CALL’ (*note
     CALL::) statement (or the equivalent in whatever programming
     language that other program was written in).

“Summary Report”
     An RWCS-generated report to which no detail groups are presented.

“User-Defined Function”
     A subprogram written in GnuCOBOL that is executed in a
     syntactically-similar manner to that by which the various built-in
     intrinsic functions are executed.

“User-Defined Names”
     Either the name of an identifier or a procedure in the program.
     GnuCOBOL limits user-defined names to a maximum of 31 characters
     taken from the set of numeric digits, upper- and lower-case
     letters, hyphens and underscores.  A user-defined name may neither
     begin nor end with a hyphen or underscore.  User-defined names used
     as file names may additionally not begin with a digit although -
     unlike many other programming languages - user-defined names used
     as identifiers or procedure names may.  A vendor specific feature
     has been introduced into gnucobol to allow extending the 31
     character limit to 63 when using -std=default.  It may be added
     also to other conf files if required.  NOTE: This feature will
     prevent you ever migrating source code compiled for gnucobol to
     work with other Cobol compilers (unless they also have such a
     feature) without a lot of changes to all such names.

“Verb”
     The first reserved word of a COBOL statement.

“Zero-Delimited Alphanumeric Literals”
     An alphanumeric literal prefixed with an upper- or lower-case ‘Z’
     character -- for example, ‘Z'ABC'’.  These literals are one
     character longer than the value within apostrophes or quotes would
     make them appear.  The extra character (the last character) will be
     a null character (comprised entirely of zero bits).  These literals
     are ideal when defining or assigning values to alphanumeric data
     items that will be passed as arguments to a C subroutine.  *Note
     Alphanumeric Literals::.


File: gnucobpg.info,  Node: Reserved Word List,  Next: Grouped Word Lists by feature and function,  Prev: Glossary of Terms,  Up: Top

Appendix B Reserved Word List
*****************************

See Appendix C for the complete lists of ALL reserved words of all
types.


File: gnucobpg.info,  Node: Grouped Word Lists by feature and function,  Next: List of Intrinsic Functions,  Prev: Reserved Word List,  Up: Top

Appendix C Grouped Word Lists by feature and function
*****************************************************

The following is the complete list of ALL reserved words in the 11th
January 2025 at 17:40 GMT. build of GnuCOBOL 3.2 - Final.  Even though
the functionality behind some of these words may not be implemented in
this version of GnuCOBOL, none may be used as any user-defined name.
This list includes ALL reserved, intrinsics, mnemonics and system and
shows some 1100+ words in total.  In addition there are the arithmetic
and relational symbols as well as extra words that can be added and
existing words removed by the use of the -std file content see the
specific one used for each sub-set.

   The following list of reserved words was extracted from ‘cobc
--list-reserved’ and shows the reserved words, an implementation

   *Please notice:* This list is highly specific to the option
‘-std=DIALECT’ and reserved word options (‘-freserved=WORD’,
‘-fno-reserved=WORD’) in effect.  You can get the list for a given
DIALECT by calling ‘cobc -std=DIALECT --list-reserved’.

C.1 Common reserved words
=========================

Note: (C/S) stands for Context-sensitive words (words reserved only
depending on a specific contexts)

Reserved word                 Implemented    Aliases
---------------------------------------------------------------------------
‘3-D’                         Yes (C/S)
‘ABSENT’                      Yes
‘ACCEPT’                      Yes
‘ACCESS’                      Yes
‘ACTION’                      Yes (C/S)
‘ACTIVATING’                  No (C/S)
‘ACTIVE-CLASS’                No
‘ACTIVE-X’                    Yes (C/S)
‘ACTUAL’                      Yes (C/S)
‘ADD’                         Yes
‘ADDRESS’                     Yes
‘ADJUSTABLE-COLUMNS’          Yes (C/S)
‘ADVANCING’                   Yes
‘AFTER’                       Yes
‘ALIGNED’                     No
‘ALIGNMENT’                   Yes (C/S)
‘ALL’                         Yes
‘ALLOCATE’                    Yes
‘ALLOWING’                    Yes (C/S)
‘ALPHABET’                    Yes
‘ALPHABETIC’                  Yes
‘ALPHABETIC-LOWER’            Yes
‘ALPHABETIC-UPPER’            Yes
‘ALPHANUMERIC’                Yes
‘ALPHANUMERIC-EDITED’         Yes
‘ALSO’                        Yes
‘ALTER’                       Yes
‘ALTERNATE’                   Yes
‘AND’                         Yes
‘ANUM’                        No (C/S)
‘ANY’                         Yes
‘ANYCASE’                     No
‘APPLY’                       Yes (C/S)
‘ARE’                         Yes
‘AREA’                        Yes            ‘AREAS’
‘AREAS’                       Yes            ‘AREA’
‘ARGUMENT-NUMBER’             Yes
‘ARGUMENT-VALUE’              Yes
‘ARITHMETIC’                  Yes (C/S)
‘AS’                          Yes
‘ASCENDING’                   Yes
‘ASCII’                       Yes (C/S)
‘ASSIGN’                      Yes
‘AT’                          Yes
‘ATTRIBUTE’                   Yes (C/S)
‘ATTRIBUTES’                  Yes (C/S)
‘AUTHOR’                      Yes (C/S)
‘AUTO’                        Yes (C/S)      ‘AUTO-SKIP, AUTOTERMINATE’
‘AUTO-DECIMAL’                Yes (C/S)
‘AUTO-SKIP’                   Yes            ‘AUTO, AUTOTERMINATE’
‘AUTO-SPIN’                   Yes (C/S)
‘AUTOMATIC’                   Yes
‘AUTOTERMINATE’               Yes            ‘AUTO, AUTO-SKIP’
‘AWAY-FROM-ZERO’              Yes (C/S)
‘B-AND’                       Yes
‘B-NOT’                       Yes
‘B-OR’                        Yes
‘B-SHIFT-L’                   Yes
‘B-SHIFT-LC’                  Yes
‘B-SHIFT-R’                   Yes
‘B-SHIFT-RC’                  Yes
‘B-XOR’                       Yes
‘BACKGROUND-COLOR’            Yes (C/S)      ‘BACKGROUND-COLOUR’
‘BACKGROUND-COLOUR’           Yes            ‘BACKGROUND-COLOR’
‘BACKGROUND-HIGH’             Yes
‘BACKGROUND-LOW’              Yes
‘BACKGROUND-STANDARD’         Yes
‘BACKWARD’                    Yes (C/S)
‘BAR’                         Yes (C/S)
‘BASED’                       Yes
‘BEEP’                        Yes            ‘BELL’
‘BEFORE’                      Yes
‘BELL’                        Yes (C/S)      ‘BEEP’
‘BINARY’                      Yes
‘BINARY-C-LONG’               Yes
‘BINARY-CHAR’                 Yes
‘BINARY-DOUBLE’               Yes            ‘BINARY-LONG-LONG’
‘BINARY-INT’                  Yes            ‘BINARY-LONG’
‘BINARY-LONG’                 Yes            ‘BINARY-INT’
‘BINARY-LONG-LONG’            Yes            ‘BINARY-DOUBLE’
‘BINARY-SEQUENTIAL’           Yes (C/S)
‘BINARY-SHORT’                Yes
‘BIT’                         Yes
‘BITMAP’                      Yes (C/S)
‘BITMAP-END’                  Yes (C/S)
‘BITMAP-HANDLE’               Yes (C/S)
‘BITMAP-NUMBER’               Yes (C/S)
‘BITMAP-START’                Yes (C/S)
‘BITMAP-TIMER’                Yes (C/S)
‘BITMAP-TRAILING’             Yes (C/S)
‘BITMAP-TRANSPARENT-COLOR’    Yes (C/S)
‘BITMAP-WIDTH’                Yes (C/S)
‘BLANK’                       Yes
‘BLINK’                       Yes (C/S)
‘BLOCK’                       Yes
‘BOOLEAN’                     No
‘BOTTOM’                      Yes
‘BOX’                         Yes (C/S)
‘BOXED’                       Yes (C/S)
‘BULK-ADDITION’               Yes (C/S)
‘BUSY’                        Yes (C/S)
‘BUTTONS’                     Yes (C/S)
‘BY’                          Yes
‘BYTE-LENGTH’                 Yes (C/S)
‘C’                           Yes (C/S)
‘CALENDAR-FONT’               Yes (C/S)
‘CALL’                        Yes
‘CANCEL’                      Yes
‘CANCEL-BUTTON’               Yes (C/S)
‘CAPACITY’                    Yes (C/S)
‘CARD-PUNCH’                  Yes (C/S)
‘CARD-READER’                 Yes (C/S)
‘CASSETTE’                    Yes (C/S)
‘CCOL’                        Yes (C/S)
‘CD’                          Yes
‘CELL’                        Yes (C/S)      ‘CELLS’
‘CELL-COLOR’                  Yes (C/S)
‘CELL-DATA’                   Yes (C/S)
‘CELL-FONT’                   Yes (C/S)
‘CELL-PROTECTION’             Yes (C/S)
‘CELLS’                       Yes            ‘CELL’
‘CENTER’                      Yes (C/S)
‘CENTERED’                    Yes (C/S)
‘CENTERED-HEADINGS’           Yes (C/S)
‘CENTURY-DATE’                Yes (C/S)
‘CF’                          Yes
‘CH’                          Yes
‘CHAIN’                       No
‘CHAINING’                    Yes
‘CHANGED’                     Yes (C/S)
‘CHARACTER’                   Yes
‘CHARACTERS’                  Yes
‘CHECK-BOX’                   Yes (C/S)
‘CLASS’                       Yes
‘CLASS-ID’                    No
‘CLASSIFICATION’              Yes (C/S)
‘CLEAR-SELECTION’             Yes (C/S)
‘CLINE’                       Yes (C/S)
‘CLINES’                      Yes (C/S)
‘CLOSE’                       Yes
‘COBOL’                       Yes (C/S)
‘CODE’                        Yes
‘CODE-SET’                    Yes
‘COL’                         Yes
‘COLLATING’                   Yes
‘COLOR’                       Yes
‘COLORS’                      Yes (C/S)      ‘COLOURS’
‘COLOURS’                     Yes            ‘COLORS’
‘COLS’                        Yes
‘COLUMN’                      Yes
‘COLUMN-COLOR’                Yes (C/S)
‘COLUMN-DIVIDERS’             Yes (C/S)
‘COLUMN-FONT’                 Yes (C/S)
‘COLUMN-HEADINGS’             Yes (C/S)
‘COLUMN-PROTECTION’           Yes (C/S)
‘COLUMNS’                     Yes
‘COMBO-BOX’                   Yes (C/S)
‘COMMA’                       Yes
‘COMMAND-LINE’                Yes
‘COMMIT’                      Yes
‘COMMON’                      Yes
‘COMMUNICATION’               Yes
‘COMP’                        Yes            ‘COMPUTATIONAL’
‘COMP-0’                      Yes            ‘COMPUTATIONAL-0’
‘COMP-1’                      Yes            ‘COMPUTATIONAL-1’
‘COMP-10’                     Yes            ‘COMP-10, DOUBLE,
                                             FLOAT-LONG’
‘COMP-15’                     Yes            ‘COMP-15, DOUBLE,
                                             FLOAT-LONG’
‘COMP-2’                      Yes            ‘COMPUTATIONAL-2’
‘COMP-3’                      Yes            ‘COMPUTATIONAL-3’
‘COMP-4’                      Yes            ‘COMPUTATIONAL-4’
‘COMP-5’                      Yes            ‘COMPUTATIONAL-5’
‘COMP-6’                      Yes            ‘COMPUTATIONAL-6’
‘COMP-9’                      Yes            ‘FLOAT, FLOAT-SHORT’
‘COMP-N’                      Yes            ‘COMPUTATIONAL-N’
‘COMP-X’                      Yes            ‘COMPUTATIONAL-X’
‘COMPUTATIONAL’               Yes            ‘COMP’
‘COMPUTATIONAL-0’             Yes            ‘COMP-0’
‘COMPUTATIONAL-1’             Yes            ‘COMP-1’
‘COMPUTATIONAL-2’             Yes            ‘COMP-2’
‘COMPUTATIONAL-3’             Yes            ‘COMP-3’
‘COMPUTATIONAL-4’             Yes            ‘COMP-4’
‘COMPUTATIONAL-5’             Yes            ‘COMP-5’
‘COMPUTATIONAL-6’             Yes            ‘COMP-6’
‘COMPUTATIONAL-N’             Yes            ‘COMP-N’
‘COMPUTATIONAL-X’             Yes            ‘COMP-X’
‘COMPUTE’                     Yes
‘CONDITION’                   Yes
‘CONFIGURATION’               Yes
‘CONSTANT’                    Yes
‘CONTAINS’                    Yes
‘CONTENT’                     Yes
‘CONTINUE’                    Yes
‘CONTROL’                     Yes
‘CONTROLS’                    Yes
‘CONVERSION’                  Yes (C/S)
‘CONVERTING’                  Yes
‘COPY’                        Yes
‘COPY-SELECTION’              Yes (C/S)
‘CORE-INDEX’                  Yes (C/S)
‘CORR’                        Yes            ‘CORRESPONDING’
‘CORRESPONDING’               Yes            ‘CORR’
‘COUNT’                       Yes
‘CRT’                         Yes
‘CRT-UNDER’                   Yes
‘CSIZE’                       Yes (C/S)
‘CURRENCY’                    Yes
‘CURRENT’                     No
‘CURSOR’                      Yes
‘CURSOR-COL’                  Yes (C/S)
‘CURSOR-COLOR’                Yes (C/S)
‘CURSOR-FRAME-WIDTH’          Yes (C/S)
‘CURSOR-ROW’                  Yes (C/S)
‘CURSOR-X’                    Yes (C/S)
‘CURSOR-Y’                    Yes (C/S)
‘CUSTOM-PRINT-TEMPLATE’       Yes (C/S)
‘CYCLE’                       Yes (C/S)
‘CYL-INDEX’                   Yes (C/S)
‘CYL-OVERFLOW’                Yes (C/S)
‘DASHED’                      Yes (C/S)
‘DATA’                        Yes
‘DATA-COLUMNS’                Yes (C/S)
‘DATA-POINTER’                No
‘DATA-TYPES’                  Yes (C/S)
‘DATE’                        Yes
‘DATE-COMPILED’               Yes (C/S)
‘DATE-ENTRY’                  Yes (C/S)
‘DATE-MODIFIED’               Yes (C/S)
‘DATE-WRITTEN’                Yes (C/S)
‘DAY’                         Yes
‘DAY-OF-WEEK’                 Yes
‘DE’                          Yes
‘DEBUGGING’                   Yes
‘DECIMAL-POINT’               Yes
‘DECLARATIVES’                Yes
‘DEFAULT’                     Yes
‘DEFAULT-BUTTON’              Yes (C/S)
‘DEFAULT-FONT’                Yes
‘DELETE’                      Yes
‘DELIMITED’                   Yes
‘DELIMITER’                   Yes
‘DEPENDING’                   Yes
‘DESCENDING’                  Yes
‘DESTINATION’                 Yes
‘DESTROY’                     Yes
‘DETAIL’                      Yes
‘DISABLE’                     Yes
‘DISC’                        Yes (C/S)
‘DISK’                        Yes (C/S)
‘DISP’                        Yes (C/S)
‘DISPLAY’                     Yes
‘DISPLAY-COLUMNS’             Yes (C/S)
‘DISPLAY-FORMAT’              Yes (C/S)
‘DIVIDE’                      Yes
‘DIVIDER-COLOR’               Yes (C/S)
‘DIVIDERS’                    Yes (C/S)
‘DIVISION’                    Yes
‘DOTDASH’                     Yes (C/S)
‘DOTTED’                      Yes (C/S)
‘DOUBLE’                      Yes            ‘FLOAT-LONG’
‘DOWN’                        Yes
‘DRAG-COLOR’                  Yes (C/S)
‘DROP-DOWN’                   Yes (C/S)
‘DROP-LIST’                   Yes (C/S)
‘DUPLICATES’                  Yes
‘DYNAMIC’                     Yes
‘EBCDIC’                      Yes (C/S)
‘EC’                          Yes
‘ECHO’                        Yes
‘EDITING’                     No
‘EGI’                         Yes
‘ELEMENT’                     Yes (C/S)
‘ELSE’                        Yes
‘EMI’                         Yes
‘EMPTY-CHECK’                 Yes            ‘REQUIRED’
‘ENABLE’                      Yes
‘ENCODING’                    Yes (C/S)
‘ENCRYPTION’                  Yes (C/S)
‘END’                         Yes
‘END-ACCEPT’                  Yes
‘END-ADD’                     Yes
‘END-CALL’                    Yes
‘END-CHAIN’                   No
‘END-COLOR’                   Yes (C/S)
‘END-COMPUTE’                 Yes
‘END-DELETE’                  Yes
‘END-DISPLAY’                 Yes
‘END-DIVIDE’                  Yes
‘END-EVALUATE’                Yes
‘END-IF’                      Yes
‘END-JSON’                    Yes
‘END-MODIFY’                  Yes (C/S)
‘END-MULTIPLY’                Yes
‘END-OF-PAGE’                 Yes            ‘EOP’
‘END-PERFORM’                 Yes
‘END-READ’                    Yes
‘END-RECEIVE’                 Yes
‘END-RETURN’                  Yes
‘END-REWRITE’                 Yes
‘END-SEARCH’                  Yes
‘END-SEND’                    Yes
‘END-START’                   Yes
‘END-STRING’                  Yes
‘END-SUBTRACT’                Yes
‘END-UNSTRING’                Yes
‘END-WRITE’                   Yes
‘END-XML’                     Yes
‘ENGRAVED’                    Yes (C/S)
‘ENSURE-VISIBLE’              Yes (C/S)
‘ENTRY’                       Yes
‘ENTRY-CONVENTION’            Yes (C/S)
‘ENTRY-FIELD’                 Yes (C/S)
‘ENTRY-REASON’                Yes (C/S)
‘ENVIRONMENT’                 Yes
‘ENVIRONMENT-NAME’            Yes
‘ENVIRONMENT-VALUE’           Yes
‘EO’                          No
‘EOL’                         Yes (C/S)
‘EOP’                         Yes            ‘END-OF-PAGE’
‘EOS’                         Yes (C/S)
‘EQUAL’                       Yes            ‘EQUALS’
‘EQUALS’                      Yes            ‘EQUAL’
‘ERASE’                       Yes (C/S)
‘ERROR’                       Yes
‘ESCAPE’                      Yes
‘ESCAPE-BUTTON’               Yes (C/S)
‘ESI’                         Yes
‘EVALUATE’                    Yes
‘EVENT’                       Yes
‘EVENT-LIST’                  Yes (C/S)
‘EVERY’                       Yes (C/S)
‘EXCEPTION’                   Yes
‘EXCEPTION-OBJECT’            No
‘EXCEPTION-VALUE’             Yes (C/S)
‘EXCLUSIVE’                   Yes
‘EXCLUSIVE-OR’                No
‘EXHIBIT’                     Yes
‘EXIT’                        Yes
‘EXPAND’                      Yes (C/S)
‘EXPANDS’                     No (C/S)
‘EXTEND’                      Yes
‘EXTENDED-SEARCH’             Yes (C/S)
‘EXTERN’                      Yes (C/S)
‘EXTERNAL’                    Yes
‘EXTERNAL-FORM’               Yes
‘F’                           Yes (C/S)
‘FACTORY’                     No
‘FALSE’                       Yes
‘FD’                          Yes
‘FH--FCD’                     Yes (C/S)
‘FH--KEYDEF’                  Yes (C/S)
‘FILE’                        Yes
‘FILE-CONTROL’                Yes
‘FILE-ID’                     Yes
‘FILE-LIMIT’                  Yes (C/S)
‘FILE-LIMITS’                 Yes (C/S)
‘FILE-NAME’                   Yes (C/S)
‘FILE-POS’                    Yes (C/S)
‘FILL-COLOR’                  Yes (C/S)
‘FILL-COLOR2’                 Yes (C/S)
‘FILL-PERCENT’                Yes (C/S)
‘FILLER’                      Yes
‘FINAL’                       Yes
‘FINALLY’                     No
‘FINISH-REASON’               Yes (C/S)
‘FIRST’                       Yes
‘FIXED’                       Yes
‘FIXED-FONT’                  Yes
‘FIXED-WIDTH’                 Yes (C/S)
‘FLAT’                        Yes (C/S)
‘FLAT-BUTTONS’                Yes (C/S)
‘FLOAT’                       Yes            ‘FLOAT-SHORT’
‘FLOAT-BINARY-128’            No
‘FLOAT-BINARY-32’             No
‘FLOAT-BINARY-64’             No
‘FLOAT-DECIMAL-16’            Yes
‘FLOAT-DECIMAL-34’            Yes
‘FLOAT-EXTENDED’              No
‘FLOAT-INFINITY’              No
‘FLOAT-LONG’                  Yes            ‘DOUBLE’
‘FLOAT-NOT-A-NUMBER’          No (C/S)
‘FLOAT-SHORT’                 Yes            ‘FLOAT’
‘FLOATING’                    Yes
‘FONT’                        Yes
‘FOOTING’                     Yes
‘FOR’                         Yes
‘FOREGROUND-COLOR’            Yes (C/S)      ‘FOREGROUND-COLOUR’
‘FOREGROUND-COLOUR’           Yes            ‘FOREGROUND-COLOR’
‘FOREVER’                     Yes (C/S)
‘FORMAT’                      No
‘FRAME’                       Yes (C/S)
‘FRAMED’                      Yes (C/S)
‘FREE’                        Yes
‘FROM’                        Yes
‘FULL’                        Yes (C/S)      ‘LENGTH-CHECK’
‘FULL-HEIGHT’                 Yes (C/S)
‘FUNCTION’                    Yes
‘FUNCTION-ID’                 Yes
‘FUNCTION-POINTER’            No
‘GENERATE’                    Yes
‘GET’                         No
‘GIVING’                      Yes
‘GLOBAL’                      Yes
‘GO’                          Yes
‘GO-BACK’                     Yes (C/S)
‘GO-FORWARD’                  Yes (C/S)
‘GO-HOME’                     Yes (C/S)
‘GO-SEARCH’                   Yes (C/S)
‘GOBACK’                      Yes
‘GRAPHICAL’                   Yes (C/S)
‘GREATER’                     Yes
‘GRID’                        Yes (C/S)
‘GROUP’                       Yes
‘GROUP-USAGE’                 No
‘GROUP-VALUE’                 Yes (C/S)
‘HANDLE’                      Yes
‘HAS-CHILDREN’                Yes (C/S)
‘HEADING’                     Yes
‘HEADING-COLOR’               Yes (C/S)
‘HEADING-DIVIDER-COLOR’       Yes (C/S)
‘HEADING-FONT’                Yes (C/S)
‘HEAVY’                       Yes (C/S)
‘HEIGHT-IN-CELLS’             Yes (C/S)
‘HEX’                         No (C/S)
‘HIDDEN-DATA’                 Yes (C/S)
‘HIGH-COLOR’                  Yes (C/S)
‘HIGH-VALUE’                  Yes            ‘HIGH-VALUES’
‘HIGH-VALUES’                 Yes            ‘HIGH-VALUE’
‘HIGHLIGHT’                   Yes (C/S)
‘HOT-TRACK’                   Yes (C/S)
‘HSCROLL’                     Yes (C/S)
‘HSCROLL-POS’                 Yes (C/S)
‘I-O’                         Yes
‘I-O-CONTROL’                 Yes
‘ICON’                        Yes (C/S)
‘ID’                          Yes
‘IDENTIFICATION’              Yes
‘IDENTIFIED’                  Yes
‘IF’                          Yes
‘IGNORE’                      Yes
‘IGNORING’                    Yes (C/S)
‘IMPLEMENTS’                  No (C/S)
‘IN’                          Yes
‘INDEPENDENT’                 Yes (C/S)
‘INDEX’                       Yes
‘INDEXED’                     Yes
‘INDICATE’                    Yes
‘INHERITS’                    No
‘INITIAL’                     Yes
‘INITIALISE’                  Yes            ‘INITIALIZE’
‘INITIALISED’                 Yes            ‘INITIALIZED’
‘INITIALIZE’                  Yes            ‘INITIALISE’
‘INITIALIZED’                 Yes (C/S)      ‘INITIALISED’
‘INITIATE’                    Yes
‘INPUT’                       Yes
‘INPUT-OUTPUT’                Yes
‘INQUIRE’                     Yes
‘INSERT-ROWS’                 Yes (C/S)
‘INSERTION-INDEX’             Yes (C/S)
‘INSPECT’                     Yes
‘INSTALLATION’                Yes (C/S)
‘INTERFACE’                   No
‘INTERFACE-ID’                No
‘INTERMEDIATE’                Yes (C/S)
‘INTO’                        Yes
‘INTRINSIC’                   Yes (C/S)
‘INVALID’                     Yes
‘INVOKE’                      No
‘IS’                          Yes
‘ITEM’                        Yes (C/S)
‘ITEM-TEXT’                   Yes (C/S)
‘ITEM-TO-ADD’                 Yes (C/S)
‘ITEM-TO-DELETE’              Yes (C/S)
‘ITEM-TO-EMPTY’               Yes (C/S)
‘ITEM-VALUE’                  Yes (C/S)
‘JSON’                        Yes
‘JUST’                        Yes            ‘JUSTIFIED’
‘JUSTIFIED’                   Yes            ‘JUST’
‘KEPT’                        Yes
‘KEY’                         Yes
‘KEYBOARD’                    Yes (C/S)
‘LABEL’                       Yes
‘LABEL-OFFSET’                Yes (C/S)
‘LARGE-FONT’                  Yes
‘LARGE-OFFSET’                Yes (C/S)
‘LAST’                        Yes
‘LAST-ROW’                    Yes (C/S)
‘LAYOUT-DATA’                 Yes (C/S)
‘LAYOUT-MANAGER’              Yes
‘LC_ALL’                      No (C/S)
‘LC_COLLATE’                  No (C/S)
‘LC_CTYPE’                    No (C/S)
‘LC_MESSAGES’                 No (C/S)
‘LC_MONETARY’                 No (C/S)
‘LC_NUMERIC’                  No (C/S)
‘LC_TIME’                     No (C/S)
‘LEADING’                     Yes
‘LEADING-SHIFT’               Yes (C/S)
‘LEAVE’                       Yes (C/S)
‘LEFT’                        Yes
‘LEFT-JUSTIFY’                No
‘LEFT-TEXT’                   Yes (C/S)
‘LEFTLINE’                    Yes
‘LENGTH’                      Yes
‘LENGTH-CHECK’                Yes            ‘FULL’
‘LESS’                        Yes
‘LIKE’                        Yes
‘LIMIT’                       Yes
‘LIMITS’                      Yes
‘LINAGE’                      Yes
‘LINAGE-COUNTER’              Yes
‘LINE’                        Yes
‘LINE-COUNTER’                Yes
‘LINE-SEQUENTIAL’             Yes (C/S)
‘LINES’                       Yes
‘LINES-AT-ROOT’               Yes (C/S)
‘LINKAGE’                     Yes
‘LIST-BOX’                    Yes (C/S)
‘LM-RESIZE’                   Yes
‘LOC’                         Yes (C/S)
‘LOCAL-STORAGE’               Yes
‘LOCALE’                      Yes
‘LOCATION’                    No
‘LOCK’                        Yes
‘LOCK-HOLDING’                Yes (C/S)
‘LONG-DATE’                   Yes (C/S)
‘LOW-COLOR’                   Yes (C/S)
‘LOW-VALUE’                   Yes            ‘LOW-VALUES’
‘LOW-VALUES’                  Yes            ‘LOW-VALUE’
‘LOWER’                       Yes (C/S)
‘LOWERED’                     Yes (C/S)
‘LOWLIGHT’                    Yes (C/S)
‘MAGNETIC-TAPE’               Yes (C/S)
‘MANUAL’                      Yes
‘MASS-UPDATE’                 Yes (C/S)
‘MASTER-INDEX’                Yes (C/S)
‘MAX-LINES’                   Yes (C/S)
‘MAX-PROGRESS’                Yes (C/S)
‘MAX-TEXT’                    Yes (C/S)
‘MAX-VAL’                     Yes (C/S)
‘MEDIUM-FONT’                 Yes
‘MEMORY’                      Yes (C/S)
‘MENU’                        Yes
‘MERGE’                       Yes
‘MESSAGE’                     Yes
‘MESSAGE-TAG’                 No
‘METHOD’                      No
‘METHOD-ID’                   No
‘MIN-VAL’                     Yes (C/S)
‘MINUS’                       Yes
‘MODE’                        Yes
‘MODIFY’                      Yes
‘MODULES’                     Yes (C/S)
‘MOVE’                        Yes
‘MULTILINE’                   Yes (C/S)
‘MULTIPLE’                    Yes
‘MULTIPLY’                    Yes
‘NAME’                        Yes (C/S)
‘NAMED’                       Yes (C/S)
‘NAMESPACE’                   Yes (C/S)
‘NAMESPACE-PREFIX’            Yes (C/S)
‘NAT’                         No
‘NATIONAL’                    Yes
‘NATIONAL-EDITED’             Yes
‘NATIVE’                      Yes
‘NAVIGATE-URL’                Yes (C/S)
‘NEAREST-AWAY-FROM-ZERO’      Yes (C/S)
‘NEAREST-EVEN’                Yes (C/S)
‘NEAREST-TOWARD-ZERO’         Yes (C/S)
‘NEGATIVE’                    Yes
‘NESTED’                      Yes
‘NEW’                         Yes
‘NEXT’                        Yes
‘NEXT-ITEM’                   Yes (C/S)
‘NO’                          Yes
‘NO-AUTO-DEFAULT’             Yes (C/S)
‘NO-AUTOSEL’                  Yes (C/S)
‘NO-BOX’                      Yes (C/S)
‘NO-DIVIDERS’                 Yes (C/S)
‘NO-ECHO’                     Yes
‘NO-F4’                       Yes (C/S)
‘NO-FOCUS’                    Yes (C/S)
‘NO-GROUP-TAB’                Yes (C/S)
‘NO-KEY-LETTER’               Yes (C/S)
‘NO-SEARCH’                   Yes (C/S)
‘NO-UPDOWN’                   Yes (C/S)
‘NOMINAL’                     Yes (C/S)
‘NONE’                        No (C/S)
‘NONNUMERIC’                  Yes (C/S)
‘NORMAL’                      Yes (C/S)
‘NOT’                         Yes
‘NOTAB’                       Yes (C/S)
‘NOTHING’                     Yes
‘NOTIFY’                      Yes (C/S)
‘NOTIFY-CHANGE’               Yes (C/S)
‘NOTIFY-DBLCLICK’             Yes (C/S)
‘NOTIFY-SELCHANGE’            Yes (C/S)
‘NULL’                        Yes            ‘NULLS’
‘NULLS’                       Yes            ‘NULL’
‘NUM-COL-HEADINGS’            Yes (C/S)
‘NUM-ROWS’                    Yes (C/S)
‘NUMBER’                      Yes
‘NUMBERS’                     Yes
‘NUMERIC’                     Yes
‘NUMERIC-EDITED’              Yes
‘OBJECT’                      Yes
‘OBJECT-COMPUTER’             Yes
‘OBJECT-REFERENCE’            No
‘OCCURS’                      Yes
‘OF’                          Yes
‘OFF’                         Yes
‘OK-BUTTON’                   Yes (C/S)
‘OMITTED’                     Yes
‘ON’                          Yes
‘ONLY’                        Yes
‘OPEN’                        Yes
‘OPTIONAL’                    Yes
‘OPTIONS’                     Yes
‘OR’                          Yes
‘ORDER’                       Yes
‘ORGANISATION’                Yes            ‘ORGANIZATION’
‘ORGANIZATION’                Yes            ‘ORGANISATION’
‘OTHER’                       Yes
‘OTHERS’                      Yes (C/S)
‘OUTPUT’                      Yes
‘OVERFLOW’                    Yes
‘OVERLAP-LEFT’                Yes (C/S)      ‘OVERLAP-TOP’
‘OVERLAP-TOP’                 Yes (C/S)      ‘OVERLAP-LEFT’
‘OVERLINE’                    Yes
‘OVERRIDE’                    No
‘PACKED-DECIMAL’              Yes
‘PADDING’                     Yes
‘PAGE’                        Yes
‘PAGE-COUNTER’                Yes
‘PAGE-SETUP’                  Yes (C/S)
‘PAGED’                       Yes (C/S)
‘PARAGRAPH’                   Yes (C/S)
‘PARENT’                      Yes (C/S)
‘PARSE’                       Yes (C/S)
‘PASCAL’                      Yes (C/S)
‘PASSWORD’                    Yes (C/S)
‘PERFORM’                     Yes
‘PERMANENT’                   Yes (C/S)
‘PF’                          Yes
‘PH’                          Yes
‘PHYSICAL’                    Yes
‘PIC’                         Yes            ‘PICTURE’
‘PICTURE’                     Yes            ‘PIC’
‘PIXEL’                       Yes (C/S)      ‘PIXELS’
‘PIXELS’                      Yes            ‘PIXEL’
‘PLACEMENT’                   Yes (C/S)
‘PLUS’                        Yes
‘POINTER’                     Yes
‘POP-UP’                      Yes (C/S)
‘POS’                         Yes
‘POSITION’                    Yes
‘POSITION-SHIFT’              Yes (C/S)
‘POSITIVE’                    Yes
‘PREFIXED’                    No (C/S)
‘PRESENT’                     Yes
‘PREVIOUS’                    Yes (C/S)
‘PRINT’                       Yes (C/S)
‘PRINT-NO-PROMPT’             Yes (C/S)
‘PRINT-PREVIEW’               Yes (C/S)
‘PRINTER’                     Yes (C/S)
‘PRINTER-1’                   Yes (C/S)
‘PRINTING’                    Yes
‘PRIORITY’                    Yes
‘PROCEDURE’                   Yes
‘PROCEDURE-POINTER’           Yes            ‘PROGRAM-POINTER’
‘PROCEDURES’                  Yes
‘PROCEED’                     Yes
‘PROCESSING’                  Yes (C/S)
‘PROGRAM’                     Yes
‘PROGRAM-ID’                  Yes
‘PROGRAM-POINTER’             Yes            ‘PROCEDURE-POINTER’
‘PROGRESS’                    Yes (C/S)
‘PROHIBITED’                  Yes (C/S)
‘PROMPT’                      Yes
‘PROPERTIES’                  Yes (C/S)
‘PROPERTY’                    Yes
‘PROTECTED’                   Yes (C/S)
‘PROTOTYPE’                   No
‘PURGE’                       Yes
‘PUSH-BUTTON’                 Yes (C/S)
‘QUERY-INDEX’                 Yes (C/S)
‘QUEUE’                       Yes
‘QUOTE’                       Yes            ‘QUOTES’
‘QUOTES’                      Yes            ‘QUOTE’
‘RADIO-BUTTON’                Yes (C/S)
‘RAISE’                       Yes
‘RAISED’                      Yes (C/S)
‘RAISING’                     No
‘RANDOM’                      Yes
‘RD’                          Yes
‘READ’                        Yes
‘READ-ONLY’                   Yes (C/S)
‘READERS’                     Yes (C/S)
‘RECEIVE’                     Yes
‘RECEIVED’                    Yes
‘RECORD’                      Yes
‘RECORD-DATA’                 Yes (C/S)
‘RECORD-OVERFLOW’             Yes (C/S)
‘RECORD-TO-ADD’               Yes (C/S)
‘RECORD-TO-DELETE’            Yes (C/S)
‘RECORDING’                   Yes
‘RECORDS’                     Yes
‘RECURSIVE’                   Yes (C/S)
‘REDEFINES’                   Yes
‘REEL’                        Yes
‘REFERENCE’                   Yes
‘REFERENCES’                  Yes
‘REFRESH’                     Yes (C/S)
‘REGION-COLOR’                Yes (C/S)
‘RELATION’                    No (C/S)
‘RELATIVE’                    Yes
‘RELEASE’                     Yes
‘REMAINDER’                   Yes
‘REMARKS’                     Yes (C/S)
‘REMOVAL’                     Yes
‘RENAMES’                     Yes
‘REORG-CRITERIA’              Yes (C/S)
‘REPEATED’                    Yes
‘REPLACE’                     Yes
‘REPLACING’                   Yes
‘REPORT’                      Yes
‘REPORTING’                   Yes
‘REPORTS’                     Yes
‘REPOSITORY’                  Yes
‘REQUIRED’                    Yes (C/S)      ‘EMPTY-CHECK’
‘REREAD’                      Yes (C/S)
‘RERUN’                       Yes (C/S)
‘RESERVE’                     Yes
‘RESET’                       Yes
‘RESET-GRID’                  Yes (C/S)
‘RESET-LIST’                  Yes (C/S)
‘RESET-TABS’                  Yes (C/S)
‘RESUME’                      No
‘RETRY’                       Yes
‘RETURN’                      Yes
‘RETURNING’                   Yes
‘REVERSE’                     Yes
‘REVERSE-VIDEO’               Yes (C/S)
‘REVERSED’                    Yes
‘REWIND’                      Yes
‘REWRITE’                     Yes
‘RF’                          Yes
‘RH’                          Yes
‘RIGHT’                       Yes
‘RIGHT-ALIGN’                 Yes (C/S)
‘RIGHT-JUSTIFY’               No
‘RIMMED’                      Yes (C/S)
‘ROLLBACK’                    Yes
‘ROUNDED’                     Yes
‘ROUNDING’                    Yes (C/S)
‘ROW-COLOR’                   Yes (C/S)
‘ROW-COLOR-PATTERN’           Yes (C/S)
‘ROW-DIVIDERS’                Yes (C/S)
‘ROW-FONT’                    Yes (C/S)
‘ROW-HEADINGS’                Yes (C/S)
‘ROW-PROTECTION’              Yes (C/S)
‘RUN’                         Yes
‘S’                           Yes (C/S)
‘SAME’                        Yes
‘SAVE-AS’                     Yes (C/S)
‘SAVE-AS-NO-PROMPT’           Yes (C/S)
‘SCREEN’                      Yes
‘SCROLL’                      Yes (C/S)
‘SCROLL-BAR’                  Yes (C/S)
‘SD’                          Yes
‘SEARCH’                      Yes
‘SEARCH-OPTIONS’              Yes (C/S)
‘SEARCH-TEXT’                 Yes (C/S)
‘SECONDS’                     Yes (C/S)
‘SECTION’                     Yes
‘SECURE’                      Yes (C/S)
‘SECURITY’                    Yes (C/S)
‘SEGMENT’                     Yes
‘SEGMENT-LIMIT’               Yes
‘SELECT’                      Yes
‘SELECT-ALL’                  Yes (C/S)
‘SELECTION-INDEX’             Yes (C/S)
‘SELECTION-TEXT’              Yes (C/S)
‘SELF’                        No
‘SELF-ACT’                    Yes (C/S)
‘SEND’                        Yes
‘SENTENCE’                    Yes
‘SEPARATE’                    Yes
‘SEPARATION’                  Yes (C/S)
‘SEQUENCE’                    Yes
‘SEQUENTIAL’                  Yes
‘SET’                         Yes
‘SHADING’                     Yes (C/S)
‘SHADOW’                      Yes (C/S)
‘SHARING’                     Yes
‘SHORT-DATE’                  Yes (C/S)
‘SHOW-LINES’                  Yes (C/S)
‘SHOW-NONE’                   Yes (C/S)
‘SHOW-SEL-ALWAYS’             Yes (C/S)
‘SIGN’                        Yes
‘SIGNED’                      Yes
‘SIGNED-INT’                  Yes
‘SIGNED-LONG’                 Yes
‘SIGNED-SHORT’                Yes
‘SIZE’                        Yes
‘SMALL-FONT’                  Yes
‘SORT’                        Yes
‘SORT-MERGE’                  Yes
‘SORT-ORDER’                  Yes (C/S)
‘SOURCE’                      Yes
‘SOURCE-COMPUTER’             Yes
‘SOURCES’                     No
‘SPACE’                       Yes            ‘SPACES’
‘SPACE-FILL’                  No
‘SPACES’                      Yes            ‘SPACE’
‘SPECIAL-NAMES’               Yes
‘SPINNER’                     Yes (C/S)
‘SQUARE’                      Yes (C/S)
‘STACK’                       No (C/S)
‘STANDARD’                    Yes
‘STANDARD-1’                  Yes
‘STANDARD-2’                  Yes
‘STANDARD-BINARY’             Yes (C/S)
‘STANDARD-DECIMAL’            Yes (C/S)
‘START’                       Yes
‘START-X’                     Yes (C/S)
‘START-Y’                     Yes (C/S)
‘STATEMENT’                   No (C/S)
‘STATIC’                      Yes (C/S)
‘STATIC-LIST’                 Yes (C/S)
‘STATUS’                      Yes
‘STATUS-BAR’                  Yes (C/S)
‘STATUS-TEXT’                 Yes (C/S)
‘STDCALL’                     Yes (C/S)
‘STEP’                        Yes (C/S)
‘STOP’                        Yes
‘STRING’                      Yes
‘STRONG’                      No (C/S)
‘STYLE’                       Yes (C/S)
‘SUB-QUEUE-1’                 Yes
‘SUB-QUEUE-2’                 Yes
‘SUB-QUEUE-3’                 Yes
‘SUBTRACT’                    Yes
‘SUBWINDOW’                   Yes
‘SUM’                         Yes
‘SUPER’                       No
‘SUPPRESS’                    Yes
‘SYMBOL’                      No (C/S)
‘SYMBOLIC’                    Yes
‘SYNC’                        Yes            ‘SYNCHRONISED,
                                             SYNCHRONIZED’
‘SYNCHRONISED’                Yes            ‘SYNC, SYNCHRONIZED’
‘SYNCHRONIZED’                Yes            ‘SYNC, SYNCHRONISED’
‘SYSTEM-DEFAULT’              Yes
‘SYSTEM-INFO’                 Yes (C/S)
‘SYSTEM-OFFSET’               Yes
‘TAB’                         Yes (C/S)
‘TAB-TO-ADD’                  Yes (C/S)
‘TAB-TO-DELETE’               Yes (C/S)
‘TABLE’                       Yes
‘TALLYING’                    Yes
‘TAPE’                        Yes (C/S)
‘TEMPORARY’                   Yes (C/S)
‘TERMINAL-INFO’               Yes (C/S)
‘TERMINATE’                   Yes
‘TERMINATION-VALUE’           Yes (C/S)
‘TEST’                        Yes
‘TEXT’                        Yes
‘THAN’                        Yes
‘THEN’                        Yes
‘THREAD’                      Yes
‘THREADS’                     Yes
‘THROUGH’                     Yes            ‘THRU’
‘THRU’                        Yes            ‘THROUGH’
‘THUMB-POSITION’              Yes (C/S)
‘TILED-HEADINGS’              Yes (C/S)
‘TIME’                        Yes
‘TIME-OUT’                    Yes (C/S)      ‘TIMEOUT’
‘TIMEOUT’                     Yes            ‘TIME-OUT’
‘TIMES’                       Yes
‘TITLE’                       Yes (C/S)
‘TITLE-POSITION’              Yes (C/S)
‘TO’                          Yes
‘TOP’                         Yes
‘TOP-LEVEL’                   No (C/S)
‘TOWARD-GREATER’              Yes (C/S)
‘TOWARD-LESSER’               Yes (C/S)
‘TRACK’                       Yes (C/S)
‘TRACK-AREA’                  Yes (C/S)
‘TRACK-LIMIT’                 Yes (C/S)
‘TRACKS’                      Yes (C/S)
‘TRADITIONAL-FONT’            Yes
‘TRAILING’                    Yes
‘TRAILING-SHIFT’              Yes (C/S)
‘TRAILING-SIGN’               No
‘TRANSFORM’                   Yes
‘TRANSPARENT’                 Yes (C/S)
‘TREE-VIEW’                   Yes (C/S)
‘TRUE’                        Yes
‘TRUNCATION’                  Yes (C/S)
‘TYPE’                        Yes
‘TYPEDEF’                     Yes
‘U’                           Yes (C/S)
‘UCS-4’                       Yes (C/S)
‘UNBOUNDED’                   Yes (C/S)
‘UNDERLINE’                   Yes (C/S)
‘UNFRAMED’                    Yes (C/S)
‘UNIT’                        Yes
‘UNIVERSAL’                   No
‘UNLOCK’                      Yes
‘UNSIGNED’                    Yes
‘UNSIGNED-INT’                Yes
‘UNSIGNED-LONG’               Yes
‘UNSIGNED-SHORT’              Yes
‘UNSORTED’                    Yes (C/S)
‘UNSTRING’                    Yes
‘UNTIL’                       Yes
‘UP’                          Yes
‘UPDATE’                      Yes
‘UPDATERS’                    Yes (C/S)
‘UPON’                        Yes
‘UPPER’                       Yes (C/S)
‘USAGE’                       Yes
‘USE’                         Yes
‘USE-ALT’                     Yes (C/S)
‘USE-RETURN’                  Yes (C/S)
‘USE-TAB’                     Yes (C/S)
‘USER’                        Yes (C/S)
‘USER-DEFAULT’                Yes
‘USING’                       Yes
‘UTF-16’                      Yes (C/S)
‘UTF-8’                       Yes (C/S)
‘V’                           Yes (C/S)
‘VAL-STATUS’                  No
‘VALID’                       No
‘VALIDATE’                    Yes
‘VALIDATE-STATUS’             No
‘VALIDATING’                  Yes (C/S)
‘VALUE’                       Yes            ‘VALUES’
‘VALUE-FORMAT’                Yes (C/S)
‘VALUES’                      Yes            ‘VALUE’
‘VARIABLE’                    Yes (C/S)
‘VARIANT’                     Yes
‘VARYING’                     Yes
‘VERTICAL’                    Yes (C/S)
‘VERY-HEAVY’                  Yes (C/S)
‘VIRTUAL-WIDTH’               Yes (C/S)
‘VOLATILE’                    Yes
‘VPADDING’                    Yes (C/S)
‘VSCROLL’                     Yes (C/S)
‘VSCROLL-BAR’                 Yes (C/S)
‘VSCROLL-POS’                 Yes (C/S)
‘VTOP’                        Yes (C/S)
‘WAIT’                        Yes
‘WEB-BROWSER’                 Yes (C/S)
‘WHEN’                        Yes
‘WIDTH’                       Yes (C/S)
‘WIDTH-IN-CELLS’              Yes (C/S)
‘WINDOW’                      Yes
‘WITH’                        Yes
‘WORDS’                       Yes
‘WORKING-STORAGE’             Yes
‘WRAP’                        Yes (C/S)
‘WRITE’                       Yes
‘WRITE-ONLY’                  Yes (C/S)
‘WRITE-VERIFY’                Yes (C/S)
‘WRITERS’                     Yes (C/S)
‘X’                           Yes (C/S)
‘XML’                         Yes
‘XML-DECLARATION’             Yes (C/S)
‘XML-SCHEMA’                  Yes (C/S)
‘XOR’                         No
‘Y’                           Yes (C/S)
‘YYYYDDD’                     Yes (C/S)
‘YYYYMMDD’                    Yes (C/S)
‘ZERO’                        Yes            ‘ZEROES, ZEROS’
‘ZERO-FILL’                   No (C/S)
‘ZEROES’                      Yes            ‘ZERO, ZEROS’
‘ZEROS’                       Yes            ‘ZERO, ZEROES’
                                             

C.2 Extra (obsolete) context sensitive words
============================================

‘AUTHOR’, ‘DATE-COMPILED’, ‘DATE-MODIFIED’, ‘DATE-WRITTEN’,
‘INSTALLATION’, ‘REMARKS’, ‘SECURITY’

C.3 Internal registers
======================

Register                      Implemented    Definition
---------------------------------------------------------------------------
‘'ADDRESS OF' phrase’         Yes            ‘USAGE POINTER’
‘COB-CRT-STATUS’              Yes            ‘PICTURE 9(4) USAGE DISPLAY
                                             VALUE ZERO’
‘DEBUG-ITEM’                  Yes            ‘PICTURE X(n) USAGE
                                             DISPLAY’
‘'LENGTH OF' phrase’          Yes            ‘CONSTANT USAGE
                                             BINARY-LONG’
‘NUMBER-OF-CALL-PARAMETERS’   Yes            ‘USAGE BINARY-LONG’
‘RETURN-CODE’                 Yes            ‘GLOBAL USAGE BINARY-LONG
                                             VALUE ZERO’
‘SORT-RETURN’                 Yes            ‘GLOBAL USAGE BINARY-LONG
                                             VALUE ZERO’
‘TALLY’                       Yes            ‘GLOBAL PICTURE 9(5) USAGE
                                             BINARY VALUE ZERO’
‘WHEN-COMPILED’               Yes            ‘CONSTANT PICTURE X(16)
                                             USAGE DISPLAY’
‘XML-CODE’                    Yes            ‘GLOBAL PICTURE S9(9) USAGE
                                             BINARY VALUE 0’
‘XML-EVENT’                   Yes ‘GLOBAL
                              USAGE
                              DISPLAY
                              PICTURE
                              X(30) VALUE
                              SPACE’
‘XML-INFORMATION’             Yes ‘GLOBAL
                              PICTURE
                              S9(9) USAGE
                              BINARY VALUE
                              0’
‘XML-NAMESPACE’               Yes ‘GLOBAL
                              PIC X ANY
                              LENGTH’
‘XML-NAMESPACE-PREFIX’        Yes ‘GLOBAL
                              PIC X ANY
                              LENGTH’
‘XML-NNAMESPACE’              Yes ‘GLOBAL
                              PIC N ANY
                              LENGTH’
‘XML-NNAMESPACE-PREFIX’       Yes ‘GLOBAL
                              PIC N ANY
                              LENGTH’
‘XML-NTEXT’                   Yes ‘GLOBAL
                              PIC N ANY
                              LENGTH’
‘XML-TEXT’                    Yes ‘GLOBAL
                              PIC X ANY
                              LENGTH’
‘JSON-CODE’                   Yes            ‘GLOBAL PICTURE S9(9) USAGE
                                             BINARY VALUE 0’
‘JSON-STATUS’                 Yes            ‘GLOBAL PICTURE S9(9) USAGE
                                             BINARY VALUE 0’


