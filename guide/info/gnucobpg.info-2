This is gnucobpg.info, produced by makeinfo version 7.2 from
gnucobpg.texi.

This manual documents GnuCOBOL 3.2 - Final, 1 January 2025 at 00:01 GMT.
build.


   Document Copyright 2009-2014 Gary L. Cutler & FSF (Free Software
Foundation).
Updates: Copyright 2014-2025 Vincent B. Coen, Gary L. Cutler & FSF.

     The authors and copyright holders of the COBOL programming language
     itself used herein:

     FLOW-MATIC (trademark for Sperry Rand Corporation) Programming for
     the Univac(R) I & II. Data Automation Systems copyrighted 1958,
     1959, by Sperry Rand Corporation; IBM commercial translator form
     F28-8013, copyrighted 1959 by IBM; FACT DSI27A5260-2760,
     copyrighted 1960 by Minneapolis-Honeywell, have specifically
     authorised the use of this material in whole or in part of the
     COBOL specifications.  Such authorisation extends to the
     reproduction & use of COBOL specifications in programming manuals
     or similar publications.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License
     [FDL], Version 1.3 or any later version published by the Free
     Software Foundation; with Invariant Section "Introduction", no
     Front-Cover Texts, and no Back-Cover Texts.  A copy of the license
     is included in the section entitled "GNU Free Documentation
     License".

     Permission is granted to make and distribute verbatim copies of
     this manual provided the copyright notice and this permission
     notice are preserved on all copies.

     Permission is granted to copy and distribute modified versions of
     this manual under the conditions for verbatim copying, provided
     that the entire resulting derived work is distributed under the
     terms of a permission notice identical to this one.

     Permission is granted to copy and distribute translations of this
     manual into another language, under the above conditions for
     modified versions, except that this permission notice may be stated
     in a translation approved by the Free Software Foundation.

INFO-DIR-SECTION GNU-COBOL
START-INFO-DIR-ENTRY
* GNU-COBOL: (gnucobpg)        GnuCOBOL Programmer's Guide
END-INFO-DIR-ENTRY


File: gnucobpg.info,  Node: LINKAGE SECTION,  Next: REPORT SECTION,  Prev: LOCAL-STORAGE SECTION,  Up: DATA DIVISION

6.5 LINKAGE SECTION
===================

                   LINKAGE-SECTION-Data-Item Syntax
=======================================================================

 level-number [ identifier-1 | FILLER ] [ IS GLOBAL|EXTERNAL ]
                               ~~~~~~        ~~~~~~ ~~~~~~~~
 [ ANY LENGTH ]
   ~~~ ~~~~~~
 [ ANY NUMERIC ]
   ~~~ ~~~~~~~
 [ BASED ]
   ~~~~~
 [ BLANK WHEN ZERO ]
   ~~~~~      ~~~~
 [ JUSTIFIED RIGHT ]
   ~~~~
 [ OCCURS [ integer-1 TO ] integer-2 TIMES
   ~~~~~~             ~~   UNBOUNDED
                           ~~~~~~~~~
       [ DEPENDING ON identifier-3 ]
         ~~~~~~~~~
       [ ASCENDING|DESCENDING KEY IS identifier-4 ]
         ~~~~~~~~~ ~~~~~~~~~~
       [ INDEXED BY identifier-5 ] ]
         ~~~~~~~
 [ PICTURE IS picture-string ]
   ~~~
 [ REDEFINES identifier-6 ]
   ~~~~~~~~~
 [ SIGN IS LEADING|TRAILING [ SEPARATE CHARACTER ] ]
   ~~~~    ~~~~~~~ ~~~~~~~~   ~~~~~~~~
 [ SYNCHRONIZED|SYNCHRONISED [ LEFT|RIGHT ] ]
   ~~~~        ~~~~           ~~~~ ~~~~~
 [ USAGE IS data-item-usage ] . [ LINKAGE-SECTION-Data-Item ]...
   ~~~~~

   The ‘LEFT’ and ‘RIGHT’ (SYNCHRONIZED) clauses are syntactically
recognized but are otherwise non-functional.

=======================================================================

   The linkage section describes data within a subprogram that serves as
either input arguments to or output results from the subprogram.
  1. The reserved words ‘BY’, ‘CHARACTER’, ‘IS’, ‘KEY’, ‘ON’ and ‘WHEN’
     are optional and may be included, or not, at the discretion of the
     programmer.  The presence or absence of these words has no effect
     upon the program.

  2. The reserved words ‘SYNCHRONIZED’ and "‘SYNCHRONISED’" are
     interchangeable.  Both may be abbreviated as ‘SYNC’.

  3. The reserved word ‘PICTURE’ may be abbreviated to ‘PIC’.

  4. The reserved word ‘JUSTIFIED’ may be abbreviated to ‘JUST’.

  5. As the syntax diagram shows, the definition of a
     ‘LINKAGE-SECTION-DATA-ITEM’ is a recursive one in that there may be
     any number of such specifications coded following one another.  The
     first such specification must have a level number of 01.
     Specifications that follow that one may have level numbers greater
     than 01, in which case they are defining a hierarchical breakdown
     of a record.  The definition of a record is terminated when one of
     the following occurs:

        • Another 01-level item is found -- this signifies the end of
          the definition of one record and the start of a another.

        • A division or section header is found -- this also marks the
          completion of a record and signifies the end of the linkage
          section as well.

  6. Every ‘LINKAGE-SECTION-DATA-ITEM’ description must be terminated
     with a period.

  7. The only valid level numbers are 01-49, 66, 77, 78 and 88.  Level
     numbers 01 through 49 are used to define data items that may be
     part of a hierarchical structure.  Level number 01 can also be used
     to define a constant -- an item with an unchangeable value
     specified at compilation time.

  8. Level numbers 66, 77, 78 and 88 all have special uses -- *Note
     Special Data Items::, for details.

  9. It is expected that:
       A. A linkage section should occur only within a subprogram.  The
          compiler will not prevent its use in a main program, however.

       B. All 01-level data items described within a subprogram's
          linkage section should appear in a ‘PROCEDURE DIVISION USING’
          (*note PROCEDURE DIVISION USING::) or as arguments on an
          ‘ENTRY’ statement.

       C. Each 01-level data item described within a subprogram's
          linkage section should correspond to an argument passed on a
          ‘CALL’ statement (*note CALL::) or an argument on a function
          call to the subprogram.

  10. Not specifying an IDENTIFIER-1 or ‘FILLER’ immediately after the
     level number has the same effect as if ‘FILLER’ were specified.  A
     data item named ‘FILLER’ cannot be referenced directly; these items
     are generally used to specify an unused portion of the total
     storage allocated to a group item or to describe a group item whose
     contents which will only be referenced using the names of those
     items that belong to it.  In the linkage section, 01-level data
     items cannot be named ‘FILLER’.

  11. No storage is allocated for data defined in the linkage section;
     the data descriptions there are merely defining storage areas that
     will be passed to the subprogram by a calling program.  Therefore,
     any discussion of the default initialization of such data is
     irrelevant.  It is possible, however, to manually allocate linkage
     section data items that aren't subprogram arguments via the
     ‘ALLOCATE’ statement (*note ALLOCATE::) statement.  In such cases,
     initialization will take place as per the documentation of that
     statement.

  12. The reserved word ‘UNBOUNDED’ can be used to specify an unbounded
     table (a table with an unbounded maximum number of occurrences),
     and can be referenced anywhere that a table can be referenced.

  13. An unbounded group is a group that contains at least one unbounded
     table.  It can be specified ONLY in the Linkage Section, and must
     be of type alphanumeric or national.

  14. You can reference unbounded groups in COBOL syntax anywhere that
     an alphanumeric or national group can be referenced, with the
     following exceptions:

     You cannot specify unbounded groups as a BY CONTENT argument in a
     CALL statement.  You cannot specify unbounded groups as data-name-2
     on the Procedure Division RETURNING phrase.  You cannot specify
     unbounded groups as arguments to intrinsic functions, except as an
     argument to the LENGTH intrinsic function.

  15. *Note Data Description Clauses::, for information on the usage of
     the various data description clauses.


File: gnucobpg.info,  Node: REPORT SECTION,  Next: SCREEN SECTION,  Prev: LINKAGE SECTION,  Up: DATA DIVISION

6.6 REPORT SECTION
==================

                         REPORT SECTION Syntax
=======================================================================

 [ REPORT SECTION.
   ~~~~~~ ~~~~~~~
   { Report-Description [ { Report-Group-Definition } ]... }... ]
   {                      { 01-Level-Constant       }      }
   {                      { 78-Level-Constant       }      }
   { 01-Level-Constant                                     }
   { 78-Level-Constant                                     }


=======================================================================
                    Report-Description (RD) Syntax
=======================================================================

 RD report-name [ IS GLOBAL ]
 ~~                  ~~~~~~
 [ CODE IS literal-1 | identifier-1 ]
   ~~~~
 [ { CONTROL IS   } { FINAL        }... ]
   { ~~~~~~~      } { ~~~~~        }
   { CONTROLS ARE } { identifier-2 }
     ~~~~~~~~
 [ PAGE [ { LIMIT IS   } ] [ { literal-2    } LINES ]
   ~~~~   { ~~~~~      }     { identifier-3 } ~~~~
          { LIMITS ARE }
            ~~~~~~
       [ literal-3 | identifier-4 COLUMNS|COLS ]
                                  ~~~~~~~ ~~~~
       [ HEADING IS literal-4 | identifier-5 ]
         ~~~~~~~
       [ FIRST DE|DETAIL IS literal-5 | identifier-6 ]
         ~~~~~ ~~ ~~~~~~
       [ LAST CH|{CONTROL HEADING} IS literal-6 | identifier-7 ]
         ~~~~ ~~  ~~~~~~~ ~~~~~~~
       [ LAST DE|DETAIL IS literal-7 | identifier-8 ]
         ~~~~ ~~ ~~~~~~
       [ FOOTING IS literal-8 | identifier-9 ] ] .
         ~~~~~~~


=======================================================================

   This section describes the layout of printed reports as well as many
of the functional aspects of the generation of reports that will be
produced via the Report Writer Control System.  It is important to
maintain the order of these clauses and ensure that all fields defined
or referenced with this section are actually defined in the
‘WORKING-STORAGE SECTION’ and not elsewhere.
  1. The reserved words ‘ARE’ and ‘IS’ are optional and may be omitted.
     The presence or absence of these words has no effect upon the
     program.

  2. The phrases ‘CONTROL IS’ and ‘CONTROLS ARE’ are interchangeable, as
     are the ‘PAGE LIMIT’ and ‘PAGE LIMITS’ phrases.

  3. The reserved word ‘LINES’ may be abbreviated as ‘LINE’.

  4. The reserved word ‘COLUMNS’ may be abbreviated as ‘COLS’.

  5. Each report referenced on a ‘REPORT IS’ clause (*note
     File/Sort-Description::) must be described with a report
     description (‘RD’).

  6. *Note GLOBAL::, for information on the ‘GLOBAL’ option.

  7. Please see *note Report Writer Features::, if you have not read it
     already.  It will familiarize you with the Report Writer
     terminology that follows.

  8. The following rules pertain to the ‘PAGE LIMITS’ clause:
       A. If no ‘PAGE LIMITS’ clause is specified, the entire report
          will be generated as if it consists of a single arbitrarily
          long page.

       B. All literals (LITERAL-2 through LITERAL-8) must be numeric
          with non-zero positive integer values.

       C. All identifiers (IDENTIFIER-2 through IDENTIFIER-8) must be
          numeric, unedited with non-zero positive integer values.

       D. Any value specified for LITERAL-2 or IDENTIFIER-2 will define
          the total number of available lines on any report page, not
          counting any unused margins at the top and/or bottom of the
          page (defined by the ‘LINES AT TOP’ and ‘LINES AT BOTTOM’
          values specified on the ‘LINAGE’ clause of the ‘FD’ this ‘RD’
          is linked to -- *note File/Sort-Description::).

       E. Any value specified for LITERAL-3 or IDENTIFIER-3 will be
          ignored.

       F. The ‘HEADING’ clause defines the first line number at which a
          report heading or page heading may be presented.

       G. The ‘FIRST DETAIL’ clause defines the first line at which a
          detail group may be presented.

       H. The ‘LAST CONTROL’ ‘HEADING’ clause defines the last line at
          which any line of a control heading may be presented.

       I. The ‘LAST DETAIL’ clause defines the last line at which any
          line of a detail group may be presented.

       J. The ‘FOOTING’ clause defines the last line at which any line
          of a control footing group may be presented.

       K. The following rules establish default values for the various
          ‘PAGE LIMIT’ clauses, assuming there is one:
          ‘HEADING’
               default is one (1)

          ‘FIRST DETAIL HEADING’
               value is used

          ‘LAST CONTROL HEADING’
               value from ‘LAST DETAIL’ or, if that is absent, the value
               from ‘FOOTING’ or, if that too is absent, the value from
               ‘PAGE LIMIT’

          ‘LAST DETAIL’
               value from ‘FOOTING’ or, if that is absent, the value
               from ‘PAGE LIMIT’

          ‘FOOTING’
               value from ‘LAST DETAIL’ or, if that is absent, the value
               from ‘PAGE LIMIT’

       L. For the values specified on a ‘PAGE LIMIT’ clause to be valid,
          all of the following must be true:

             • ‘FIRST DETAIL’ ≤ ‘HEADING’

             • ‘LAST CONTROL HEADING’ ≤ ‘FIRST DETAIL’

             • ‘LAST DETAIL’ ≤ ‘LAST CONTROL HEADING’

             • ‘FOOTING’ ≤ ‘LAST DETAIL’

  9. The following rules pertain to the ‘CONTROL’ clause:
       A. If there is no ‘CONTROL’ clause, the report will contain no
          control breaks; this implies that there can be no ‘CONTROL
          HEADING’ or ‘CONTROL FOOTING’ report groups defined for this
          ‘RD’.

       B. Include the reserved word ‘FINAL’ if you want to include a
          special control heading before the first detail line is
          generated (‘CONTROL HEADING FINAL’) or after the last detail
          line is generated (‘CONTROL FOOTING FINAL’).

       C. If you specify ‘FINAL’, it must be the first control break
          named in the ‘RD’.

       D. Any IDENTIFIER-9 specifications included on the ‘CONTROL’
          clause are referencing data names defined in any data division
          section except for the report section.

       E. There must be a ‘CONTROL HEADING’ and/or ‘CONTROL FOOTING’
          report group defined in the report section for each
          IDENTIFIER-9.

       F. At execution time:

             • Each time a ‘GENERATE’ statement (*note GENERATE::) is
               executed against a detail report group defined for this
               ‘RD’, the RWCS will check the contents of each
               IDENTIFIER-2 data item; whenever an IDENTIFIER-9's value
               has changed since the previous ‘GENERATE’, a control
               break condition will be in effect for that IDENTIFIER-2.

             • Once the list of control breaks has been determined, the
               ‘CONTROL FOOTING’ for each IDENTIFIER-2 having a control
               break (if any such report group is defined) will be
               presented.

             • Next, the ‘CONTROL HEADING’ for each IDENTIFIER-2 having
               a control break (if any such report group is defined)
               will be presented.

             • The ‘CONTROL FOOTING’ and ‘CONTROL HEADING’ report groups
               will be presented in the sequence in which they are
               listed on the ‘CONTROL’ clause.

             • Only after this processing has occurred will the detail
               report group specified on the ‘GENERATE’ be presented.
  10. Each ‘RD’ will have the following allocated for it:
       A. The ‘PAGE-COUNTER’ special register (*note Special
          Registers::), which will contain the current report page
          number.
             • This register will be set to a value of 1 when an
               ‘INITIATE’ statement (*note INITIATE::) is executed for
               the report and will be incremented by 1 each time the
               RWCS starts a new page of the report.

             • References to ‘PAGE-COUNTER’ within the report section
               will be implicitly qualified with the name of the report
               to which the report group referencing the register
               belongs.

             • References to ‘PAGE-COUNTER’ in the procedure division
               must be qualified with the appropriate report name if
               there are multiple ‘RD’s defined.
       B. The ‘LINE-COUNTER’ special register, which will contain the
          current line number on the current page.
  11. The ‘RD’ must be followed by at least one 01-level report group
     definition.
* Menu:

* Report Group Definitions.
* REPORT SECTION Data Items.


File: gnucobpg.info,  Node: Report Group Definitions,  Next: REPORT SECTION Data Items,  Up: REPORT SECTION

6.6.1 Report Group Definitions
------------------------------

                    Report-Group-Definition Syntax
=======================================================================

 01 [ identifier-1 ]

 [ LINE NUMBER IS { integer-1 [ [ ON NEXT PAGE ] } ]
   ~~~~           {                  ~~~~ ~~~~   }
                  { +|PLUS integer-1             }
                  {   ~~~~                       }
                  { ON NEXT PAGE                 }
                       ~~~~ ~~~~
 [ NEXT GROUP IS { [ +|PLUS ] integer-2  } ]
   ~~~~ ~~~~~    {     ~~~~              }
                 { NEXT|{NEXT PAGE}|PAGE }
                   ~~~~  ~~~~ ~~~~  ~~~~
 [ TYPE IS { RH|{REPORT HEADING}                      } ]
   ~~~~    { ~~  ~~~~~~ ~~~~~~~                       }
           { PH|{PAGE HEADING}                        }
           { ~~  ~~~~ ~~~~~~~                         }
           { CH|{CONTROL HEADING} FINAL|identifier-2  }
           { ~~  ~~~~~~~ ~~~~~~~  ~~~~~               }
           { DE|DETAIL                                }
           { ~~ ~~~~~~                                }
           { CF|{CONTROL FOOTING} FINAL|identifier-2  }
           { ~~  ~~~~~~~ ~~~~~~~  ~~~~~               }
           { PF|{PAGE FOOTING}                        }
           {  ~~ ~~~~ ~~~~~~~                         }
           { RF|{REPORT FOOTING}                      }
             ~~  ~~~~~~ ~~~~~~~
 . [ REPORT-SECTION-Data-Item ]...


=======================================================================

   The syntax shown here documents how a report group is defined to a
report.  This syntax is valid only in the report section, and only then
after an ‘RD’.
  1. The reserved words ‘IS’, ‘NUMBER’ and ‘ON’ are optional and may be
     omitted.  The presence or absence of these words has no effect upon
     the program.

  2. The ‘RH’ and ‘REPORT HEADING’ terms are interchangeable, as are
     ‘PH’ and ‘PAGE HEADING’, ‘CH’ and ‘CONTROL HEADING’, ‘DE’ and
     ‘DETAIL’, ‘CF’ and ‘CONTROL FOOTING’, ‘PF’ and ‘PAGE FOOTING’ as
     well as ‘RF’ and ‘REPORT FOOTING’.

  3. The report group being defined will be a part of the most-recently
     coded ‘RD’.

  4. The ‘TYPE’ (*note TYPE::) clause specifies the type of report group
     being defined.

  5. The level number used for a report group definition must be 01.

  6. The optional IDENTIFIER-1 specification assigns a name to this
     report group so that the group may be referenced either by a
     ‘GENERATE’ statement or on a ‘USE BEFORE REPORTING’.

  7. No two report groups in the same report (‘RD’) may named with the
     same IDENTIFIER-1.  There may, however, be multiple IDENTIFIER-1
     definitions in different reports.  In such instances, references to
     IDENTIFIER-1 must be qualified by the report name.

  8. There may only be one report heading, report footing, final control
     heading, final control footing, page heading and page footing
     defined per report.

  9. Report group declarations must be followed by at least one
     ‘REPORT-SECTION-DATA-ITEM’ with a level number in the range 02-49.

  10. *Note Data Description Clauses::, for information on the usage of
     the various data description clauses.


File: gnucobpg.info,  Node: REPORT SECTION Data Items,  Prev: Report Group Definitions,  Up: REPORT SECTION

6.6.2 REPORT SECTION Data Items
-------------------------------

                    REPORT-SECTION-Data-Item Syntax
=======================================================================

 level-number [ identifier-1 ]

 [ BLANK WHEN ZERO ]
   ~~~~~      ~~~~
 [ COLUMN [ { NUMBER IS   } ] [ +|PLUS ] integer-1 ]
   ~~~      { ~~~~~~      }       ~~~~
            { NUMBERS ARE }
              ~~~~~~~
 [ GROUP INDICATE ]
   ~~~~~ ~~~~~~~~
 [ JUSTIFIED RIGHT ]
   ~~~~
 [ LINE NUMBER IS { integer-2 [ [ ON NEXT PAGE ] } ]
   ~~~~           { +|PLUS integer-2 ~~~~ ~~~~   }
                  {   ~~~~                       }
                  { ON NEXT PAGE                 }
                       ~~~~ ~~~~
 [ OCCURS [ integer-3 TO ] integer-4 TIMES
   ~~~~~~             ~~   UNBOUNDED
                           ~~~~~~~~~
     [ DEPENDING ON identifier-2 ]
       ~~~~~~~~~
     [ STEP integer-5 ]
       ~~~~
     [ VARYING identifier-3 FROM { identifier-4 } BY { identifier-5 } ]
       ~~~~~~~              ~~~~ { integer-6    } ~~ { integer-7    }
 [ PICTURE IS picture-string ]
   ~~~
 [ PRESENT WHEN condition-name ]
   ~~~~~~~ ~~~~
 [ SIGN IS LEADING|TRAILING [ SEPARATE CHARACTER ] ]
   ~~~~    ~~~~~~~ ~~~~~~~~   ~~~~~~~~
 [ { SOURCE IS literal-1|identifier-6 [ ROUNDED ]                   } ]
   { ~~~~~~                             ~~~~~~~                     }
   { SUM OF { identifier-7 }... [ { RESET ON FINAL|identifier-8 } ] }
   { ~~~    { literal-2    }      { ~~~~~    ~~~~~              }   }
   { VALUE IS [ ALL ] literal-3   { UPON identifier-9           }   }
     ~~~~~      ~~~                 ~~~~
 . [ REPORT-SECTION-Data-Item ]...


=======================================================================

   Data item descriptions describing the report lines and fields that
make up the substance of a report group immediately follow the
definition of that group.
  1. The reserved words ‘IS’, ‘NUMBER’, ‘OF’, ‘ON’, ‘RIGHT’, ‘TIMES’ and
     ‘WHEN’ (BLANK) are optional and may be omitted.  The presence or
     absence of these words has no effect upon the program.

  2. The reserved word ‘COLUMN’ may be abbreviated as ‘COL’.

  3. The reserved word ‘JUSTIFIED’ may be abbreviated as ‘JUST’.

  4. The reserved word ‘PICTURE’ may be abbreviated as ‘PIC’.

  5. The ‘SOURCE’ (*note SOURCE::), ‘SUM’ (*note SUM::) and ‘VALUE’
     (*note VALUE::) clauses, valid only on an elementary item, are
     mutually-exclusive of each other.

  6. Group items (those without ‘PICTURE’ clauses) are frequently used
     to describe entire lines of a report, while elementary items (those
     with a picture clause) are frequently used to describe specific
     fields of information on the report.  When this coding convention
     is being used, group items will have ‘LINE’ (*note LINE::) clauses
     and no ‘COLUMN’ (*note COLUMN::) clauses while elementary items
     will be specified the other way around.

  7. *Note Data Description Clauses::, for information on the usage of
     the various data description clauses.


File: gnucobpg.info,  Node: SCREEN SECTION,  Next: Special Data Items,  Prev: REPORT SECTION,  Up: DATA DIVISION

6.7 SCREEN SECTION
==================

                    SCREEN-SECTION-Data-Item Syntax
=======================================================================

 level-number [ identifier-1 | FILLER ]
                               ~~~~~~

 [ AUTO | AUTO-SKIP | AUTOTERMINATE | TAB ]
   ~~~~   ~~~~~~~~~   ~~~~~~~~~~~~~   ~~~
 [ BELL | BEEP ]
   ~~~~   ~~~~
 [ BACKGROUND-COLOR|BACKGROUND-COLOUR IS integer-1 | identifier-2 ]
   ~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~
 [ FOREGROUND-COLOR|FOREGROUND-COLOUR IS integer-3 | identifier-4 ]
   ~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~
 [ BLANK { LINE|SCREEN } ]
   ~~~~~   ~~~~ ~~~~~~
 [ ERASE { EOL|EOS                       } ]
 [ ~~~~~ { ~~~ ~~~                       } ]
 [       { [TO END OF ] {LINE | SCREEN } } ]
               ~~~       ~~~~   ~~~~~~
 [ INITIAL ]
   ~~~~~~~
 [ BLANK WHEN ZERO ] [ JUSTIFIED RIGHT ]
   ~~~~~      ~~~~     ~~~~
 [ BLINK ] [ HIGHLIGHT | LOWLIGHT ]
   ~~~~~     ~~~~~~~~~   ~~~~~~~~
 [ REVERSE-VIDEO | REVERSE | REVERSED ]
   ~~~~~~~~~~~~~   ~~~~~~~   ~~~~~~~~
 [ COLUMN | POSITION NUMBER IS [ { +|PLUS  } ] integer-2 | identifier-3 ]
 [ ~~~      ~~~~~~~~           [ {   ~~~~  } ]                          ]
 [                             [ { -|MINUS } ]                          ]
                                     ~~~~~
 [ CURSOR { identifier-10 } ]
   ~~~~~~
 [ { FROM literal-1 | identifier-5 } ]
 [ { ~~~~                          } ]
 [ { TO identifier-5               } ]
 [ { ~~                            } ]
 [ { USING identifier-5            } ]
     ~~~~~
 [ { VALUE IS [ ALL ] literal-1    } ]
     ~~~~~      ~~~
 [ FULL | LENGTH-CHECK ] [ REQUIRED | EMPTY-CHECK ]
   ~~~~   ~~~~~~~~~~~~     ~~~~~~~~   ~~~~~~~~~~~
 [ NO ECHO | NO-ECHO | OFF | SECURE ]
   ~~~~~~~   ~~~~~~~   ~~~   ~~~~~~
 [ LEFTLINE ] [ OVERLINE ] [ UNDERLINE ]
   ~~~~~~~~     ~~~~~~~~     ~~~~~~~~~
 [ LINE NUMBER IS [ { +|PLUS  } ] integer-4 | identifier-6 ]
 [ ~~~            [ {   ~~~~  } ]                          ]
 [                [ { -|MINUS } ]                          ]
                        ~~~~~
 [ OCCURS integer-5 TIMES ]
   ~~~~~~
 [ PICTURE IS picture-string ]
   ~~~
 [ PROMPT [ CHARACTER IS literal-2 | identifier-7 ]
   ~~~~~~   ~~~~~~~~~
 [ SIGN IS LEADING|TRAILING [ SEPARATE CHARACTER ] ] .
   ~~~~    ~~~~~~~ ~~~~~~~~   ~~~~~~~~


=======================================================================

   The screen section describes the screens to be displayed during
terminal/console I-O.
  1. The reserved words ‘CHARACTER’ (‘SEPARATE’ clause), ‘IS’, ‘NUMBER’,
     ‘RIGHT’, ‘TIMES’ and ‘WHEN’ are optional and may be omitted.  The
     presence or absence of these words has no effect upon the program.

  2. The reserved word ‘COLUMN’ may be abbreviated as ‘COL’.

  3. The reserved word ‘PICTURE’ may be abbreviated as ‘PIC’.

  4. The following sets of reserved words are interchangeable:

        • ‘AUTO’, ‘AUTO-SKIP’ and ‘AUTOTERMINATE’

        • ‘BACKGROUND-COLOR’ and ‘BACKGROUND-COLOUR’

        • ‘BELL’ and ‘BEEP’

        • ‘FOREGROUND-COLOR’ and ‘FOREGROUND-COLOUR’

        • ‘FULL’ and ‘LENGTH-CHECK’

        • ‘REQUIRED’ and ‘EMPTY-CHECK’

        • ‘SECURE’ and ‘NO-ECHO’

  5. Data items defined in the screen section describe input, output or
     combination screen layouts to be used with ‘ACCEPT data-item’
     statement (*note ACCEPT data-item::) or ‘DISPLAY data-item’
     statement (*note DISPLAY data-item::) statements.  These screen
     layouts may define the entire available screen area or any subset
     of it.

  6. The term available screen area is a nebulous one in those
     environments where command-line shell sessions are invoked within a
     graphical user-interface environment, as will be the case on
     Windows, OSX and most Unix/Linux systems -- these environments
     allow command-line session windows to exist with a variable number
     of available screen rows and columns.  When you are designing
     GnuCOBOL screens, you need to do so with an awareness of the
     logical screen row/column geometry the program will be executing
     within.

  7. Data items with level numbers 01 (Constants), 66, 78 and 88 may be
     used in the screen section; they have the same syntax, rules and
     usage as they do in the other data division sections.

  8. Without ‘LINE’ (*note LINE::) or ‘COLUMN’ (*note COLUMN::) clauses,
     screen section fields will display on the console window beginning
     at whatever line/column coordinate is stated or implied by the
     ‘ACCEPT data-item’ or ‘DISPLAY data-item’ statement that presents
     the screen item.  After a field is presented to the console window,
     the next field will be presented immediately following that field.

  9. A ‘LINE’ clause explicitly stated in the definition of a screen
     section data item will override any ‘LINE’ clause included on the
     ‘ACCEPT data-item’ or ‘DISPLAY data-item’ statement that presents
     that data item to the screen.  The same is true of ‘COLUMN’
     clauses.

  10. The <Tab> and <Back-Tab> (<Shift>-<Tab> on most keyboards) keys
     will position the cursor from field to field in the line/column
     sequence in which the fields occur on the screen at execution time,
     regardless of the sequence in which they were defined in the screen
     section.

  11. *Note Data Description Clauses::, for information on the usage of
     the various data description clauses.

  12. See details of ACCEPT data-item for more information regarding
     usage of CURSOR.

  13. Use of the TAB phrase forces the user to finish the ACCEPT verb
     with a termination key.  This is the standard mode for GnuCOBOL and
     other compilers but not for RM COBOL. TAB cannot be used together
     with the AUTO / AUTO-SKIP and AUTOTERMINATE clauses.



File: gnucobpg.info,  Node: Special Data Items,  Next: Data Description Clauses,  Prev: SCREEN SECTION,  Up: DATA DIVISION

6.8 Special Data Items
======================

* Menu:

* 01-Level Constants.
* 66-Level Data Items.
* 77-Level Data Items.
* 78-Level Data Items.
* 88-Level Data Items.


File: gnucobpg.info,  Node: 01-Level Constants,  Next: 66-Level Data Items,  Up: Special Data Items

6.8.1 01-Level Constants
------------------------

                       01-Level-Constant Syntax
=======================================================================

 01 constant-name-1 CONSTANT [ IS GLOBAL ]
                    ~~~~~~~~      ~~~~~~
   { AS { literal-1                           } }
   {    { arithmetic-expression-1             } }
   {    { { BYTE-LENGTH } OF { identifier-1 } } }
   {    { { ~~~~~~~~~~~ }    { usage-name   } } }
   {    { { LENGTH      }                     } }
   {        ~~~~~~                              }
   { FROM CDF-variable-name-1                   }
     ~~~~


=======================================================================

   This syntax is valid in the following sections: ‘FILE’,
‘WORKING-STORAGE’, ‘LOCAL-STORAGE’, ‘LINKAGE’, ‘SCREEN’.

   The 01-level constant is one of five types of compilation-time
constants that can be declared within a program.  The other four types
are ‘>>DEFINE’ CDF directive (*note >>DEFINE::) constants, ‘>>SET’ CDF
directive (*note >>SET::) constants, 78-level constants (*note 78-Level
Data Items:: and arithmetic-expression-1).
  1. The reserved words ‘AS’, ‘IS’ and ‘OF’ are optional and may be
     omitted.  The presence or absence of these words has no effect upon
     the program.

  2. *Note GLOBAL::, for information on the ‘GLOBAL’ option.

  3. This particular type of constant declaration provides the ability
     to determine the length of a data item or the storage size
     associated with a particular numeric ‘USAGE’ (*note USAGE::) type
     -- something not possible with the other types of constants.

  4. Constants defined in this way become undefined once an ‘END
     PROGRAM’ or ‘END FUNCTION’ is encountered in the input source.

  5. Data descriptions of this form do not actually allocate any storage
     -- they merely define a name (CONSTANT-NAME-1) that may be used
     anywhere a numeric literal (see ‘BYTE-LENGTH’ or ‘LENGTH’ options)
     or a literal of the same type as LITERAL-1 may be used.

  6. The CONSTANT-NAME-1 name may not be referenced on a CDF directive.

  7. Care must be taken that CONSTANT-NAME-1 does not duplicate any
     other data item name that has been defined in the program as
     references to that data item name will refer to the constant and
     not the data item.  The GnuCOBOL compiler will not issue a warning
     about this condition.

  8. The value specified for USAGE-NAME may be any ‘USAGE’ that does not
     use a ‘PICTURE’ (*note PICTURE::) clause.  These would be any of
     ‘BINARY-C-LONG’, ‘BINARY-CHAR’, ‘BINARY-DOUBLE’, ‘BINARY-LONG’,
     ‘BINARY-SHORT’, ‘COMP-1’ (or ‘COMPUTATIONAL-1’), ‘COMP-2’ (or
     ‘COMPUTATIONAL-2’), ‘FLOAT-DECIMAL-16’, ‘FLOAT-DECIMAL-34’,
     ‘FLOAT-LONG’, ‘FLOAT-SHORT’, ‘POINTER’, or ‘PROGRAM-POINTER’.

  9. The ‘BYTE-LENGTH’ clause will produce a numeric value for
     CONSTANT-NAME-1 identical to that which would be returned by the
     ‘BYTE-LENGTH’ intrinsic function executed against IDENTIFIER-1 or a
     data item declared with a ‘USAGE’ of USAGE-NAME.

  10. The ‘LENGTH’ clause will produce a numeric value for
     CONSTANT-NAME-1 identical to that which would be returned by the
     ‘LENGTH’ intrinsic function executed against IDENTIFIER-1 or a data
     item declared with a ‘USAGE’ of USAGE-NAME.

   Here is usage examples of the option arithmetic-expression


 78 wCONST VALUE 2 *  (23 + 3) + (10 / 2).
 01 wCONST2 constant (23 + 3)**2.
 01 wCONST3 constant (12 + wCONST2)**2 - wCONST.
 78 wCONST4 value    (12 + wCONST3)**2 - wCONST2.

   Here is another example of using the option arithmetic-expression.

       PROGRAM-ID. TESTCONST.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01 A   CONSTANT 2.
       01 B   CONSTANT ( (3 + 2) * A).
       01 CON CONSTANT (A ** B).
       01 MYDATA PIC X(CON).
       PROCEDURE DIVISION.
        DISPLAY CON
        ACCEPT omitted
        MOVE "123456789012345678901234567890" TO MYDATA
         DISPLAY MYDATA
        ACCEPT omitted
        GOBACK.

   Here is the listing of a GnuCOBOL program that uses 01-level
constants to display the length (in bytes) of the various picture-less
usage types.

       IDENTIFICATION DIVISION.
       PROGRAM-ID. Usage-Lengths.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01  Len-BINARY-C-LONG    CONSTANT AS LENGTH OF BINARY-C-LONG.
       01  Len-BINARY-CHAR      CONSTANT AS LENGTH OF BINARY-CHAR.
       01  Len-BINARY-DOUBLE    CONSTANT AS LENGTH OF BINARY-DOUBLE.
       01  Len-BINARY-LONG      CONSTANT AS LENGTH OF BINARY-LONG.
       01  Len-BINARY-SHORT     CONSTANT AS LENGTH OF BINARY-SHORT.
       01  Len-COMP-1           CONSTANT AS LENGTH OF COMP-1.
       01  Len-COMP-2           CONSTANT AS LENGTH OF COMP-2.
       01  Len-FLOAT-DECIMAL-16 CONSTANT AS LENGTH OF FLOAT-DECIMAL-16.
       01  Len-FLOAT-DECIMAL-34 CONSTANT AS LENGTH OF FLOAT-DECIMAL-34.
       01  Len-FLOAT-LONG       CONSTANT AS LENGTH OF FLOAT-LONG.
       01  Len-FLOAT-SHORT      CONSTANT AS LENGTH OF FLOAT-SHORT.
       01  Len-POINTER          CONSTANT AS LENGTH OF POINTER.
       01  Len-PROGRAM-POINTER  CONSTANT AS LENGTH OF PROGRAM-POINTER.
       PROCEDURE DIVISION.
       000-Main.
           DISPLAY "On this system, with this build of GnuCOBOL, the"
           DISPLAY "PICTURE-less USAGE's have these lengths (in bytes):"
           DISPLAY " "
           DISPLAY "BINARY-C-LONG:    " Len-BINARY-C-LONG
           DISPLAY "BINARY-CHAR:      " Len-BINARY-CHAR
           DISPLAY "BINARY-DOUBLE:    " Len-BINARY-DOUBLE
           DISPLAY "BINARY-LONG:      " Len-BINARY-LONG
           DISPLAY "BINARY-SHORT:     " Len-BINARY-SHORT
           DISPLAY "COMP-1:           " Len-COMP-1
           DISPLAY "COMP-2:           " Len-COMP-2
           DISPLAY "FLOAT-DECIMAL-16: " Len-FLOAT-DECIMAL-16
           DISPLAY "FLOAT-DECIMAL-34: " Len-FLOAT-DECIMAL-34
           DISPLAY "FLOAT-LONG:       " Len-FLOAT-LONG
           DISPLAY "FLOAT-SHORT:      " Len-FLOAT-SHORT
           DISPLAY "POINTER:          " Len-POINTER
           DISPLAY "PROGRAM-POINTER:  " Len-PROGRAM-POINTER
           STOP RUN.

   The output of this program, on a Windows 7 system with a 32-bit MinGW
build of GnuCOBOL is:

    On this system, with this build of GnuCOBOL, the
    PICTURE-less USAGE's have these lengths (in bytes):

    BINARY-C-LONG:    4
    BINARY-CHAR:      1
    BINARY-DOUBLE:    8
    BINARY-LONG:      4
    BINARY-SHORT:     2
    COMP-1:           4
    COMP-2:           8
    FLOAT-DECIMAL-16: 8
    FLOAT-DECIMAL-34: 16
    FLOAT-LONG:       8
    FLOAT-SHORT:      4
    POINTER:          4
    PROGRAM-POINTER:  4

The output of this program, on a Linux X64 system running cobc (GnuCOBOL) 3.1.2.0 is:

On this system, with this build of GnuCOBOL, the
PICTURE-less USAGE's have these lengths (in bytes):

BINARY-C-LONG:    8
BINARY-CHAR:      1
BINARY-DOUBLE:    8
BINARY-LONG:      4
BINARY-SHORT:     2
COMP-1:           4
COMP-2:           8
FLOAT-DECIMAL-16: 8
FLOAT-DECIMAL-34: 16
FLOAT-LONG:       8
FLOAT-SHORT:      4
POINTER:          8
PROGRAM-POINTER:  8

Spot the differences between 32 and 64 bit.



File: gnucobpg.info,  Node: 66-Level Data Items,  Next: 77-Level Data Items,  Prev: 01-Level Constants,  Up: Special Data Items

6.8.2 66-Level Data Items
-------------------------

                       66-Level-Data-Item Syntax
=======================================================================

 66 identifier-1 RENAMES identifier-2 [ THRU|THROUGH identifier-3 ] .
                 ~~~~~~~                ~~~~ ~~~~~~~


=======================================================================

   This syntax is valid in the following sections: ‘FILE’,
‘WORKING-STORAGE’, ‘LOCAL-STORAGE’, ‘LINKAGE’

   A 66-level data item regroups previously defined items by specifying
alternative, possibly overlapping, groupings of elementary data items.
  1. The reserved words ‘THRU’ and ‘THROUGH’ are interchangeable.

  2. A level-66 data item cannot rename a level-66, level-01, level-77,
     or level-88 data item.

  3. There may be multiple level-66 data items that rename data items
     contained within the same 01-level record description.

  4. All ‘RENAMES’ entries associated with one logical record must
     immediately follow that record's last data description entry.


File: gnucobpg.info,  Node: 77-Level Data Items,  Next: 78-Level Data Items,  Prev: 66-Level Data Items,  Up: Special Data Items

6.8.3 77-Level Data Items
-------------------------

                       77-Level-Data-Item Syntax
=======================================================================

 77 identifier-1 [ IS GLOBAL|EXTERNAL ]
                      ~~~~~~ ~~~~~~~~
 [ BASED ]
   ~~~~~
 [ BLANK WHEN ZERO ]
   ~~~~~      ~~~~
 [ JUSTIFIED RIGHT ]
   ~~~~
 [ PICTURE IS picture-string ]
   ~~~
 [ REDEFINES identifier-5 ]
   ~~~~~~~~~
 [ SIGN IS LEADING|TRAILING [ SEPARATE CHARACTER ] ]
   ~~~~    ~~~~~~~ ~~~~~~~~   ~~~~~~~~
 [ SYNCHRONIZED|SYNCHRONISED [ LEFT|RIGHT ] ]
   ~~~~        ~~~~           ~~~~ ~~~~~
 [ USAGE IS data-item-usage ]
   ~~~~~
 [ VALUE IS [ ALL ] literal-1 ] .
   ~~~~~      ~~~

   The ‘LEFT’ and ‘RIGHT’ (SYNCHRONIZED) clauses are syntactically
recognized but are otherwise non-functional.

=======================================================================
   This syntax is valid in the following sections: ‘WORKING-STORAGE’,
‘LOCAL-STORAGE’, ‘LINKAGE’

   The intent of a 77-level item is to be able to create a stand-alone
elementary data item.
  1. The reserved words ‘CHARACTER’, ‘IS’, ‘RIGHT’ (JUSTIFIED) and
     ‘WHEN’ are optional and may be omitted.  The presence or absence of
     these words has no effect upon the program.

  2. The reserved word ‘JUSTIFIED’ may be abbreviated as ‘JUST’, the
     reserved word ‘PICTURE’ may be abbreviated as ‘PIC’ and the
     reserved words ‘SYNCHRONIZED’ and ‘SYNCHRONISED’ may be abbreviated
     as ‘SYNC’.

  3. New programs requiring a stand-alone elementary item should be
     coded to use a level number of 01 rather than 77.

  4. *Note Data Description Clauses::, for information on the usage of
     the various data description clauses.


File: gnucobpg.info,  Node: 78-Level Data Items,  Next: 88-Level Data Items,  Prev: 77-Level Data Items,  Up: Special Data Items

6.8.4 78-Level Data Items
-------------------------

                       78-Level-Constant Syntax
=======================================================================

 78 constant-name-1 VALUE IS
                    ~~~~~
  { integer-1                  } [ { +|-|*|/|** } { integer-3                  } ]
  { identifier-1               } [ { AND        } { identifier-3               } ]
  { literal-1                  } [ { ~~~        } { literal-3                  } ]
  { arithmetic-expression-1    } [ { OR         } { arithmetic-expression-3    } ]
  { LENGTH OF { identifier-2 } } [ { ~~         } { LENGTH OF { identifier-4 } } ]
  { ~~~~~~    { literal-2    } } [                { ~~~~~~    { literal-4    } } ]

  { START OF  identifier-5  }
  { ~~~~~                   }
  { NEXT }
    ~~~~


=======================================================================
   This syntax is valid in the following sections: ‘FILE’,
‘WORKING-STORAGE’, ‘LOCAL-STORAGE’, ‘LINKAGE’, ‘SCREEN’

   The 78-level constant is one of four types of compilation-time
constants that can be declared within a program.  The other three types
are ‘>>DEFINE’ CDF directive (*note >>DEFINE::) constants, ‘>>SET’ CDF
directive (*note >>SET::) constants and 01-level constants (*note
01-Level Constants::).
  1. The reserved word ‘IS’ is optional and may be omitted.  The
     presence or absence of this word has no effect upon the program.

  2. Constants defined in this way become undefined once an ‘END
     PROGRAM’ or ‘END FUNCTION’ is encountered in the input source.

  3. Data descriptions of this form do not actually allocate any storage
     -- they merely define a name (CONSTANT-NAME-1) that may be used
     anywhere a literal of the same type as LITERAL-1 may be used.

  4. The CONSTANT-NAME-1 name may not be referenced on a CDF directive.

  5. Care must be taken that CONSTANT-NAME-1 does not duplicate any
     other data item name that has been defined in the program as
     references to that data item name will refer to the constant and
     not the data item.  The GnuCOBOL compiler will not issue a warning
     about this condition.

  6. See in 6.8.1 for examples of using the option
     arithmetic-expression.

  7. NEXT gives the integer value representing the offset at which the
     next byte of storage hat follows the previous data declaration.

          Following sample program shows some definitions -

          ID DIVISION.
          PROGRAM-ID. TEST78.
          DATA DIVISION.
          WORKING-STORAGE SECTION.
          78 AAA VALUE (100 -1) + 100.
          01 K          PIC X(19).
          01 A EXTERNAL PIC X(05) VALUE SPACE.
          01 R EXTERNAL PIC X(08) VALUE SPACE.
          78 BBB VALUE LENGTH OF A.
          78 CCC VALUE LENGTH OF '1234'.
          78 DDD VALUE LENGTH OF '1234567890' / LENGTH OF A.
          78 EEE VALUE LENGTH OF '123'  * 3.
          78 FFF VALUE START OF R.
          01 B EXTERNAL.
             05 C   PIC X(26) VALUE 'A'.
             05 D   PIC X(21) VALUE 'A'.
             78 GGG           VALUE NEXT.
             78 HHH           VALUE START OF A.
             05 M   PIC X(23) VALUE 'B'.
          PROCEDURE DIVISION.
              DISPLAY 'AAA= ' AAA
              DISPLAY 'BBB= ' BBB
              DISPLAY 'CCC= ' CCC
              DISPLAY 'DDD= ' DDD
              DISPLAY 'EEE= ' EEE
              DISPLAY 'FFF= ' FFF
              DISPLAY 'GGG= ' GGG
              DISPLAY 'HHH= ' HHH
              STOP RUN.



File: gnucobpg.info,  Node: 88-Level Data Items,  Prev: 78-Level Data Items,  Up: Special Data Items

6.8.5 88-Level Data Items
-------------------------

                       88-Level-Data-Item Syntax
=======================================================================

 88 condition-name-1 { VALUE IS   } {literal-1 [ THRU|THROUGH literal-2 ]}...
                     { ~~~~~      }              ~~~~ ~~~~~~~
                     { VALUES ARE }
                       ~~~~~~

   [ WHEN SET TO FALSE IS literal-3 ] .
                 ~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘FILE’,
‘WORKING-STORAGE’, ‘LOCAL-STORAGE’, ‘LINKAGE’, ‘REPORT’, ‘SCREEN’

   Condition names are Boolean (i.e.  ‘TRUE’ / ‘FALSE’) data items that
receive their ‘TRUE’ and ‘FALSE’ values based upon the values of the non
88-level data item whose definition they immediately follow.
  1. The reserved words ‘ARE’, ‘IS’, ‘SET’ and ‘TO’ are optional and may
     be omitted.  The presence or absence of these words has no effect
     upon the program.

  2. The reserved words ‘THRU’ and ‘THROUGH’ are interchangeable.

  3. Condition names are always defined subordinate to another (non
     88-level) data item.  That data item must be an elementary item.
     Whenever the parent data item assumes one of the values specified
     on the 88-level item's ‘VALUE’ (*note VALUE::) clause,
     CONDITION-NAME-1 will take on the value of ‘TRUE’.

  4. Condition names do not occupy any storage.

  5. The optional ‘THROUGH’ clause allows a range of possible ‘TRUE’
     values to be specified.

  6. Whenever the parent data item assumes any value except one of the
     values specified on CONDITION-NAME-1's ‘VALUE’ clause,
     CONDITION-NAME-1 will take on the value of FALSE.

  7. Executing the statement ‘SET CONDITION-NAME-1 TO TRUE’ will cause
     CONDITION-NAME-1's parent data item to take on the first value
     specified on CONDITION-NAME-1's ‘VALUE’ clause.

  8. Executing the statement ‘SET CONDITION-NAME-1 TO FALSE’ will cause
     CONDITION-NAME-1's parent data item to take on the value specified
     on CONDITION-NAME-1's ‘FALSE’ clause.  If CONDITION-NAME-1 does not
     have a ‘FALSE’ clause, the ‘SET’ (*note SET::) statement will
     generate an error message at compilation time.

  9. *Note Condition Names::, for more information.


File: gnucobpg.info,  Node: Data Description Clauses,  Prev: Special Data Items,  Up: DATA DIVISION

6.9 Data Description Clauses
============================

* Menu:

* ANY LENGTH.
* ANY NUMERIC
* AUTO.
* AUTO-SKIP.
* AUTOTERMINATE.
* BACKGROUND-COLOR.
* BEFORE TIME.
* BASED.
* BEEP.
* BELL.
* BLANK.
* BLANK WHEN ZERO.
* BLINK.
* COLUMN.
* CONSTANT.
* DEFAULT.
* EMPTY-CHECK.
* ERASE.
* EXTERNAL.
* FALSE.
* FOREGROUND-COLOR.
* FROM.
* FULL.
* GLOBAL.
* GROUP INDICATE.
* HIGHLIGHT.
* JUSTIFIED.
* LEFTLINE.
* LENGTH-CHECK.
* LINE.
* LOWER.
* LOWLIGHT.
* NEXT GROUP.
* NO-ECHO.
* NO UPDATE.
* OCCURS.
* OVERLINE.
* PICTURE.
* PRESENT WHEN.
* PROMPT.
* PROTECTED.
* REDEFINES.
* RENAMES.
* REQUIRED.
* REVERSE-VIDEO.
* SAME AS.
* SCROLL DOWN.
* SCROLL UP.
* SECURE.
* SIGN.
* SIZE.
* SOURCE.
* SPECIAL-NAMES.
* SUM.
* SYNCHRONIZED.
* TIME OUT
* TO.
* TYPE.
* TYPEDEF.
* UNDERLINE.
* UPDATE.
* UPPER.
* USAGE.
* USING.
* VALUE.



File: gnucobpg.info,  Node: ANY LENGTH,  Next: ANY NUMERIC,  Up: Data Description Clauses

6.9.1 ANY LENGTH
----------------

                      ANY LENGTH Attribute Syntax
=======================================================================

 ANY LENGTH
 ~~~ ~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘LINKAGE’

   Data items declared with the ‘ANY LENGTH’ attribute have no fixed
compile-time length.  Such items may only be defined in the linkage
section of a subprogram as they may only serve as subroutine argument
descriptions.  These items must have a ‘PICTURE’ (*note PICTURE::)
clause that specifies exactly one A, X, U or 1 symbol.
  1. The ‘ANY LENGTH’ and ‘BASED’ (*note BASED::) clauses cannot be used
     together in the same data item description.  The ‘ANY LENGTH’
     clause specifies that the length of the data item will be
     determined at runtime, the type is determined (and someday checked
     with EC-PROGRAM-ARGS) by the picture symbol.

     They are determined by checking the caller's definition, which
     therefore MUST be either a GnuCOBOL module or a C program that uses
     api functions to create COBOL fields.



File: gnucobpg.info,  Node: ANY NUMERIC,  Next: AUTO,  Prev: ANY LENGTH,  Up: Data Description Clauses

6.9.2 ANY NUMERIC
-----------------

                     ANY NUMERIC Attribute Syntax
=======================================================================

 ANY NUMERIC
 ~~~ ~~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘LINKAGE’

   Data items declared with the ‘ANY NUMERIC’ attribute has no fixed
compile-time length.  Such items may only be defined in the linkage
section of a subprogram as they may only serve as subroutine argument
descriptions.  These items must have a ‘PICTURE’ (*note PICTURE::)
clause that specifies exactly one 9 symbol.  The ANY NUMERIC clause
specifies that the length and the usage of the data item will be
determined at runtime.

   They are determined by checking the caller's definition, which
therefore MUST be either a GnuCOBOL module or a C program that uses api
functions to create COBOL fields.

  1. The ‘ANY NUMERIC’ and ‘BASED’ (*note BASED::) clauses cannot be
     used together in the same data item description.



File: gnucobpg.info,  Node: AUTO,  Next: AUTO-SKIP,  Prev: ANY NUMERIC,  Up: Data Description Clauses

6.9.3 AUTO
----------

                         AUTO Attribute Syntax
=======================================================================

 AUTO
 ~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   A field whose description includes this attribute will cause the
cursor to automatically advance to the next input-enabled field of a
screen if the field is completely filled with input data.
  1. The ‘AUTO’, ‘AUTO-SKIP’ (*note AUTO-SKIP::) and ‘AUTOTERMINATE’
     (*note AUTOTERMINATE::) clauses are interchangeable, and may not be
     used together in the same data item description.


File: gnucobpg.info,  Node: AUTO-SKIP,  Next: AUTOTERMINATE,  Prev: AUTO,  Up: Data Description Clauses

6.9.4 AUTO-SKIP
---------------

                      AUTO-SKIP Attribute Syntax
=======================================================================

 AUTO-SKIP
 ~~~~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   A field whose description includes this attribute will cause the
cursor to automatically advance to the next input-enabled field of a
screen if the field is completely filled with input data.
  1. The ‘AUTO’ (*note AUTO::), ‘AUTO-SKIP’ and ‘AUTOTERMINATE’ (*note
     AUTOTERMINATE::) clauses are interchangeable, and may not be used
     together in the same data item description.


File: gnucobpg.info,  Node: AUTOTERMINATE,  Next: BACKGROUND-COLOR,  Prev: AUTO-SKIP,  Up: Data Description Clauses

6.9.5 AUTOTERMINATE
-------------------

                    AUTOTERMINATE Attribute Syntax
=======================================================================

 AUTOTERMINATE
 ~~~~~~~~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   A field whose description includes this attribute will cause the
cursor to automatically advance to the next input-enabled field of a
screen if the field is completely filled with input data.
  1. The ‘AUTO’ (*note AUTO::), ‘AUTO-SKIP’ (*note AUTO-SKIP::) and
     ‘AUTOTERMINATE’ clauses are interchangeable, and may not be used
     together in the same data item description.


File: gnucobpg.info,  Node: BACKGROUND-COLOR,  Next: BEFORE TIME,  Prev: AUTOTERMINATE,  Up: Data Description Clauses

6.9.6 BACKGROUND-COLOR
----------------------

                   BACKGROUND-COLOR Attribute Syntax
=======================================================================

 BACKGROUND-COLOR|BACKGROUND-COLOUR IS integer-1 | identifier-1
 ~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   This clause is used to specify the screen background color of the
screen data item or the default screen background color of subordinate
items if used on a group item.
  1. The reserved word ‘IS’ is optional and may be omitted.  The
     presence or absence of this word has no effect upon the program.

  2. The reserved words ‘BACKGROUND-COLOR’ and ‘BACKGROUND-COLOUR’ are
     interchangeable.

  3. You specify colors by number (0-7), or by using the constant names
     provided in the ‘screenio.cpy’ copybook (provided with all GnuCOBOL
     source distributions).

  4. Colors may also be specified using a numeric non-edited identifier
     whose value is in the range 0-7.

   For composite ‘DISPLAY’'s, the attributes are always only applied to
the previous source-item but the following also allows a change by
variable or literal i.e.

DISPLAY "Name: "   BACKGROUND-COLOR COB-YELLOW
         NAME-VAR  BACKGROUND-COLOR COB-BLACK
END-DISPLAY

   *Note Color Palette and Video Attributes::, for more information on
screen colors and video attributes.



File: gnucobpg.info,  Node: BEFORE TIME,  Next: BASED,  Prev: BACKGROUND-COLOR,  Up: Data Description Clauses

6.9.7 BEFORE TIME
-----------------

                     BEFORE TIME Attribute Syntax
=======================================================================

BEFORE TIME  {identifier-1 }
       ~~~~  {literal-1    }


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   This clause is functionally the same as the ‘TIMEOUT’ clause.  The
value of identifier-1 or literal-1 specifies the length of time before
automatically terminating the ACCEPT statement when no data is entered
by the user.



File: gnucobpg.info,  Node: BASED,  Next: BEEP,  Prev: BEFORE TIME,  Up: Data Description Clauses

6.9.8 BASED
-----------

                        BASED Attribute Syntax
=======================================================================

 BASED
 ~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘WORKING-STORAGE’,
‘LOCAL-STORAGE’, ‘LINKAGE’

   Data items declared with ‘BASED’ are allocated no storage at
compilation time.  At run-time, the ‘ALLOCATE’ (*note ALLOCATE::) or
‘SET ADDRESS’ (*note SET ADDRESS::) statements are used to allocate
space for and (optionally) initialize such items.
  1. The ‘BASED’ and ‘ANY LENGTH’ (*note ANY LENGTH::) clauses cannot be
     used together in the same data item description.

  2. The ‘BASED’ clause may only be used on level 01 and level 77 data
     items.


File: gnucobpg.info,  Node: BEEP,  Next: BELL,  Prev: BASED,  Up: Data Description Clauses

6.9.9 BEEP
----------

                         BEEP Attribute Syntax
=======================================================================

 BEEP
 ~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

  1. The ‘BEEP’ and ‘BELL’ (*note BELL::) clauses are interchangeable,
     and may not be used together in the same data item description.

  2. Use this clause to cause an audible tone to occur when the screen
     item is ‘DISPLAY’ed.


File: gnucobpg.info,  Node: BELL,  Next: BLANK,  Prev: BEEP,  Up: Data Description Clauses

6.9.10 BELL
-----------

                         BELL Attribute Syntax
=======================================================================

 BELL
 ~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’
  1. The ‘BEEP’ (*note BEEP::) and ‘BELL’ clauses are interchangeable,
     and may not be used together in the same data item description.

  2. Use this clause to cause an audible tone to occur when the screen
     item is ‘DISPLAY’ed.


File: gnucobpg.info,  Node: BLANK,  Next: BLANK WHEN ZERO,  Prev: BELL,  Up: Data Description Clauses

6.9.11 BLANK
------------

                        BLANK Attribute Syntax
=======================================================================

 BLANK LINE|SCREEN
 ~~~~~ ~~~~ ~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   This clause will blank out either the entire screen (‘BLANK SCREEN’)
or just the line upon which data is about to be displayed (‘BLANK
LINE’).
  1. Blanked-out areas will have their foreground and background colors
     set to the attributes of the field containing the ‘BLANK’ clause.

  2. This clause is useful when one screen section item is being
     displayed over the top of a previously-displayed one.


File: gnucobpg.info,  Node: BLANK WHEN ZERO,  Next: BLINK,  Prev: BLANK,  Up: Data Description Clauses

6.9.12 BLANK WHEN ZERO
----------------------

                   BLANK-WHEN-ZERO Attribute Syntax
=======================================================================

 BLANK WHEN ZERO
 ~~~~~      ~~~~


=======================================================================
   This syntax is valid in the following sections: ‘FILE’,
‘WORKING-STORAGE’, ‘LOCAL-STORAGE’, ‘LINKAGE’, ‘REPORT’, ‘SCREEN’

   This clause will cause that item's value to be automatically
transformed into spaces if a value of 0 is ever ‘MOVE’d to the item.
  1. The reserved word ‘WHEN’ is optional and may be omitted.  The
     presence or absence of this word has no effect upon the program.

  2. This clause may only be used on a ‘PIC 9’ data item with a ‘USAGE’
     (*note USAGE::) of ‘DISPLAY’.


File: gnucobpg.info,  Node: BLINK,  Next: COLUMN,  Prev: BLANK WHEN ZERO,  Up: Data Description Clauses

6.9.13 BLINK
------------

                        BLINK Attribute Syntax
=======================================================================

 BLINK
 ~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   The ‘BLINK’ clause modifies the visual appearance of the displayed
field by making the field contents blink.

   *Note Color Palette and Video Attributes::, for more information on
screen colors and video attributes.


File: gnucobpg.info,  Node: COLUMN,  Next: CONSTANT,  Prev: BLINK,  Up: Data Description Clauses

6.9.14 COLUMN
-------------

                 COLUMN (REPORT SECTION) Clause Syntax
=======================================================================

 { COLUMN } [ NUMBER  ] [ LEFT   ] [ IS  ] { [ +|PLUS ] integer-1 }
 { ~~~~~~ } [ NUMBERS ] [ ~~~~   ] [ ARE ] {     ~~~~             }
 { COL    }             [ RIGTH  ]         { {integer-2 } ...     }
 { ~~~    }             [ ~~~~~  ]
 { COLUMNS}             [ CENTER ]
 { ~~~~~~~}             [ ~~~~~~ ]
 { COLS   }
 { ~~~~   }



=======================================================================
                 COLUMN (SCREEN SECTION) Clause Syntax
=======================================================================

 COLUMN NUMBER IS [ { +|PLUS  } ] integer-2 | identifier-3
 ~~~              [ {   ~~~~  } ]
                  [ { -|MINUS } ]
                  [ {   ~~~~~ } ]


=======================================================================
   This syntax is valid in the following sections: ‘REPORT’, ‘SCREEN’

   The ‘COLUMN’ clause provides the means of stating in which column a
field should be presented on the console window (screen section) or a
report (report section).
  1. The reserved words ‘ARE’, ‘IS’, ‘NUMBER’ and ‘NUMBERS’ are optional
     and may be omitted.  The presence or absence of these words has no
     effect upon the program.

  2. The reserved word ‘COLUMN’ may be abbreviated as ‘COL’.

  3. The line location of a report section or screen section field will
     be determined by the ‘LINE’ (*note LINE::) clause.

  4. The value of INTEGER-1 must be 1 or greater.

  5. If IDENTIFIER-1 is used to specify either an absolute or relative
     column position, IDENTIFIER-1 must be defined as a numeric item of
     any ‘USAGE’ (*note USAGE::) other than ‘COMPUTATIONAL-1’ or
     ‘COMPUTATIONAL-2’, without editing symbols.  The value of
     IDENTIFIER-1 at the time the screen data item is presented must be
     1 or greater.  Note that a ‘COMPUTATIONAL-1’ or ‘COMPUTATIONAL-2’
     identifier will be accepted by the compiler, but will produce
     unpredictable results at run-time.

  6. The column coordinate of a field may be stated on an absolute basis
     (i.e.  ‘COLUMN 5’) or on a relative basis based upon the end of the
     previously-presented field (i.e.  ‘COLUMN PLUS 1’).

  7. The symbol ‘+’ may be used in lieu of the word ‘PLUS’, if desired;
     if symbol ‘+’ is used, however, there must be at least one space
     separating it from INTEGER-1.  Failure to include this space will
     cause the symbol ‘+’ sign to be simply treated as part of INTEGER-1
     and will treat the ‘COLUMN’ clause as an absolute column
     specification rather than a relative one.

  8. Using relative column positioning (‘COLUMN PLUS’) has slightly
     different behaviour depending upon the section in which the clause
     is used, as follows:
       A. When used on a report section data item, ‘COLUMN PLUS’ will
          position the start of the new field's value such that there
          are INTEGER-1 blank columns between the end of the previous
          field and the beginning of this field.

          If a report data item's description includes the ‘SOURCE’
          (*note SOURCE::), ‘SUM’ (*note SUM::) or ‘VALUE’ (*note
          VALUE::) clause but has no ‘COLUMN’ clause, ‘COLUMN PLUS 1’
          will be assumed.

       B. When used on a screen section data item, ‘COLUMN PLUS’ will
          position the new field so that it begins exactly INTEGER-1 or
          IDENTIFIER-1 characters past the last character of the
          previous field.  Thus, ‘COLUMN PLUS 1’ will leave no blank
          positions between the end of the previous field and the start
          of this one.

          If a screen data item's description includes the ‘FROM’ (*note
          FROM::), ‘TO’ (*note TO::), ‘USING’ (*note USING::) or ‘VALUE’
          (*note VALUE::) clause but has no ‘COLUMN’ clause, the new
          screen field will begin at the column coordinate of the last
          character of the previous field.


File: gnucobpg.info,  Node: CONSTANT,  Next: DEFAULT,  Prev: COLUMN,  Up: Data Description Clauses

6.9.15 CONSTANT
---------------

                       CONSTANT Attribute Syntax
=======================================================================

 CONSTANT
 ~~~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘FILE’,
‘WORKING-STORAGE’, ‘LOCAL-STORAGE’, ‘LINKAGE’, ‘SCREEN’

   This option signifies that the 01-level data item in whose
declaration ‘CONSTANT’ is specified will be treated as a symbolic name
for a literal value, usable wherever a literal of the appropriate type
could be used.
  1. The value of a data item defined as a constant cannot be changed at
     run-time.  In fact, it is not syntactically acceptable to use such
     a data item as the destination field of any procedure division
     statement that stores a value.

  2. *Note 01-Level Constants::, for additional information.



File: gnucobpg.info,  Node: DEFAULT,  Next: EMPTY-CHECK,  Prev: CONSTANT,  Up: Data Description Clauses

6.9.16 DEFAULT
--------------

                       DEFAULT Attribute Syntax
=======================================================================

DEFAULT
~~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   The ‘DEFAULT’ clause will display the existing data before allowing
user to update it.DEFAULT clause is synonymous with the ‘UPDATE’
clause).



File: gnucobpg.info,  Node: EMPTY-CHECK,  Next: ERASE,  Prev: DEFAULT,  Up: Data Description Clauses

6.9.17 EMPTY-CHECK
------------------

                     EMPTY-CHECK Attribute Syntax
=======================================================================

 EMPTY-CHECK
 ~~~~~~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   This clause forces the user to enter data into the field it is
specified on (or into all subordinate input-capable fields if
‘EMPTY-CHECK’ is specified on a group item).
  1. The ‘EMPTY-CHECK’ and ‘REQUIRED’ (*note REQUIRED::) clauses are
     interchangeable, and may not be used together in the same data item
     description.

  2. In order to take effect, the user must first move the cursor into
     the field having this clause in its definition.

  3. The ‘ACCEPT data-item’ statement (*note ACCEPT data-item::) will
     ignore the Enter key and any other cursor-moving keystrokes that
     would cause the cursor to move to another screen item unless data
     has been entered into the field.  Function keys will still be
     allowed to terminate the ‘ACCEPT’.

  4. In order to be functional, this attribute must be supported by the
     underlying "curses" package your GnuCOBOL implementation was built
     with.  As of this time, the "PDCurses" package (used for native
     Windows or MinGW builds) does not support ‘EMPTY-CHECK’.


File: gnucobpg.info,  Node: ERASE,  Next: EXTERNAL,  Prev: EMPTY-CHECK,  Up: Data Description Clauses

6.9.18 ERASE
------------

                          ERASE Clause Syntax
=======================================================================

 ERASE EOL|EOS
 ~~~~~ ~~~ ~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   ‘ERASE’ will blank-out screen contents from the location where the
screen data item whose description contains this clause will be
displayed, forward until the end of the screen (‘ERASE EOS’)
  1. Erased areas will have their foreground and background colors set
     to the attributes of the field containing the ‘ERASE’ clause.

  2. This clause is useful when one screen section item is being
     displayed over the top of a previously-displayed one.

   *Note Color Palette and Video Attributes::, for more information on
screen colors and video attributes.


File: gnucobpg.info,  Node: EXTERNAL,  Next: FALSE,  Prev: ERASE,  Up: Data Description Clauses

6.9.19 EXTERNAL
---------------

                       EXTERNAL Attribute Syntax
=======================================================================

 EXTERNAL
 ~~~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘FILE’,
‘WORKING-STORAGE’, ‘LOCAL-STORAGE’

   This clause marks a data item description, ‘FD’ or ‘SD’ *note
File/Sort-Description:: as being shareable with other programs executed
from the same execution thread.
  1. By specifying the ‘EXTERNAL’ clause on either an ‘FD’ or an ‘SD’,
     the file description is capable of being shared between all
     programs executed from the same execution thread, provided an
     ‘EXTERNAL’ clause is coded with the file's description in each
     program requiring it.  This sharing allows the file to be opened,
     read and/or written and closed in different programs.  This sharing
     applies to the record descriptions subordinate to the file
     description too.

  2. By specifying the ‘EXTERNAL’ clause on the description of a data
     item, the data item is capable of being shared between all programs
     executed from the same execution thread, provided the data item is
     coded (with an ‘EXTERNAL’ clause) in each program requiring it.

  3. The following points apply to the specification of ‘EXTERNAL’ in a
     data item's definition:
       A. The ‘EXTERNAL’ clause may only be specified at the 77 or 01
          level.

       B. An ‘EXTERNAL’ item must have a data name and that name cannot
          be ‘FILLER’.

       C. ‘EXTERNAL’ cannot be combined with ‘BASED’ (*note BASED::),
          ‘GLOBAL’ (*note GLOBAL::) or ‘REDEFINES’ (*note REDEFINES::).


File: gnucobpg.info,  Node: FALSE,  Next: FOREGROUND-COLOR,  Prev: EXTERNAL,  Up: Data Description Clauses

6.9.20 FALSE
------------

                          FALSE Clause Syntax
=======================================================================

 WHEN SET TO FALSE IS literal-1
             ~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘FILE’,
‘WORKING-STORAGE’, ‘LOCAL-STORAGE’, ‘LINKAGE’, ‘REPORT’, ‘SCREEN’

   This clause, which may only appear on the definition of a level-88
condition name, is used to specify the value of the data item that
serves as the parent of the level-88 condition name that will force the
condition name to assume a value of ‘FALSE’.
  1. The reserved words ‘IS’, ‘SET’, ‘TO’ and ‘WHEN’ are optional and
     may be omitted.  The presence or absence of these words has no
     effect upon the program.

  2. *Note 88-Level Data Items::, or *Note Condition Names::, for more
     information.


File: gnucobpg.info,  Node: FOREGROUND-COLOR,  Next: FROM,  Prev: FALSE,  Up: Data Description Clauses

6.9.21 FOREGROUND-COLOR
-----------------------

                   FOREGROUND-COLOR Attribute Syntax
=======================================================================

 FOREGROUND-COLOR|FOREGROUND-COLOUR IS integer-1 | identifier-1
 ~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   This clause is used to specify the color of text within a screen data
item or the default text color of subordinate items if used on a group
item.
  1. The reserved word ‘IS’ is optional and may be omitted.  The
     presence or absence of this word has no effect upon the program.

  2. The reserved words ‘FOREGROUND-COLOR’ and ‘FOREGROUND-COLOUR’ are
     interchangeable.

  3. You specify colors by number (0-7), or by using the constant names
     provided in the ‘screenio.cpy’ copybook (which is provided with all
     GnuCOBOL source distributions).

  4. Colors may also be specified using a numeric non-edited identifier
     whose value is in the range 0-7.

   *Note Color Palette and Video Attributes::, for more information on
screen colors and video attributes.


File: gnucobpg.info,  Node: FROM,  Next: FULL,  Prev: FOREGROUND-COLOR,  Up: Data Description Clauses

6.9.22 FROM
-----------

                          FROM Clause Syntax
=======================================================================

 FROM literal-1 | identifier-5
 ~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   This clause is used to specify either the data item a screen section
field is to obtain its value from when the screen is displayed, or a
literal that will specify the value of that same field.
  1. The ‘FROM’, ‘TO’ (*note TO::), ‘USING’ (*note USING::) and ‘VALUE’
     (*note VALUE::) clauses are mutually-exclusive in any screen
     section data item's definition.


File: gnucobpg.info,  Node: FULL,  Next: GLOBAL,  Prev: FROM,  Up: Data Description Clauses

6.9.23 FULL
-----------

                         FULL Attribute Syntax
=======================================================================

 FULL
 ~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   The ‘FULL’ clause forces the user to enter data into the field it is
specified on (or into all subordinate input-capable fields if specified
on a group item) sufficient to fill every character position of the
field.
  1. The ‘FULL’ and ‘LENGTH-CHECK’ (*note LENGTH-CHECK::) clauses are
     interchangeable, and may not be used together in the same data item
     description.

  2. In order for this clause to take effect at execution time, the user
     must move the cursor into the field having this clause in its
     definition.

  3. The ‘ACCEPT data-item’ statement (*note ACCEPT data-item::) will
     ignore the Enter key and any other cursor-moving keystrokes that
     would cause the cursor to move to another screen item unless the
     proper amount of data has been entered into the field.  Function
     keys will still be allowed to terminate the ‘ACCEPT’, however.

  4. In order to be functional, this attribute must be supported by the
     underlying "curses" package your GnuCOBOL implementation was built
     with.  As of this time, the "PDCurses" package (used for native
     Windows or MinGW builds) does not support ‘FULL’.


File: gnucobpg.info,  Node: GLOBAL,  Next: GROUP INDICATE,  Prev: FULL,  Up: Data Description Clauses

6.9.24 GLOBAL
-------------

                        GLOBAL Attribute Syntax
=======================================================================

 GLOBAL
 ~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘FILE’,
‘WORKING-STORAGE’, ‘LOCAL-STORAGE’, ‘REPORT’

   This clause marks a data item, 01-level constant, ‘FD’ (*note
File/Sort-Description::), ‘SD’ (*note File/Sort-Description::) or an
‘RD’ (*note REPORT SECTION::) as being shareable with any nested
subprograms.
  1. By specifying the ‘GLOBAL’ clause on the description of a file or a
     report, that description is capable of being shared between a
     program and any nested subprograms within it, provided the ‘FD’,
     ‘SD’ or ‘RD’ is coded (with a ‘GLOBAL’ clause) in each nested
     subprogram requiring it.  This sharing allows the file to be
     opened, read and/or written and closed or the report to be
     initiated or terminated in those programs.  Separately compiled
     programs may not share a ‘GLOBAL’ file description, but they may
     share an ‘EXTERNAL’ (*note EXTERNAL::) file description.  This
     sharing applies to the record descriptions subordinate to the file
     description and the report groups subordinate to the ‘RD’ also.

  2. By specifying the ‘GLOBAL’ clause on the description of a data
     item, the data item is capable of being shared between a program
     and any nested subprograms within it, provided the data item is
     coded (with a ‘GLOBAL’ clause) in each program requiring it.

  3. The following points apply to the specification of ‘GLOBAL’ in a
     data item's definition:
       A. The ‘GLOBAL’ clause may only be specified at the 77 or 01
          level.

       B. A ‘GLOBAL’ item must have a data name and that name cannot be
          ‘FILLER’.

       C. ‘GLOBAL’ cannot be combined with ‘EXTERNAL’ (*note
          EXTERNAL::), ‘REDEFINES’ (*note REDEFINES::) or ‘BASED’ (*note
          BASED::).


File: gnucobpg.info,  Node: GROUP INDICATE,  Next: HIGHLIGHT,  Prev: GLOBAL,  Up: Data Description Clauses

6.9.25 GROUP INDICATE
---------------------

                    GROUP-INDICATE Attribute Syntax
=======================================================================

 GROUP INDICATE
 ~~~~~ ~~~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘REPORT’

   The ‘GROUP INDICATE’ clause specifies that the data item in whose
definition the clause appears will be presented only in very limited
circumstances.
  1. This clause may only appear within a ‘DETAIL’ report group (*note
     TYPE::).

  2. When this clause is present, the data item in question will be
     presented only under the following circumstances:
       A. On the first presentation of the detail group following the
          ‘INITIATE’ (*note INITIATE::) of the report.

       B. On the first presentation of the detail group after every new
          page is started.

       C. On the first presentation of the detail group after any
          control break occurs.


File: gnucobpg.info,  Node: HIGHLIGHT,  Next: JUSTIFIED,  Prev: GROUP INDICATE,  Up: Data Description Clauses

6.9.26 HIGHLIGHT
----------------

                      HIGHLIGHT Attribute Syntax
=======================================================================

 HIGHLIGHT
 ~~~~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   This clause controls the intensity of text (‘FOREGROUND-COLOR’ (*note
FOREGROUND-COLOR::)) by setting that intensity to its highest of three
possible settings.
  1. This clause, along with ‘LOWLIGHT’ (*note LOWLIGHT::), are intended
     to provide a three-level intensity scheme (‘LOWLIGHT’ ... nothing
     (Normal) ... ‘HIGHLIGHT’).

   *Note Color Palette and Video Attributes::, for more information on
screen colors and video attributes.


File: gnucobpg.info,  Node: JUSTIFIED,  Next: LEFTLINE,  Prev: HIGHLIGHT,  Up: Data Description Clauses

6.9.27 JUSTIFIED
----------------

                      JUSTIFIED Attribute Syntax
=======================================================================

 JUSTIFIED RIGHT
 ~~~~


=======================================================================
   This syntax is valid in the following sections: ‘FILE’,
‘WORKING-STORAGE’, ‘LOCAL-STORAGE’, ‘LINKAGE’, ‘REPORT’, ‘SCREEN’

   The presence of a ‘JUSTIFIED RIGHT’ clause in a data item's
definition alters the manner in which data is stored into the field from
the default 'left-justified, space filled' behaviour to 'right
justified, space filled'.  Unless you are using any of the IBM dialects,
it has NO effect on the initial content of a variable, eg:
01  A PIC X(12) JUST RIGHT VALUE 'ABC'.

Will show content as 'ABC' with NO justification taken place.

  1. The reserved word ‘RIGHT’ is optional and may be omitted.  The
     presence or absence of this word has no effect upon the program.

  2. The reserved word ‘JUSTIFIED’ may be abbreviated as ‘JUST’.

  3. This clause is valid only on alphabetic (‘PIC A’) or alphanumeric
     (‘PIC X’) data items.

  4. The presence or absence of this clause influences the behaviour of
     the ‘MOVE’ (*note MOVE::) statement as well as the ‘FROM’ (*note
     FROM::), ‘SOURCE’ (*note SOURCE::) and ‘USING’ (*note USING::) data
     item description clauses.

  5. If the value being stored into the field is the same length as the
     receiving field, the presence or absence of the ‘JUSTIFIED RIGHT’
     clause on that field's description is irrelevant.

  6. The following examples illustrate the behaviour of the presence and
     absence of the ‘JUSTIFIED RIGHT’ clause when the field size is
     different than that of the value being stored.  In these examples,
     the symbol b represents a space.

     When the value is shorter than the field size:

     Without ‘JUSTIFIED’                  With ‘JUSTIFIED’
     --------------------------------------------------------------------------
     01  A PIC X(6).                      01  A PIC X(6) JUSTIFIED RIGHT.
     MOVE 'ABC' TO A                      MOVE 'ABC' TO A

     Result                               Result
     --------------------------------------------------------------------------
     ‘ABCBBB’                             ‘BBBABC’

     When the value is longer than the field size:

     Without ‘JUSTIFIED’                  With ‘JUSTIFIED’
     --------------------------------------------------------------------------
     01  A PIC X(6).                      01  A PIC X(6) JUSTIFIED RIGHT.
     MOVE 'ABCDEFGHI' TO A                MOVE 'ABCDEFGHI' TO A

     Result                               Result
     --------------------------------------------------------------------------
     ‘ABCDEF’                             ‘DEFGHI’


File: gnucobpg.info,  Node: LEFTLINE,  Next: LENGTH-CHECK,  Prev: JUSTIFIED,  Up: Data Description Clauses

6.9.28 LEFTLINE
---------------

                       LEFTLINE Attribute Syntax
=======================================================================

 LEFTLINE
 ~~~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   The ‘LEFTLINE’ clause will introduce a vertical line at the left edge
of a screen field.
  1. The ‘LEFTLINE’, ‘OVERLINE’ (*note OVERLINE::) and ‘UNDERLINE’
     (*note UNDERLINE::) clauses may be used in any combination in a
     single field's description.

  2. This clause is essentially non-functional when used within Windows
     command shell (cmd.exe) environments and running programs compiled
     using a GnuCOBOL implementation built using "PDCurses" (such as
     Windows/MinGW builds).

  3. Whether or not this clause operates on Cygwin or UNIX/Linux/OSX
     systems will depend upon the video attribute capabilities of the
     terminal output drivers and "curses" software being used.

   *Note Color Palette and Video Attributes::, for more information on
screen colors and video attributes.


File: gnucobpg.info,  Node: LENGTH-CHECK,  Next: LINE,  Prev: LEFTLINE,  Up: Data Description Clauses

6.9.29 LENGTH-CHECK
-------------------

                     LENGTH-CHECK Attribute Syntax
=======================================================================

 LENGTH-CHECK
 ~~~~~~~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   The ‘LENGTH-CHECK’ clause forces the user to enter data into the
field it is specified on (or into all subordinate input-capable fields
if specified on a group item) sufficient to fill every character
position of the field.
  1. The ‘FULL’ (*note FULL::) and ‘LENGTH-CHECK’ clauses are
     interchangeable, and may not be used together in the same data item
     description.

  2. In order for this clause to take effect at execution time, the user
     must move the cursor into the field having this clause in its
     definition.

  3. The ‘ACCEPT data-item’ statement (*note ACCEPT data-item::) will
     ignore the Enter key and any other cursor-moving keystrokes that
     would cause the cursor to move to another screen item unless the
     proper amount of data has been entered into the field.  Function
     keys will still be allowed to terminate the ‘ACCEPT’, however.

  4. In order to be functional, this attribute must be supported by the
     underlying "curses" package your GnuCOBOL implementation was built
     with.  As of this time, the "PDCurses" package (used for native
     Windows or MinGW builds) does not support ‘LENGTH-CHECK’.


File: gnucobpg.info,  Node: LINE,  Next: LOWER,  Prev: LENGTH-CHECK,  Up: Data Description Clauses

6.9.30 LINE
-----------

                  LINE (REPORT SECTION) Clause Syntax
=======================================================================

{ LINE    [ NUMBER  ]  [ IS  ] }  { integer-2 [ [ ON NEXT PAGE ] }
{ ~~~~~~  [ NUMBERS ]  [ ARE ] }  {                  ~~~~ ~~~~   }
{ LINES ARE                    }  { +|PLUS integer-2             } ...
{ ~~~                          }  {   ~~~~                       }
                                  { ON NEXT PAGE                 }
                                      ~~~~ ~~~~


=======================================================================
                  LINE (SCREEN SECTION) Clause Syntax
=======================================================================

  LINE NUMBER IS [ { +|PLUS  } ] integer-4 | identifier-6
  ~~~            [ {   ~~~~  } ]
                 [ { -|MINUS } ]
                 [ {   ~~~~~ } ]


=======================================================================
   This syntax is valid in the following sections: ‘REPORT’, ‘SCREEN’

   This clause provides a means of explicitly stating on which line a
field should be presented on the console window (screen section) or on a
report (report section).
  1. The reserved words ‘IS’, ‘NUMBER’ and ‘ON’ are optional and may be
     omitted.  The presence or absence of these words has no effect upon
     the program.

  2. The following points document the use of format 1 of the ‘LINE’
     clause:
       A. The column location of a report item will be determined by the
          ‘COLUMN’ (*note COLUMN::) clause.

       B. The value of INTEGER-1 must be 1 or greater.

       C. The report line number upon which the data item containing
          this clause along with any subordinate data items will be
          presented may be stated on an absolute basis (i.e.  ‘LINE 5’)
          or on a relative basis based upon the previously-displayed
          line (i.e.  ‘LINE PLUS 1’).

       D. The symbol ‘+’ may be used in lieu of the word ‘PLUS’, if
          desired; if ‘+’ is used, however, there must be at least one
          space separating it from INTEGER-1.  Failure to include this
          space will cause the ‘+’ to be simply treated as part of
          INTEGER-1 and will treat the LINE clause as an absolute line
          specification rather than a relative one.

       E. The optional ‘NEXT PAGE’ clause specifies that -- regardless
          of whether or not the report group containing this clause
          could fit on the report page being currently generated, the
          report group will be forced to appear on a new page.
  3. The following points document the use for format 2 of the ‘LINE’
     clause:
       A. The column location of a screen section field is determined by
          the ‘COLUMN’ (*note COLUMN::) clause.

       B. The value of INTEGER-1 must be 1 or greater.

       C. If IDENTIFIER-1 is used to specify either an absolute or
          relative column position, IDENTIFIER-1 must be defined as a
          numeric item of any ‘USAGE’ (*note USAGE::) other than
          ‘COMPUTATIONAL-1’ or ‘COMPUTATIONAL-2’, without editing
          symbols.  The value of IDENTIFIER-1 at the time the screen
          data item is presented must be 1 or greater.  Note that a
          ‘COMPUTATIONAL-1’ or ‘COMPUTATIONAL-2’ identifier will be
          accepted by the compiler, but will produce unpredictable
          results at run-time.

       D. The screen line number upon which the data item containing
          this clause along with any subordinate data items will be
          displayed may be stated on an absolute basis (i.e.  ‘LINE 5’)
          or on a relative basis based upon the previously-displayed
          line (i.e.  ‘LINE PLUS 1’).

       E. The symbol ‘+’ may be used in lieu of the word ‘PLUS’, if
          desired; if ‘+’ is used, however, there must be at least one
          space separating it from INTEGER-1.  Failure to include this
          space will cause the ‘+’ to be simply treated as part of
          INTEGER-1 and will treat the ‘LINE’ clause as an absolute line
          specification rather than a relative one.

       F. If a screen data item's description includes the ‘FROM’ (*note
          FROM::), ‘TO’ (*note TO::), ‘USING’ (*note USING::) or ‘VALUE’
          (*note VALUE::) clause but has no LINE clause, the "current
          screen line" will be assumed.


File: gnucobpg.info,  Node: LOWER,  Next: LOWLIGHT,  Prev: LINE,  Up: Data Description Clauses

6.9.31 LOWER
------------

                        LOWER Attribute Syntax
=======================================================================

LOWER
~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   This clause provides a means of explicitly stating that accepted data
will be in lower case.



File: gnucobpg.info,  Node: LOWLIGHT,  Next: NEXT GROUP,  Prev: LOWER,  Up: Data Description Clauses

6.9.32 LOWLIGHT
---------------

                       LOWLIGHT Attribute Syntax
=======================================================================

 LOWLIGHT
 ~~~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   The ‘LOWLIGHT’ clause controls the intensity of text
(‘FOREGROUND-COLOR’) by setting that intensity to its lowest of three
possible settings.
  1. This clause, along with ‘HIGHLIGHT’ (*note HIGHLIGHT::), are
     intended to provide a three-level intensity scheme (‘LOWLIGHT’ ...
     nothing (Normal) ... ‘HIGHLIGHT’).  In environments such as a
     Windows console where only two levels of intensity are supported,
     ‘LOWLIGHT’ is the same as leaving this clause off altogether.

   *Note Color Palette and Video Attributes::, for more information on
screen colors and video attributes.


File: gnucobpg.info,  Node: NEXT GROUP,  Next: NO-ECHO,  Prev: LOWLIGHT,  Up: Data Description Clauses

6.9.33 NEXT GROUP
-----------------

                       NEXT-GROUP Clause Syntax
=======================================================================

 NEXT GROUP IS { [ +|PLUS ] integer-2  }
 ~~~~ ~~~~~    {     ~~~~              }
               { NEXT|{NEXT PAGE}|PAGE }
                 ~~~~  ~~~~ ~~~~  ~~~~


=======================================================================
   This syntax is valid in the following sections: ‘REPORT’

   This clause defines any rules for where the next group to be
presented on a report will begin, line-wise, with respect to the last
line of the group in which this clause appears.
  1. The reserved word ‘IS’ is optional and may be omitted.  The
     presence or absence of this word has no effect upon the program.

  2. The terms ‘NEXT’, ‘NEXT PAGE’ and ‘PAGE’ are interchangeable.

  3. A report group must contain at least one ‘LINE NUMBER’ clause in
     order to also contain a ‘NEXT GROUP’ clause.

  4. If the ‘RD’ (*note REPORT SECTION::) in which the report group
     containing a ‘NEXT GROUP’ clause does not contain a ‘PAGE LIMITS’
     clause, only the ‘PLUS integer-1’ option may be specified.

  5. The ‘NEXT PAGE’ option cannot be used in a ‘PAGE FOOTING’.

  6. The ‘NEXT GROUP’ option cannot be specified in either a ‘REPORT
     HEADING’ or a ‘PAGE HEADING’.

  7. The effects of ‘NEXT GROUP’ will be in addition to any line spacing
     defined by the next-presented group's ‘LINE NUMBER’ clause.


File: gnucobpg.info,  Node: NO-ECHO,  Next: NO UPDATE,  Prev: NEXT GROUP,  Up: Data Description Clauses

6.9.34 NO-ECHO
--------------

                       NO-ECHO Attribute Syntax
=======================================================================

NO-ECHO | NO ECHO | OFF
~~~~~~~   ~~ ~~~~   ~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   The ‘NO-ECHO’ clause will cause all data entered into the field to
appear on the screen as spaces.  The ‘OFF’ clause is the same as the
‘NO-ECHO’ clause (and same of ‘NO ECHO’).

  1. If ‘NO-ECHO’ is present then the ‘PROMPT’ clause is ignored.

  2. If the dialect configuration -fno-echo-means-secure is active all
     data entered into the field will appear on the screen as asterisks.
     In this case the ‘NO-ECHO’ and ‘SECURE’ clauses are
     interchangeable.

  3. The ‘NO-ECHO’ and ‘SECURE’ (*note SECURE::) clauses may not be used
     together in the same data item description.

  4. This clause may only be used on a field allowing data entry (a
     field containing either the ‘USING’ (*note USING::) or ‘TO’ (*note
     TO::) clause).

   *Note Color Palette and Video Attributes::, for more information on
screen colors and video attributes.


File: gnucobpg.info,  Node: NO UPDATE,  Next: OCCURS,  Prev: NO-ECHO,  Up: Data Description Clauses

6.9.35 NO UPDATE
----------------

                      NO-UPDATE Attribute Syntax
=======================================================================

NO UPDATE
~~ ~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   The ‘NO UPDATE’ clause forces the field to which this is applied will
not be updated.



File: gnucobpg.info,  Node: OCCURS,  Next: OVERLINE,  Prev: NO UPDATE,  Up: Data Description Clauses

6.9.36 OCCURS
-------------

                         OCCURS Clause Syntax
=======================================================================


GENERAL FORMAT.

 Format 1 (fixed-table):

 OCCURS integer-2 [ TIMES ]
 ~~~~~~

 Format 2 (occurs-depending-table):

 OCCURS [ integer-1 TO ] { integer-2 [ TIMES ] } DEPENDING ON identifier-1
 ~~~~~~             ~~   { UNBOUNDED           } ~~~~~~~~~

   [ ASCENDING|DESCENDING KEY IS identifier-5 ... ] ...
     ~~~~~~~~~ ~~~~~~~~~~
   [ INDEXED BY index-name-1 ... ]
     ~~~~~~~

 REPORT SECTION.

 Format 3

 OCCURS [ integer-1 TO ] { integer-2 [ TIMES ] } [ DEPENDING ON identifier-1 ]
 ~~~~~~             ~~                             ~~~~~~~~~

   [ STEP integer-3 ]
     ~~~~
   [ VARYING identifier-2 FROM { identifier-3 } BY { identifier-4 } ]
     ~~~~~~~              ~~~~ { integer-4    } ~~ { integer-5    }


 SCREEN SECTION.

 Format 4

 OCCURS integer-2 TIMES
 ~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘FILE’,
‘WORKING-STORAGE’, ‘LOCAL-STORAGE’, ‘LINKAGE’, ‘REPORT’, ‘SCREEN’ but
UNBOUNDED is ONLY for ‘LINKAGE’.

   The ‘OCCURS’ clause is used to create a data structure called a
table, where entries in that structure repeat multiple times.
  1. The reserved words ‘BY’ (INDEXED), ‘IS’, ‘KEY’, ‘ON’ and ‘TIMES’
     are optional and may be omitted.  The presence or absence of these
     words has no effect upon the program.

  2. The reserved word ‘UNBOUNDED’ can be used to specify an unbounded
     table (a table with an unbounded maximum number of occurrences),
     and can be referenced anywhere that a table can be referenced.

  3. An unbounded group is a group that contains at least one unbounded
     table.  It can be specified ONLY in the Linkage Section, and must
     be of type alphanumeric or national.

  4. You can reference unbounded groups in COBOL syntax anywhere that an
     alphanumeric or national group can be referenced, with the
     following exceptions:

     You cannot specify unbounded groups as a BY CONTENT argument in a
     CALL statement.  You cannot specify unbounded groups as data-name-2
     on the Procedure Division RETURNING phrase.  You cannot specify
     unbounded groups as arguments to intrinsic functions, except as an
     argument to the LENGTH intrinsic function.

  5. The value of INTEGER-2 specifies how many entries will be allocated
     in the table.

  6. The following is an example of how a table might be defined:

          05 QUARTERLY-REVENUE OCCURS 4 TIMES PIC 9(7)V99.

     This will allocate the following:

          QUARTERLY-REVENUE(1)
          QUARTERLY-REVENUE(2)
          QUARTERLY-REVENUE(3)
          QUARTERLY-REVENUE(4)

     Each occurrence is referenced using the subscript syntax (a numeric
     literal, arithmetic expression or numeric identifier enclosed
     within parenthesis) shown above.

  7. The ‘OCCURS’ clause may be used at the group level too, in which
     case the entire group structure repeats, as follows:

          05 GRP OCCURS 3 TIMES.
              10 A     PIC X(1).
              10 B     PIC X(1).
              10 C     PIC X(1).

     This would allow references to any of the following:

          GRP(1)   includes A(1), B(1) and C(1)
          GRP(2)   includes A(2), B(2) and C(2)
          GRP(3)   includes A(3), B(3) and C(3)

     or each A,B,C item could be referenced as follows:

          A(1)   character #1 of GRP(1)
          B(1)   character #2 of GRP(1)
          C(1)   character #3 of GRP(1)
          A(2)   character #1 of GRP(2)
          B(2)   character #2 of GRP(2)
          C(2)   character #3 of GRP(2)
          A(3)   character #1 of GRP(3)
          B(3)   character #2 of GRP(3)
          C(3)   character #3 of GRP(3)

  8. The optional ‘DEPENDING ON’ clause can be added to an ‘OCCURS’ to
     create a variable-length table.  In such cases, the value of
     INTEGER-1 specifies what the minimum number of entries in the table
     will be while INTEGER-2 specifies the maximum.  Such tables will be
     allocated out to the maximum size specified as INTEGER-2.  At
     execution time the value of IDENTIFIER-1 will determine how many of
     the table elements are accessible.

  9. See the documentation of the ‘SEARCH’ (*note SEARCH::), ‘SEARCH
     ALL’ (*note SEARCH ALL::) and ‘SORT’ (*note SORT::) statements for
     explanations of the ‘KEY’ and ‘INDEXED BY’ clauses.

  10. The COBOL standard says that the ‘OCCURS’ clause cannot be
     specified in a data description entry that has a level number of
     01, 66, 77, or 88, although it is valid in data items described
     subordinate to an 01 level data item.  GnuCOBOL supports, as a
     extension available in several compilers, the ‘OCCURS’ clause at
     levels 01 and 77.  Depending on -std, this may be downgraded to a
     warning or be without a diagnostic.  Example, -std=ibm-strict and
     -std=cobol2002.

  11. The following points apply to an ‘OCCURS’ used in the report
     section:
       A. The optional ‘STEP’ clause defines an incrementation value
          that will be added to any absolute ‘LINE’ (*note LINE::) or
          ‘COLUMN’ (*note COLUMN::) number specifications that may be
          part of or subordinate to this data item's definition.

       B. The optional ‘VARYING’ clause defines an identifier that may
          be used as a subscript for the multiple occurrences of this or
          any subordinate data item should the ‘SOURCE’ (*note SOURCE::)
          or ‘SUM’ (*note SUM::) clause(s) on this or subordinate data
          items reference entries within the table.  The IDENTIFIER-2
          data item is dynamically created as needed and cannot be
          referenced outside the scope of the report data item
          definition.

       C. The following two examples illustrate two different ways a
          report could include four quarters worth of sales figures in
          its detail lines -- one doing things 'the hard way' and one
          using the advanced ‘OCCURS’ capabilities of ‘STEP’ and
          ‘VARYING’.  Both assume the definition of the following table
          exists in working-storage:

                 05 SALES OCCURS 4 TIMES PIC 9(7)V99.

          First, the "Hard Way":

               10 COL 7  PIC $(7)9.99 SOURCE SALES(1).
               10 COL 17 PIC $(7)9.99 SOURCE SALES(2).
               10 COL 27 PIC $(7)9.99 SOURCE SALES(3).
               10 COL 37 PIC $(7)9.99 SOURCE SALES(4).

          And then using ‘STEP’ and ‘VARYING’:

               10 COL 7  OCCURS 4 TIMES STEP 10 VARYING QTR FROM 1 BY 1
                         PIC $(7)9.99 SOURCE SALES(QTR).


File: gnucobpg.info,  Node: OVERLINE,  Next: PICTURE,  Prev: OCCURS,  Up: Data Description Clauses

6.9.37 OVERLINE
---------------

                       OVERLINE Attribute Syntax
=======================================================================

 OVERLINE
 ~~~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   The ‘OVERLINE’ clause will introduce a horizontal line at the top
edge of a screen field.
  1. The ‘LEFTLINE’ (*note LEFTLINE::), ‘OVERLINE’ and ‘UNDERLINE’
     (*note UNDERLINE::) clauses may be used in any combination in a
     single field's description.

  2. This clause is essentially non-functional when used within Windows
     command shell (cmd.exe) environments and running programs compiled
     using a GnuCOBOL implementation built using "PDCurses" (such as
     Windows/MinGW builds).

  3. Whether or not this clause operates on Cygwin or UNIX/Linux/OSX
     systems will depend upon the video attribute capabilities of the
     terminal output drivers and "curses" software being used.

   *Note Color Palette and Video Attributes::, for more information on
screen colors and video attributes.


File: gnucobpg.info,  Node: PICTURE,  Next: PRESENT WHEN,  Prev: OVERLINE,  Up: Data Description Clauses

6.9.38 PICTURE
--------------

                         PICTURE Clause Syntax
=======================================================================

 PICTURE IS picture-string
 ~~~


=======================================================================
   This syntax is valid in the following sections: ‘FILE’,
‘WORKING-STORAGE’, ‘LOCAL-STORAGE’, ‘LINKAGE’, ‘REPORT’, ‘SCREEN’

   The picture clause defines the class (numeric, alphabetic or
alphanumeric), size and format of the data that may be contained by the
data item being defined.  Sometimes this role is assisted by the ‘USAGE’
(*note USAGE::) clause, and in a few instances will be assumed entirely
by that clause.
  1. The reserved word ‘IS’ is optional and may be omitted.  The
     presence or absence of this word has no effect upon the program.

  2. The reserved word ‘PICTURE’ may be abbreviated as ‘PIC’.  Most
     programmers prefer to use the latter.

  3. A picture clause may only be specified on an elementary item.

  4. A PICTURE-STRING is a sequence of the special symbols ‘$’, ‘*’,
     ‘+’, ‘,’, ‘-’, ‘.’, ‘/’, ‘0’ (zero), ‘1’, ‘9’, ‘A’, ‘B’, ‘CR’,
     ‘DB’, ‘S’, ‘V’, ‘P’, ‘X’ and ‘Z’.

  5. In general, each picture symbol represents either a single
     character in storage or a single decimal digit.  There are a few
     exceptions, and they will be discussed as needed.

  6. When a PICTURE-STRING contains a repeated sequence of symbols --
     ‘PIC 9999/99/99’ -- for example, the repetition can be specified
     using a parenthetic repeat count, as in ‘PIC 9(4)/9(2)/9(2)’.
     Using repeat counts is optional and their use (or not) is entirely
     at the discretion of the programmer.  Many programmers use
     repetition for small sequences (‘PIC XXX’) and repeat counts for
     larger ones (‘PIC 9(9)’.

  7. This first set of picture symbols defines the basic data type of a
     data item.  Each symbol represents a single character's worth of
     storage.
     ‘A’
          Defines storage reserved for a single alphabetic character
          (‘A’-‘Z’, ‘a’-‘z’).

     ‘N’
          Defines storage reserved for a single character in the
          computer's “National Character set”.  Support for national
          character sets in GnuCOBOL is currently only partially
          implemented, and the compile- and run-time effect of using the
          ‘N’ picture symbol is the same as if ‘X(2)’ had been coded,
          with the additional effect that such a field will qualify as a
          ‘NATIONAL’ or ‘NATIONAL-EDITED’ field on an ‘INITIALIZE’
          (*note INITIALIZE::) statement.

     ‘X’
          Defines storage reserved for a single alphanumeric character
          (any character).

     ‘9’
          Defines storage reserved for a single numeric digit character
          (‘0’-‘9’).

     Typically, only one kind of each of those symbols is used in the
     same picture clause, but that isn't a requirement.  Data items
     that, of the three symbols above, use nothing but ‘A’ picture
     symbols are known as “Alphabetic Data Items” while those that use
     ‘9’ picture symbols without any ‘A’ or ‘X’ symbols (or those that
     have a ‘USAGE’ without a ‘PICTURE’) are known as “Numeric Data
     Items”.  All other data items are referred to as “Alphanumeric Data
     Items”.

     If you need to allocate space for a data item whose format is two
     letters followed by five digits followed by three letters, you
     could use the PICTURE-STRING ‘AA99999AAA’, ‘A(2)9(5)A(3)’
     ‘XXXXXXXXXX’ or ‘X(10)’.  There is absolutely no functional
     difference whatsoever between the four -- none of them provide any
     functionality the others do not.  The first two probably make for
     better documentation of the expected field contents, but they don't
     provide any run-time enforcement capabilities.

     As far as enforcement goes, however, both alphabetic and numeric
     picture strings do provide for both compile-time and run-time
     enforcement capabilities.  In the case of compilation enforcement,
     the compiler can issue warning messages if you attempt to specify a
     non-numeric value for a numeric data item or if you attempt to
     ‘MOVE’ (*note MOVE::) a non-numeric data item to one that is
     numeric.  Similar capabilities exist for alphabetic data items.  At
     run-time, you may use a special class test (*note Class
     Conditions::) to determine if the contents of a data item are
     entirely numeric or entirely alphabetic.

  8. ‘1’ Defines storage for a single bit representing a boolean
     condition with a states of zero or 1, condition of off or on.
     Warning the level of implementation of this feature is compiler
     version specific starting with v3.1-RC-1.

  9. The following picture symbols may be used with numeric data items.
     ‘P’
          Defines an implied digit position that will be considered to
          be a zero when the data item is referenced at run-time.  This
          symbol is used to allow data items that will contain very
          large values to be allocated using less storage by assuming a
          certain number of trailing zeros (one per ‘P’) to exist at the
          end of values.

          The ‘P’ symbol is not allowed in conjunction with ‘N’.

          The ‘P’ symbol may only be used at the beginning or end of a
          picture clause.

          ‘P’ is a repeatable symbol.

          All computations and ‘MOVE’ (*note MOVE::) operations
          involving such a data item will behave as if the zeros were
          actually there.

          For example, let's say you need to allocate a data item that
          contains however many millions of dollars of revenue your
          company has in gross revenues this year:

          01 Gross-Revenue PIC 9(9).

          In which case 9 characters of storage will be reserved.  The
          values 000000000 through 999999999 will represent the
          gross-revenues.  But, if only the millions are tracked
          (meaning the last six digits are always going to be 0), you
          could define the field as:

          01 Gross-Revenue PIC 9(3)P(6).

          Whenever Gross-Revenue is referenced in calculations, or
          whenever its value is moved to another data item, the value of
          Gross-Revenue will be treated as if it is ‘NNN000000’, where
          ‘NNN’ is the actual value in storage.

          If you wanted to store the value 128 million into that field,
          you would do so as if the ‘P’s were ‘9’s:

               MOVE 128000000 TO Gross-Revenue

          A ‘DISPLAY’ (*note DISPLAY::) of a data item containing ‘P’
          symbols is a little strange.  The value displayed will be what
          is actually in storage, but the total size of the displayed
          value will be as if the ‘P’ symbols had been ‘9’s.  Thus,
          after the above statement established a value for
          Gross-Revenue, a ‘DISPLAY Gross-Revenue’ would produce output
          of ‘128000000’.  This is the actual three characters stored
          with six zeros appended.

     ‘S’
          This symbol, if used, must be the very first symbol in the
          ‘PICTURE’ value.  A ‘S’ indicates that the data item is
          ‘Signed’, meaning that negative values are possible for this
          data item.  Without an ‘S’, any negative values stored into
          this data item via a ‘MOVE’ or arithmetic statement will have
          the negative sign stripped from it (in effect becoming the
          absolute value).

          The ‘S’ symbol is not allowed in conjunction with ‘N’.

          The ‘S’ symbol may only occur once in a picture string.  *Note
          SIGN IS::, for further discussion of how negative values may
          be stored in a numeric data item.

     ‘V’
          This symbol is used to define where an implied decimal-point
          (if any) is located in a numeric item.  Just as there may only
          be a single decimal point in a number so may there be no more
          than one ‘V’ in a ‘PICTURE’.  Implied decimal points occupy no
          space in storage -- they just specify how values are used.
          For example, if the value ‘1234’ is in storage in a field
          defined as ‘PIC 999V9’, that value would be treated as 123.4
          in any statements that referenced it.

          The ‘V’ symbol is not allowed in conjunction with ‘N’.

          The ‘V’ symbol may only occur once in a picture string.

  10. Any editing symbols introduced past this point will, if coded in
     the picture clause of an otherwise numeric data item, transform
     that data item from a numeric to a “Numeric Edited” data item.
     Numeric edited data items are treated as alphanumeric and may not
     serve either as table subscripts or as source arguments on an
     arithmetic statement.

  11. The following are the fixed insertion editing symbols that may be
     specified in a picture string.  Each of these editing symbols will
     insert a special character into the field value at the position it
     is specified in the picture string.  These editing symbols will
     each introduce one extra character into the total field size for
     each occurrence of the symbol in the picture string.

     ‘B’
          The ‘B’ editing symbol introduces a blank into the field value
          for each occurrence.

          Multiple ‘B’ symbols may be coded.

          The following example will format a ten digit number
          (presumably a telephone number) into a ‘### ### ####’ layout:
              ...
                  05 Phone-Number       PIC 9(3)B9(3)B9(4).
              ...
                  MOVE 5185551212 TO Phone-Number
                  DISPLAY Phone-Number

          This code will display ‘518 555 1212’.

     ‘0’
          The ‘0’ (zero) editing symbol introduces one "0" character
          into the field value for each occurrence in the picture
          string.

          Multiple ‘0’ symbols may be coded.

          Here's an example:
              ...
                  05  Output-Item     PIC 909090909.
              ...
                  MOVE 12345 TO Output-Item
                  DISPLAY Output-Item

          The above will display ‘102030405’.

     ‘/’
          The ‘/’ editing symbol inserts one "/" character into the
          field value for each occurrence in the picture string.

          Multiple ‘/’ symbols may be coded.

          This editing symbol is most-frequently used to format dates,
          as follows:
              ...
                  05  Year-Month-Day   PIC 9(4)/9(2)/9(2).
              ...
                  MOVE 20140207 TO Year-Month-Day
                  DISPLAY Year-Month-Day

          This example displays ‘2014/02/07’.

  12. The following are the numeric formatting symbols that may be
     specified in a picture string.  Each of these editing symbols will
     insert special characters into the field value to present numbers
     in a "friendly" format.  These editing symbols will each introduce
     one extra character into the total field size for each occurrence
     of the symbol in the picture string.  Numeric fields whose picture
     clause contains these characters may neither be used as source
     fields in any calculation nor may they serve as source fields for
     the transfer of data values to any data item other than an
     alphanumeric field.
     ‘.’
          The ‘.’ symbol inserts a decimal point into a numeric field
          value.  When the contents of a numeric data item sending field
          are moved into a receiving data item whose picture clause
          contains the ‘.’ editing symbol, implied (‘V’) or actual
          decimal point in the sending data item or literal,
          respectively, will be aligned with the ‘.’ symbol in the
          receiving field.  Digits are then transferred from the sending
          to the receiving field outward from the sending field's ‘V’ or
          ‘.’, truncating sending digits if there aren't enough
          positions in the receiving field.  Any digit positions in the
          receiving field that don't receive digits from the sending
          field, if any, will be set to 0.

          The ‘.’ symbol is not allowed in conjunction with ‘N’.

          An example will probably help:
              ...
              05  Source-Field   PIC 9(2)V9 VALUE 7.2.
              05  Dest-Field     PIC 9(5).9(2).
              ...
              MOVE 1234567.89 TO Dest-Field
              DISPLAY Dest-Field
              MOVE 19 TO Dest-Field
              DISPLAY Dest-Field
              MOVE Source-Field TO Dest-Field
              DISPLAY Dest-Field

          The example will display three results -- ‘34567.89’,
          ‘00019.00’ and ‘00007.20’.

          Both data item definitions appear to have two decimal points
          in their picture clauses.  They actually don't, because the
          last character of every data item definition is always a
          period -- the period that ends the definition.

     ‘,’
          The ‘,’ symbol serves as a thousands separator.  Many times,
          you'll see large numbers formatted with these symbols -- for
          example, 123,456,789.  This can be accomplished easily by
          adding thousands separator symbols to a picture string.
          Thousands separator symbols that aren't needed will be
          ignored, i.e., not used.

          The ‘,’ symbol is not allowed in conjunction with ‘N’.

          Here's an example:
              ...
              05  My-Lottery-Winnings   PIC 9(3),9(3),9(3).
              ...
              MOVE 12345 TO My-Lottery-Winnings
              DISPLAY My-Lottery-Winnings
          
              This produces 012,345
          

          The value ‘12,345’ (a very disappointing one for my retirement
          plans, but a good thousands separator demo) will be displayed.
          Notice how, since the first comma wasn't needed due to the
          meagre amount I won, it is ignored.

     If desired, you may reverse the roles of the ‘.’ and ‘,’ editing
     symbols by specifying ‘DECIMAL POINT IS COMMA’ in the
     ‘SPECIAL-NAMES’ (*note SPECIAL-NAMES::) paragraph.

         ...
             05  My-Lottery-Winnings   PIC zzz,zzz,zz9.
         ...
         MOVE 12345 TO My-Lottery-Winnings
         DISPLAY My-Lottery-Winnings
     
         This produces 12,345
     
         Notice that there is no leading zeros when using the picture Z.
     

  13. The following are insertion symbols.  They are used to insert an
     extra character (two in the case of ‘CR’ and ‘DB’) to signify the
     sign (positive or negative) of the numeric value that is moved into
     the field whose picture string contains one of these symbols, or
     the fact that the data item represents a currency (money) amount.
     Only one of the ‘+’, ‘-’, ‘CR’ or ‘DB’ symbols may be used in a
     picture clause.  In this context, when any of these symbols are
     used in a PICTURE-STRING, they must be at the end.  The ‘+’, ‘-’
     and/or currency symbols may also be used as floating editing
     symbols at the beginning of the PICTURE-STRING -- a subject that
     will be covered in the next numbered paragraph.
     ‘+’
          If the value of the numeric value moved into the field is
          positive (0 or greater), a ‘+’ character will be inserted.  If
          the value is negative (less than 0), a ‘-’ character is
          inserted.

          The ‘+’ symbol is not allowed in conjunction with ‘N’.

     ‘-’
          If the value of the numeric value moved into the field is
          positive (0 or greater), a space will be inserted.  If the
          value is negative (less than 0), a ‘-’ character is inserted.

          The ‘-’ symbol is not allowed in conjunction with ‘N’.

     ‘CR’
          This symbol is coded as the two characters ‘C’ and ‘R’.  If
          the value of the numeric value moved into the field is
          positive (0 or greater), two spaces will be inserted.  If the
          value is negative (less than 0), the characters ‘CR’ (credit)
          are inserted.

          The ‘CR’ symbol is not allowed in conjunction with ‘N’.

     ‘DB’
          This symbol is coded as the two characters ‘D’ and ‘B’.  If
          the value of the numeric value moved into the field is
          positive (0 or greater), two spaces will be inserted.  If the
          value is negative (less than 0), the characters ‘DB’ (debit)
          are inserted.

          The ‘DB’ symbol is not allowed in conjunction with ‘N’.

     ‘$’
          Regardless of the value moved into the field, this symbol will
          insert the currency symbol into the data item's value in the
          position where it occurs in the PICTURE-STRING (*note
          SPECIAL-NAMES::).

          The ‘$’ symbol is not allowed in conjunction with ‘N’.
  14. These editing symbols are known as floating replacement symbols.
     These symbols may occur in sequences before any ‘9’ editing symbols
     in the PICTURE-STRING of a numeric data item.  Using these symbols
     transforms that numeric data item into a numerid edited data item,
     which can no longer be used in calculations or subscripts.

  15. Each of the following symbols behave like a ‘9’, until such point
     as all digits in the numeric value are exhausted and leading zeros
     are about to be inserted.  In effect, these editing symbols define
     what should happen to those leading zero.
     ‘$’
          Of those currency symbols that correspond to character
          positions in which leading zeros reside, the right-most will
          have its ‘0’ value replaced by the currency symbol in-effect
          for the program (*note SPECIAL-NAMES::).  Any remaining
          leading zero values occupying positions described by this
          symbol will be replaced by spaces.

          The ‘$’ symbol is not allowed in conjunction with ‘N’.

          Any currency symbol coded to the right of a ‘.’ will be
          treated exactly like a ‘9’.

     ‘*’
          This symbol is referred to as a check protection symbol.  All
          check-protection symbols that correspond to character
          positions in which leading zeros reside will have their ‘0’
          values replaced by ‘*’.

          The ‘*’ symbol is not allowed in conjunction with ‘N’.

          Any check-suppression symbol coded to the right of a ‘.’ will
          be treated exactly like a ‘9’.

     ‘+’
          Of those ‘+’ symbols that correspond to character positions in
          which leading zeros reside, the right-most will have its ‘0’
          value replaced by a ‘+’ if the value in the data item is zero
          or greater or a ‘-’ otherwise.  Any remaining leading zero
          values occupying positions described by this symbol will be
          replaced by spaces.  You cannot use both ‘+’ and ‘-’ in the
          same PICTURE-STRING.

          The ‘+’ symbol is not allowed in conjunction with ‘N’.

          Any ‘+’ symbol coded to the right of a ‘.’ will be treated
          exactly like a ‘9’.

     ‘-’
          Of those ‘-’ symbols that correspond to character positions in
          which leading zeros reside, the right-most will have its ‘0’
          value replaced by a space if the value in the data item is
          zero or greater or a ‘-’ otherwise.  Any remaining leading
          zero values occupying positions described by this symbol will
          be replaced by spaces.  You cannot use both ‘+’ and ‘-’ in the
          same PICTURE-STRING.

          The ‘-’ symbol is not allowed in conjunction with ‘N’.

          Any ‘-’ symbol coded to the right of a ‘.’ will be treated
          exactly like a ‘9’.

     ‘Z’
          All ‘Z’ symbols that correspond to character positions in
          which leading zeros reside will have their ‘0’ values replaced
          by spaces.

          Any zero-suppression symbol coded to the right of a ‘.’ will
          be treated exactly like a ‘9’.

     ‘Z’ and ‘*’ should not be coded in the same PICTURE-STRING

     ‘+’ and ‘-’ should not be coded in the same PICTURE-STRING

     When multiple floating symbols are coded, even if there is only one
     of them used, only the last coded one will be considered floating.
     The leading floating symbols will be treated as fixed and will
     appear in the output in the position coded.  For example, if a data
     item has a PIC +$ZZZZ9.99 picture-string, and a value of 1 is moved
     to that field at run-time, the resulting value will be (the b
     symbol represents a space) +$bbbb1.00.  This is consistent with
     many other COBOL implementations, where the result would also have
     been +$bbbb1.00.



File: gnucobpg.info,  Node: PRESENT WHEN,  Next: PROMPT,  Prev: PICTURE,  Up: Data Description Clauses

6.9.39 PRESENT WHEN
-------------------

                      PRESENT-WHEN Clause Syntax
=======================================================================

 PRESENT WHEN condition-name
 ~~~~~~~ ~~~~


=======================================================================
   This syntax is valid in the following sections: ‘REPORT’

   This clause names an existing ‘Condition Name’ (*note Condition
Names::) that will serve as a switch controlling the presentation or
suppression of a report group.
  1. If the specified condition-name has a value of FALSE when a
     ‘GENERATE’ statement (*note GENERATE::) causes a report group to be
     presented, the presentation of that group will be suppressed.

  2. If the condition-name has a value of ‘TRUE’, the group will be
     presented.

  3. *Note Condition Names::, for more information.


File: gnucobpg.info,  Node: PROMPT,  Next: PROTECTED,  Prev: PRESENT WHEN,  Up: Data Description Clauses

6.9.40 PROMPT
-------------

                         PROMPT Clause Syntax
=======================================================================

 PROMPT [ CHARACTER IS literal-1 | identifier-1 ]
 ~~~~~~   ~~~~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   This clause defines the character that will be used as the
fill-character for any input fields on the screen.
  1. The reserved word ‘IS’ is optional and may be omitted.  The
     presence or absence of this word has no effect upon the program.

  2. The default prompt character, should no ‘CHARACTER’ specification
     be coded, or should the ‘PROMPT’ clause be absent altogether, is an
     underscore (‘_’).

  3. Prompt characters will be automatically transformed into spaces
     upon input.

   *Note Color Palette and Video Attributes::, for more information on
screen colors and video attributes.


File: gnucobpg.info,  Node: PROTECTED,  Next: REDEFINES,  Prev: PROMPT,  Up: Data Description Clauses

6.9.41 PROTECTED
----------------

                      PROTECTED Attribute Syntax
=======================================================================

 PROTECTED SIZE IS { identifier }
 ~~~~~~~~  ~~~~    { integer    }


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

     The ‘PROTECTED’ extended clause will effect the specified field to
     be limited in size, regardless of the picture size.(1)

  1. The SIZE phrase specifies the size (length) of the field.  After
     the ‘ACCEPT’ or ‘DISPLAY’ is finished, the cursor is placed
     immediately after the field defined by this clause, unless this
     would place the cursor outside of the current terminal window.  In
     this case, the cursor is wrapped around to the beginning of the
     next line (scrolling the window if necessary).

  2. If the ‘SIZE’ phrase is not used, then the field length defaults to
     the size of the item being accepted or displayed.  If the ‘CONVERT’
     phrase is used, however, then the size of the field depends on the
     data type of the item and the verb being used.
       A. If the ‘DISPLAY’ verb is executing, then the size is the same
          as if the ‘CONVERT’ phrase were not specified except for
          numeric items.  For numeric items, the size is the number of
          digits in the item, plus one if it is not an integer, plus one
          if it is signed.  The remaining cases cover the size when an
          ‘ACCEPT’ statement is used.

       B. If the item is numeric or numeric edited, then the size is the
          number of digits in the item, plus one if it is not an
          integer, plus one if it is signed.

       C. If the item is alphanumeric edited, then the size is set to
          the number of ‘A’ or ‘X’ positions specified in its ‘PICTURE’
          clause.

       D. For all other data types, the field size is set to the size of
          the item (same as if ‘CONVERT’ were not specified).

  3. Note that the ‘OUTPUT’ phrase changes the way in which the default
     field size is computed.  See that heading above for details.  Also
     note that the ‘OUTPUT’ phrase affects only the way items are
     displayed on the screen; the internal format of accepted data is
     not affected.

  4. Note that you cannot supply the ‘CONVERT’ phrase in the Screen
     Section.  Thus the size of a Screen Section field is always the
     size of its screen entry unless the ‘SIZE’ phrase is specified.

   ---------- Footnotes ----------

   (1) OR DOES IT? author uncertain


File: gnucobpg.info,  Node: REDEFINES,  Next: RENAMES,  Prev: PROTECTED,  Up: Data Description Clauses

6.9.42 REDEFINES
----------------

                        REDEFINES Clause Syntax
=======================================================================

 REDEFINES identifier-1
 ~~~~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘FILE’,
‘WORKING-STORAGE’, ‘LOCAL-STORAGE’, ‘LINKAGE’

   The ‘REDEFINES’ clause causes the data item in who's definition the
‘REDEFINES’ clause is specified (hereafter referred to as the redefines
object) to occupy the same physical storage space as IDENTIFIER-1
(hereafter referred to as the redefines subject).
  1. The following rules must all be followed in order to use
     ‘REDEFINES’:
       A. The level number of both the subject and object data items
          must be the same.

       B. The level numbers of both the subject and object data items
          cannot be 66, 78 or 88.

       C. If N represents the level number of the object, then no other
          data items with level number N may be defined between the
          subject and object data items unless they too are ‘REDEFINES’
          of the subject.

       D. If N represents the level number of the object, then no other
          data items with a level number numerically less than N may be
          defined between the subject and object data items.

       E. The total allocated size of the subject data item must be the
          same as the total allocated size of the object data item.

       F. No ‘OCCURS’ (*note OCCURS::) clause may be part of the
          definition of either the subject or object data items.  Either
          or both, however, may be group items that contain data items
          with ‘OCCURS’ clauses.

       G. No ‘VALUE’ (*note VALUE::) clause may be defined on the object
          data item, and no data items subordinate to the object data
          item may have ‘VALUE’ clauses, with the exception of level-88
          condition names.


File: gnucobpg.info,  Node: RENAMES,  Next: REQUIRED,  Prev: REDEFINES,  Up: Data Description Clauses

6.9.43 RENAMES
--------------

                         RENAMES Clause Syntax
=======================================================================

 RENAMES identifier-1 [ THRU|THROUGH identifier-2
 ~~~~~~~                ~~~~ ~~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘FILE’,
‘WORKING-STORAGE’, ‘LOCAL-STORAGE’, ‘LINKAGE’

   The ‘RENAMES’ clause regroups previously defined items by specifying
alternative, possibly overlapping, groupings of elementary data items.
  1. The reserved words ‘THRU’ and ‘THROUGH’ are interchangeable.

  2. You must use the level number 66 for data description entries that
     contain the ‘RENAMES’ clause.

  3. The IDENTIFIER-1 and IDENTIFIER-2 data items, along with all data
     items defined between those two data items in the program source,
     must all be contained within the same 01-level record description.

  4. *Note 66-Level Data Items::, for additional information on the
     ‘RENAMES’ clause.


File: gnucobpg.info,  Node: REQUIRED,  Next: REVERSE-VIDEO,  Prev: RENAMES,  Up: Data Description Clauses

6.9.44 REQUIRED
---------------

                       REQUIRED Attribute Syntax
=======================================================================

 REQUIRED
 ~~~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   This clause forces the user to enter data into the field it is
specified on (or into all subordinate input-capable fields if ‘REQUIRED’
is specified on a group item).
  1. The ‘EMPTY-CHECK’ (*note EMPTY-CHECK::) and ‘REQUIRED’ clauses are
     interchangeable, and may not be used together in the same data item
     description.

  2. In order to take effect, the user must first move the cursor into
     the field having this clause in its definition.

  3. The ‘ACCEPT data-item’ statement (*note ACCEPT data-item::) will
     ignore the Enter key and any other cursor-moving keystrokes that
     would cause the cursor to move to another screen item unless data
     has been entered into the field.  Function keys will still be
     allowed to terminate the ‘ACCEPT’.

  4. In order to be functional, this attribute must be supported by the
     underlying "curses" package your GnuCOBOL implementation was built
     with.  As of this time, the "PDCurses" package (used for native
     Windows or MinGW builds) does not support ‘REQUIRED’.


File: gnucobpg.info,  Node: REVERSE-VIDEO,  Next: SAME AS,  Prev: REQUIRED,  Up: Data Description Clauses

6.9.45 REVERSE-VIDEO
--------------------

                    REVERSE-VIDEO Attribute Syntax
=======================================================================

 REVERSE-VIDEO
 ~~~~~~~~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   The ‘REVERSE-VIDEO’ attribute swaps the specified or implied
‘FOREGROUND-COLOR’ (*note FOREGROUND-COLOR::) and ‘BACKGROUND-COLOR’
(*note BACKGROUND-COLOR::) attributes for the field whose definition
contains this clause (or all subordinate fields if used on a group
item).

   *Note Color Palette and Video Attributes::, for more information on
screen colors and video attributes.



File: gnucobpg.info,  Node: SAME AS,  Next: SCROLL DOWN,  Prev: REVERSE-VIDEO,  Up: Data Description Clauses

6.9.46 SAME AS
--------------

                         SAME-AS Clause Syntax
=======================================================================

SAME AS data-name-1
~~~~ ~~


=======================================================================
   The syntax is valid in the following sections: ‘WORKING-STORAGE’

   The ‘SAME AS’ causes a data item to inherit the same definition of
another data item.

  1. Data-name-1 is a data Item defined elsewhere in the same program.
  2. Data-name-1 shall not be subscripted.
  3. A data description entry that specifies the SAME AS clause shall
     not be immediately followed by a subordinate data description entry
     or level 88 entry.
  4. Neither the description of data-name-1 nor the description of any
     data items subordinate to the subject of the entry shall directly
     or indirectly contain a SAME AS clause that references the subject
     of the entry or any group item to which this entry is subordinate.
  5. The description of data-name-1, including its subordinate data
     items, shall not contain a TYPE clause that references the record
     to which this entry is subordinate.
  6. The description of data-name-1 shall not contain an OCCURS clause.
     However, items subordinate to data-name-1 may contain OCCURS
     clauses.
  7. Data-name-1 shall reference an elementary item or a level 1 group
     item described in the file, working-storage, local-storage, or
     linkage section.
  8. If the subject of the entry is a level 77 item, data-name-1 shall
     reference an elementary item.
  9. A group item to which the subject of the entry is subordinate shall
     not contain a GROUP-USAGE, SIGN, or USAGE clause.
  10. The effect of the SAME AS clause is as though the data description
     identified by data-name-1 had been coded in place of the SAME AS
     clause, excluding the level number, name, and the EXTERNAL, GLOBAL,
     REDEFINES clauses specified for data-name-1; level numbers of
     subordinate items may be adjusted as described in general rule 2.
  11. If data-name-1 describes a group item:
  12. the subject of the entry is a group whose subordinate elements
     have the same names, descriptions, and hierarchy as the subordinate
     elements of data-name-1, the level numbers of items subordinate to
     that group are adjusted, if necessary, to preserve the hierarchy of
     data-name-1, level numbers in the resulting hierarchy may exceed
     49.


                 IDENTIFICATION   DIVISION.
                 PROGRAM-ID.      prog.
                 DATA             DIVISION.

                 WORKING-STORAGE  SECTION.
                 01 MESSAGE-TEXT-2 EXTERNAL.
                      02 MAIN-FILE-NAME     PIC X(50).
                      02 FILLER REDEFINES MAIN-FILE-NAME.
                          05 FILLER PIC 9999.
                      02 MAIN-FILE-NAME-2.
                          05 FILLER PIC 9999.
                          05 DETAIL-NO PIC 9999.
                     02 FILLER         SAME AS MAIN-FILE-NAME.
                 77 OUTPUT-NAME     SAME AS DETAIL-NO GLOBAL.
                 01 Z-MESSAGE-T2    SAME AS MAIN-FILE-NAME-2.
                 01 Z-MESSAGE-T3.
                       49 MT3                    SAME AS MESSAGE-TEXT-2.
                       49 MT3-REN  REDEFINES MT3 SAME AS MESSAGE-TEXT-2.

                 PROCEDURE DIVISION.
                     DISPLAY MAIN-FILE-NAME OF MESSAGE-TEXT-2
                     DISPLAY DETAIL-NO      OF Z-MESSAGE-T2
                     DISPLAY MAIN-FILE-NAME OF MT3
                     DISPLAY OUTPUT-NAME
                     GOBACK.



File: gnucobpg.info,  Node: SCROLL DOWN,  Next: SCROLL UP,  Prev: SAME AS,  Up: Data Description Clauses

6.9.47 SCROLL DOWN
------------------

                     SCROLL-DOWN Attribute Syntax
=======================================================================

SCROLL DOWN
~~~~~~ ~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   This clause will cause downward scrolling.


File: gnucobpg.info,  Node: SCROLL UP,  Next: SECURE,  Prev: SCROLL DOWN,  Up: Data Description Clauses

6.9.48 SCROLL UP
----------------

                      SCROLL-UP Attribute Syntax
=======================================================================

SCROLL UP
~~~~~~ ~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   This clause will cause upward scrolling.  MORE HERE ??



File: gnucobpg.info,  Node: SECURE,  Next: SIGN IS,  Prev: SCROLL UP,  Up: Data Description Clauses

6.9.49 SECURE
-------------

                        SECURE Attribute Syntax
=======================================================================

 SECURE
 ~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   This clause will cause all data entered into the field to appear on
the screen as asterisks.
  1. The ‘NO-ECHO’ and ‘SECURE’ clauses are interchangeable if If the
     dialect configuration -fno-echo-means-secure is active.

  2. The ‘NO-ECHO’ and ‘SECURE’ clauses may not be used together in the
     same data item description.

  3. This clause may only be used on a field allowing data entry (a
     field containing either the ‘USING’ (*note USING::) or ‘TO’ (*note
     TO::) clause).

   *Note Color Palette and Video Attributes::, for more information on
screen colors and video attributes.


File: gnucobpg.info,  Node: SIGN IS,  Next: SIZE,  Prev: SECURE,  Up: Data Description Clauses

6.9.50 SIGN IS
--------------

                         SIGN-IS Clause Syntax
=======================================================================

 SIGN IS LEADING|TRAILING [ SEPARATE CHARACTER ]
 ~~~~    ~~~~~~~ ~~~~~~~~   ~~~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘FILE’,
‘WORKING-STORAGE’, ‘LOCAL-STORAGE’, ‘LINKAGE’, ‘REPORT’, ‘SCREEN’

   This clause, allowable only for ‘USAGE DISPLAY’ numeric data items,
specifies how an ‘S’ symbol will be interpreted in a data item's picture
clause.
  1. The reserved words ‘CHARACTER’ and ‘IS’ are optional and may be
     omitted.  The presence or absence of these words has no effect upon
     the program.

  2. Without the ‘SEPARATE CHARACTER’ option, the sign of the data
     item's value will be encoded by transforming the last (see
     ‘TRAILING’) or first (see ‘LEADING’) digit as follows:

     First/Last Digit   Value For          Value for
                        Positive           Negative
     ---------------------------------------------------------
     0                  0                  p
     1                  1                  q
     2                  2                  r
     3                  3                  s
     4                  4                  t
     5                  5                  u
     6                  6                  v
     7                  7                  w
     8                  8                  x
     9                  9                  y

  3. If the ‘SEPARATE CHARACTER’ clause is used, then an actual ‘+’ or
     ‘-’ character will be inserted into the field's value as the first
     (‘LEADING’) or last (‘TRAILING’) character.  Note that having this
     character embedded within the data item's storage does not prevent
     the data item from being used as a source field in arithmetic
     operations.

  4. When ‘SEPARATE CHARACTER’ is specified, the ‘S’ symbol in the data
     item's ‘PICTURE’ must be counted when determining the data item's
     size.

  5. Neither the presence of an encoded digit (see above) nor an actual
     ‘+’ or ‘-’ character embedded within the data item's storage
     prevents the data item from being used as a source field in
     arithmetic operations.


File: gnucobpg.info,  Node: SIZE,  Next: SOURCE,  Prev: SIGN IS,  Up: Data Description Clauses

6.9.51 SIZE
-----------

                          SIZE Clause Syntax
=======================================================================

SIZE IS variable-1 | literal-1
~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   The size of Variable to accept from the screen.  VARIABLE-1 or
LITERAL-1 must be numeric.  'SIZE <greater than zero>' If VARIABLE-1 or
LITERAL-1 is less than the length of the variable then only the 'SIZE'
number of characters accept into the field.  Variable pads with spaces
after 'SIZE' to the end of the field.  If VARIABLE-1 or LITERAL-1 is
greater than the variable, then the screen pads with spaces after
variable to the 'SIZE' length.  'SIZE ZERO' '<SIZE option not
specified>' The variable accepts to its field length.



File: gnucobpg.info,  Node: SOURCE,  Next: SPECIAL-NAMES.,  Prev: SIZE,  Up: Data Description Clauses

6.9.52 SOURCE
-------------

                         SOURCE Clause Syntax
=======================================================================

 SOURCE IS literal-1 | identifier-1 [ ROUNDED ]
 ~~~~~~                               ~~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘REPORT’

   This clause logically attaches a report section data item to another
data item defined elsewhere in the data division.
  1. The reserved word ‘IS’ is optional and may be omitted.  The
     presence or absence of this word has no effect upon the program.

  2. When the report group containing this clause is presented, the
     value of the specified numeric literal or identifier will be
     automatically moved to the report data item prior to presentation.

  3. The specified identifier may be defined anywhere in the data
     division, but if it is defined in the report section it may only be
     ‘PAGE-COUNTER’, ‘LINE-COUNTER’ or a ‘SUM’ (*note SUM::) counter.

  4. The ‘PICTURE’ (*note PICTURE::) of the report data item must be
     such that it would be legal to ‘MOVE’ (*note MOVE::) the specified
     literal or identifier to a data item with that ‘PICTURE’.

  5. The ‘ROUNDED’ option comes into play should the number of digits to
     the right of an actual or assumed decimal point be different
     between the specified literal or identifier value (the "source
     value") and the ‘PICTURE’ specified for the field in whose
     definition the ‘SOURCE’ clause appears (the "target field").
     Without ‘ROUNDED’, excess digits in the source value will simply be
     truncated to fit the target field.  With ‘ROUNDED’, the source
     value will be arithmetically rounded to fit the target field.
     *Note ROUNDED::, for information on the ‘NEAREST-AWAY-FROM-ZERO’
     rounding rule, which is the one that will apply.



File: gnucobpg.info,  Node: SPECIAL-NAMES.,  Next: SUM OF,  Prev: SOURCE,  Up: Data Description Clauses

6.9.53 SPECIAL-NAMES.
---------------------

                      SPECIAL-NAMES Clause Syntax
=======================================================================

 IS SPECIAL-NAMES { CURSOR         }
    ~~~~~~~~~~~~~ { CRT STATUS     }
                  { SCREEN CONTROL }
                  { EVENT STATUS   }


=======================================================================
   This syntax is valid in the following sections: ‘DATA DIVISION’

   The SPECIAL-NAMES clause allows you to identify commonly used
Special-Names items directly in the Data Division.  Sample of use:
  1. The reserved word ‘IS’ is optional and may be omitted.  The
     presence or absence of this word has no effect upon the program.
     Next an example of usage.


          01  wCURPOS IS SPECIAL-NAMES CURSOR.
              03 wCURSOR-ROW PIC 999.
              03 wCURSOR-COL PIC 999.
          01  wCRTSTAT IS SPECIAL-NAMES CRT STATUS PIC 9(5).



File: gnucobpg.info,  Node: SUM OF,  Next: SYNCHRONIZED,  Prev: SPECIAL-NAMES.,  Up: Data Description Clauses

6.9.54 SUM OF
-------------

                         SUM-OF Clause Syntax
=======================================================================

 SUM OF { identifier-7 }... [ { RESET ON FINAL|identifier-8 } ]
 ~~~    { literal-2    }      { ~~~~~    ~~~~~              }
                              { UPON identifier-9           }
                                ~~~~


=======================================================================
   This syntax is valid in the following sections: ‘REPORT’

   The ‘SUM’ clause establishes a summation counter whose value will be
arithmetically calculated whenever the field is presented.
  1. The reserved words ‘OF’ and ‘ON’ are optional and may be omitted.
     The presence or absence of these words has no effect upon the
     program.

  2. The ‘SUM’ clause may only appear in a ‘CONTROL FOOTING’ report
     group.

  3. If the data item in which the ‘SUM’ clause appears has been
     assigned its own identifier name, and that name is not ‘FILLER’,
     then that data item is referred to as a sum counter.

  4. All IDENTIFIER-7 data items must be non-edited numeric in nature.

  5. If any IDENTIFIER-7 data item is defined in the report section, it
     must be a sum counter.

  6. Any IDENTIFIER-7 data items that are sum counters must either be
     defined in the same report group as the data item in which this
     ‘SUM’ clause appears or they must be defined in a report data item
     that exists at a lower level in this report's control hierarchy.
     *Note Control Hierarchy::, for additional information.

  7. The ‘PICTURE’ of the report data item in who's description this
     ‘SUM’ clause appears in must be such that it would be legal to
     ‘MOVE’ (*note MOVE::) the specified IDENTIFIER-7 or LITERAL-2 value
     to a data item with that ‘PICTURE’.

  8. The following points apply to the ‘UPON’ option:
       A. The data item IDENTIFIER-9 must be the name of a detail group
          specified in the same report as the control footing group in
          which this ‘SUM’ clause appears.

       B. The presence of an ‘UPON’ clause limits the ‘SUM’ clause to
          adding the specified numeric literal or identifier value into
          the sum counter only when a ‘GENERATE IDENTIFIER-9’ statement
          is executed.

       C. If there is no ‘UPON’ clause specified, the value of
          IDENTIFIER-7 or LITERAL-2 will be added into the sum counter
          whenever a ‘GENERATE’ (*note GENERATE::) of any detail report
          group in the report is executed.

       D. If there is only a single detail group in the report's
          definition, the ‘UPON’ clause is meaningless.
  9. The following points apply to the ‘RESET’ option:
       A. If the ‘RESET’ option is coded, ‘FINAL’ or IDENTIFIER-8
          (whichever is coded on the ‘RESET’) must be one of the
          report's control breaks specified on the ‘CONTROLS’ clause.

       B. If there is no ‘RESET’ option coded, the sum counter will be
          reset back to zero after each time the control footing
          containing the ‘SUM’ clause is presented.  This is the typical
          behaviour that would be expected.

       C. If, however, you want to reset the ‘SUM’ counter only when the
          control footing for a control break higher in the control
          hierarchy is presented, specify that higher control break on
          the ‘RESET’ option.


File: gnucobpg.info,  Node: SYNCHRONIZED,  Next: TIME OUT,  Prev: SUM OF,  Up: Data Description Clauses

6.9.55 SYNCHRONIZED
-------------------

                          SYNCHRONIZED Syntax
=======================================================================

 SYNCHRONIZED|SYNCHRONISED [ LEFT|RIGHT ]
 ~~~~         ~~~~           ~~~~ ~~~~~

   The ‘LEFT’ and ‘RIGHT’ (SYNCHRONIZED) clauses are syntactically
recognized but are otherwise non-functional.

=======================================================================
   This syntax is valid in the following sections: ‘FILE’,
‘WORKING-STORAGE’, ‘LOCAL-STORAGE’, ‘LINKAGE’

   This optional clause optimizes the storage of binary numeric items to
store them in such a manner as to make it as fast as possible for the
CPU to fetch them.
  1. The reserved words ‘SYNCHRONIZED’ and ‘SYNCHRONISED’ are
     interchangeable, and may be abbreviated as ‘SYNC’.

  2. If the ‘SYNCHRONIZED’ clause is coded on anything but a numeric
     data item with a ‘USAGE’ (*note USAGE::) that specifies storage of
     data in a binary form, the ‘SYNCHRONIZED’ clause will be ignored.

  3. Synchronization is performed (by the compiler) as follows:
       A. If the binary item occupies one byte of storage, no
          synchronization is performed.

       B. If the binary item occupies two bytes of storage, the binary
          item is allocated at the next half-word boundary.

       C. If the binary item occupies four bytes of storage, the binary
          item is allocated at the next word boundary.

       D. If the binary item occupies eight bytes of storage, the binary
          item is allocated at the next word boundary.


File: gnucobpg.info,  Node: TIME OUT,  Next: TO,  Prev: SYNCHRONIZED,  Up: Data Description Clauses

6.9.56 TIME OUT
---------------

                        TIME-OUT Clause Syntax
=======================================================================

TIME OUT
~~~~ ~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   This clause will force a specific time for the data to be entered.



File: gnucobpg.info,  Node: TO,  Next: TYPE,  Prev: TIME OUT,  Up: Data Description Clauses

6.9.57 TO
---------

                           TO Clause Syntax
=======================================================================

 TO identifier-5
 ~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   This clause logically attaches a screen section data item to another
data item defined elsewhere in the data division.
  1. The ‘TO’ clause is used to define a data-entry field with no
     initial value; when a value is entered, it will be saved to the
     specified identifier.

  2. The ‘FROM’ (*note FROM::), ‘TO’, ‘USING’ (*note USING::) and
     ‘VALUE’ (*note VALUE::) clauses are mutually-exclusive in any
     screen section data item's definition.


File: gnucobpg.info,  Node: TYPE,  Next: TYPEDEF,  Prev: TO,  Up: Data Description Clauses

6.9.58 TYPE
-----------

                          TYPE Clause Syntax
=======================================================================

 Format 1: All Sections other than REPORT

 [ TYPE TO type-name-1 ]
   ~~~~


 Format 2:  REPORT SECTION Only

 [ TYPE IS {CH|{CONTROL HEADING} [ON|FOR]  { FINAL|identifier-1 } [OR PAGE]  } ]
 [ ~~~~    {~~  ~~~~~~~ ~~~~~~~            { ~~~~~              }            } ]
 [         {RH|{REPORT HEADING}                                              } ]
 [         {~~  ~~~~~~ ~~~~~~~                                               } ]
 [         {PH|{PAGE HEADING}                                                } ]
 [         {~~  ~~~~ ~~~~~~~                                                 } ]
 [         {DE|DETAIL                                                        } ]
 [         {~~ ~~~~~~                                                        } ]
 [         {CF|{CONTROL FOOTING} [ON|FOR] [{ FINAL|identifier-2 } [OR PAGE] ]} ]
 [         {~~  ~~~~~~~ ~~~~~~~           [{ ~~~~~              }           ]} ]
 [         {                              [  ALL                            ]} ]
 [         {                              [  ~~~~~                          ]} ]
 [         {RF|{REPORT FOOTING}                                              } ]
 [         {~~  ~~~~~~ ~~~~~~~                                               } ]
 [         {PF|{PAGE FOOTING}                                                } ]
 [         {~~  ~~~~ ~~~~~~~                                                 } ]


=======================================================================
   The syntax is valid in all other sections than: ‘REPORT’

   As format 1
  1. The TYPE clause indicates that the data description of the subject
     of the entry is specified by a user-defined data type.
  2. The user defined data type is defined using the TYPEDEF clause,
     which is described in TYPEDEF clause ‘TYPEDEF’ (*note TYPEDEF::).
  3. The following general rules apply: If type-name-1 (defined using
     the TYPEDEF clause) describes a group item, then the subject of the
     TYPE clause is a group item whose subordinate elements have the
     same names, descriptions, and hierarchies as the subordinate
     elements of type-name-1.
  4. Since the subject of the TYPE clause may have a level number as
     high as 49 and type-name-1 may be a group item with 49 levels, the
     number of levels of this hierarchy may exceed 49.  In fact, since
     descriptions of type names may reference other type names, there is
     no limit to the number of levels in this hierarchy.
  5. If a VALUE clause is specified in the data description of the
     subject of the TYPE clause, any VALUE clause specified in the
     description of type-name-1 is ignored for this entry.
  6. The scoping rules for type names are similar to the scoping rules
     for data names.
  7. Reference modification is not allowed for an elementary item that
     is the subject of a TYPE clause.
  8. The description of type-name-1, including its subordinate data
     items, cannot contain a TYPE clause that references the record to
     which the subject of the TYPE clause (that references type-name-1),
     is subordinate.
  9. For example, A is a group item defined using the TYPEDEF clause.  B
     is also a group item defined using the TYPEDEF clause, but which
     also includes a subordinate item of TYPE A. This being the case,
     the type definition for A cannot include items of TYPE B.
  10. The subject of a TYPE clause cannot be renamed in whole, or in
     part and cannot be redefined explicitly or implicitly.
  11. If the subject of a TYPE clause is subordinate to a group item,
     the data description of the group item cannot contain the USAGE
     clause.
  12. The TYPE clause cannot occur in a data description entry with the
     BLANK WHEN ZERO, FORMAT, JUSTIFIED, PICTURE, REDEFINES, RENAMES,
     SIGN, SYNCHRONIZED, or USAGE clause.
  13. The TYPE clause can be specified in a data description entry with
     the EXTERNAL, GLOBAL, OCCURS, TYPEDEF, and VALUE clauses.
  14. The essential characteristics of a type, which is identified by
     its type-name, are the relative positions and lengths of the
     elementary items defined in the type declaration, and the BLANK
     WHEN ZERO, JUSTIFIED, PICTURE, SIGN, SYNCHRONIZED, and USAGE
     clauses specified for each of these elementary items.
  15. The TYPE clause shall not be specified in the same data
     description entry with any clauses except BASED, CLASS, CONSTANT
     RECORD, DEFAULT, DESTINATION, entry-name, EXTERNAL, GLOBAL,
     INVALID, level-number, OCCURS, PRESENT WHEN, PROPERTY, TYPEDEF,
     VALIDATE-STATUS, VALUE, and VARYING.

  16. Figure 1.  Example Showing How TYPEDEF and TYPE Clauses Can Be
     Used


                 IDENTIFICATION   DIVISION.
                 PROGRAM-ID.      prog.
                 DATA             DIVISION.
                 WORKING-STORAGE  SECTION.
                 01 MAIN-FILE-NAME-T     PIC X(50) IS TYPEDEF.
                 01 DETAIL-NO-T             PIC 9999  IS TYPEDEF.
                  01 MAIN-FILE-NAME-2T              IS TYPEDEF.
                    05 FILLER    PIC 9999.
                    05 DETAIL-NO TYPE TO DETAIL-NO-T.

                 01  MESSAGE-TEXT-2T IS TYPEDEF.
                   02 MAIN-FILE-NAME     TYPE MAIN-FILE-NAME-T.
                   02 FILLER REDEFINES MAIN-FILE-NAME.
                       05 FILLER PIC 9999.
                   02 MAIN-FILE-NAME-2   TYPE MAIN-FILE-NAME-2T.
                   02 FILLER                TYPE MAIN-FILE-NAME-T.

                 01  MESSAGE-TEXT-2 EXTERNAL TYPE MESSAGE-TEXT-2T.
                 77 OUTPUT-NAME TYPE TO DETAIL-NO-T GLOBAL.
                 01 Z-MESSAGE-T2 TYPE MAIN-FILE-NAME-2T.
                 01 Z-MESSAGE-T3.
                    49 MT3                    TYPE MESSAGE-TEXT-2T.
                    49 MT3-REN  REDEFINES MT3 TYPE MESSAGE-TEXT-2T.

                 PROCEDURE DIVISION.
                     DISPLAY MAIN-FILE-NAME OF MESSAGE-TEXT-2
                     DISPLAY DETAIL-NO         OF Z-MESSAGE-T2
                     DISPLAY MAIN-FILE-NAME OF MT3
                     DISPLAY OUTPUT-NAME
                     GOBACK.

  17. Figure 2.  Example Showing How TYPEDEF and TYPE Clauses Can Be
     Used


               DATA DIVISION.
               FILE SECTION.
               FD PRT-FILE.
               01 PRT-REC.
                  05 PRT-RECORD                PIC X(132).
               01 INVE-TYP-T IS TYPEDEF        PIC S9(3) VALUE 0.
                       88 INVE-TYP-BOOK             VALUE 4, 5.
                  88 INVE-TYP-BOOK-001         VALUE 4.
                  88 INVE-TYP-BOOK-002         VALUE 5.
                  88 INVE-TYP-CLOTHES          VALUE 1, 2, 3.
                  88 INVE-TYP-CLOTHES-SWEATERS VALUE 1.
                  88 INVE-TYP-CLOTHES-SOCKS    VALUE 2.
                  88 INVE-TYP-CLOTHES-PANTS    VALUE 3.

              FD DATA-IN.
              01 DATA-IN-REC.
                 05 INVE-TYP          TYPE INVE-TYP-T.
                 05 FILLER            PIC X(80).

              WORKING-STORAGE SECTION.
              01 ARTI-PRICE-T TYPEDEF PIC S9(4)V9(2) value 0.
              01 ARTI-COLOR-T TYPEDEF PIC S9(2) VALUE 1.
                 88 ARTI-COLOR-BLUE   VALUE 1.
                 88 ARTI-COLOR-RED    VALUE 2.
                 88 ARTI-COLOR-GREEN  VALUE 3.

              01 ARTI-SIZE-T    TYPEDEF PIC S9(2) VALUE 10.
              01 ARTI-COUNTER-T TYPEDEF PIC S9(6) VALUE 0.

              01 ARTI-B-T TYPEDEF.
                 05 ARTI-B-VALUE PIC s9(2).
                    88 ARTI-B-BLUE  VALUE 1.
                    88 ARTI-B-RED   VALUE 2.
                    88 ARTI-B-GREEN VALUE 3.

              01 TEST-ARTI       TYPE ARTI-B-T.

              01 WORK-INVE-TYP  TYPE INVE-TYP-T.

              01 CLOTHING-ARTI IS TYPEDEF.
                 05 CLOTHING-TYP    TYPE INVE-TYP-T.
                 05 PRICE           TYPE ARTI-PRICE-T.
                 05 COLOR           TYPE ARTI-COLOR-T.
                 05 CLOTHING-SIZE   TYPE ARTI-SIZE-T.
                 05 FILLER PIC X(70).

              01 SWEATERS TYPE CLOTHING-ARTI.
              01 SOCKS    TYPE CLOTHING-ARTI.
              01 PANTS    TYPE CLOTHING-ARTI.

              01 BOOK-ARTI IS TYPEDEF.
                 05 BOOK-TYP     TYPE INVE-TYP-T.
                 05 PRICE        TYPE ARTI-PRICE-T.
                 05 FILLER       PIC X(20).
                 05 BOOK-TITLE   PIC X(40).
                 05 FILLER       PIC X(14).

              01 BOOK-001       TYPE BOOK-ARTI.
              01 BOOK-002       TYPE BOOK-ARTI.

              01 SWEATERS-COUNT TYPE ARTI-COUNTER-T.
              01 SOCKS-COUNT    TYPE ARTI-COUNTER-T.
              01 PANTS-COUNT    TYPE ARTI-COUNTER-T.

              01 BOOK-001-COUNT TYPE ARTI-COUNTER-T.
              01 BOOK-002-COUNT TYPE ARTI-COUNTER-T.

              01 CLOTHES-COUNT  TYPE ARTI-COUNTER-T.
              01 BOOK-COUNT     TYPE ARTI-COUNTER-T.

   This syntax is valid in the following sections: ‘REPORT’

   As Format 2
  1. This clause defines the type of report group that is being defined
     for a report.
  2. This clause is required on any 01-level data item definitions
     (other than 01-level constants) in the report section.  This clause
     is invalid on any other report section data item definitions.

  3. There may be a maximum of one (1) report group per ‘RD’ defined
     with a ‘TYPE’ of ‘REPORT HEADING’, ‘PAGE HEADING’, ‘PAGE FOOTING’
     and ‘REPORT FOOTING’.

  4. There must be either a ‘CONTROL HEADING’ or a ‘CONTROL FOOTING’ or
     both specified for each entry specified on the ‘CONTROLS ARE’
     clause of the ‘RD’.

  5. The various report groups that constitute a report may be defined
     in any order.

  6. *Note RWCS Lexicon::, for a description of the seven different
     types of report groups.


File: gnucobpg.info,  Node: TYPEDEF,  Next: UNDERLINE,  Prev: TYPE,  Up: Data Description Clauses

6.9.59 TYPEDEF
--------------

                         TYPEDEF Clause Syntax
=======================================================================

 01  data-name-1 IS TYPEDEF
                 ~~ ~~~~~~


=======================================================================
   This syntax is valid in the following sections FILE, WORKING-STORAGE,
LOCAL-STORAGE and LINKAGE
  1. The TYPEDEF clause identifies a type declaration which creates a
     user defined data type and is used to apply this user defined data
     type to the description of a data item.

  2. The TYPEDEF clause specifies that the data description entry is a
     type declaration.
  3. The TYPEDEF clause can only be specified for level 01 entries,
     which can also be group items, and for which the data-name format
     of the entry name clause is specified.  If the TYPEDEF clause is
     specified for a data description, then that same data description
     must include a data-name, that is, it must not be specified with
     either an implicit or explicit FILLER clause.
  4. If a group item is specified, all subordinate items of the group
     become part of the type declaration.
  5. No storage is allocated for a type declaration.
  6. These type definitions act like templates that can then be used to
     define new data items using the TYPE clause or that can
     subsequently be referenced in a USAGE clause.
  7. The new data item acquires all the characteristics of the
     user-defined data type.  If the user defined data type is a group
     item, then the new data item has subordinate elements of the same
     name, description, and hierarchy as those belonging to the user
     defined data type.
  8. All of the other data description clauses, if they are specified,
     are assumed by any data item that is defined using the user defined
     data type (within the TYPE or USAGE clause).
  9. The following clauses cannot be specified along with TYPEDEF:
     EXTERNAL, GLOBAL, LIKE, OCCURS, REDEFINES.
  10. If the TYPEDEF clause is specified for a group item, then
     subordinate items can be specified with OCCURS or REDEFINES
     clauses.  TYPEDEF cannot be used with complex OCCURS DEPENDING ON.
     This means that you cannot specify an OCCURS DEPENDING ON clause
     within a table that is part of a TYPEDEF.
  11. The VALUE clause cannot be specified either in the data
     descriptions specifying the TYPEDEF clause or in any subordinate
     item except for condition-names (88 level entries) within the
     TYPEDEF structure.
  12. The TYPE clause can be specified in the same data description
     entry as the TYPEDEF clause but the description of the subject of
     the entry, including its subordinate items, shall not contain a
     TYPE clause that directly or indirectly references this type
     definition.
  13. In FILE SECTION, a data description entry declared at level number
     1 that includes a TYPEDEF clause is not a record description entry.


File: gnucobpg.info,  Node: UNDERLINE,  Next: UPDATE,  Prev: TYPEDEF,  Up: Data Description Clauses

6.9.60 UNDERLINE
----------------

                      UNDERLINE Attribute Syntax
=======================================================================

 UNDERLINE
 ~~~~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   The ‘UNDERLINE’ clause will introduce a horizontal line at the bottom
edge of a screen field.
  1. The ‘LEFTLINE’ (*note LEFTLINE::), ‘OVERLINE’ (*note OVERLINE::)
     and ‘UNDERLINE’ clauses may be used in any combination in a single
     field's description.

  2. This clause is essentially non-functional when used within Windows
     command shell (cmd.exe) environments and running programs compiled
     using a GnuCOBOL implementation built using "PDCurses" (such as
     Windows/MinGW builds).

  3. Whether or not this clause operates on Cygwin or UNIX/Linux/OSX
     systems will depend upon the video attribute capabilities of the
     terminal output drivers and "curses" software being used.

   *Note Color Palette and Video Attributes::, for more information on
screen colors and video attributes.


File: gnucobpg.info,  Node: UPDATE,  Next: UPPER,  Prev: UNDERLINE,  Up: Data Description Clauses

6.9.61 UPDATE
-------------

                         UPDATE Clause Syntax
=======================================================================

UPDATE
~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   The ‘UPDATE’ clause will display the existing data before allowing
user to update it.  The ‘DEFAULT’ clause is synonymous with the ‘UPDATE’
clause.



File: gnucobpg.info,  Node: UPPER,  Next: USAGE,  Prev: UPDATE,  Up: Data Description Clauses

6.9.62 UPPER
------------

                          UPPER Clause Syntax
=======================================================================

UPPER
~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   The ‘UPPER’ clause force the accepted data to be in Upper Case.



File: gnucobpg.info,  Node: USAGE,  Next: USING,  Prev: UPPER,  Up: Data Description Clauses

6.9.63 USAGE
------------

                          USAGE Clause Syntax
=======================================================================

 USAGE IS data-item-usage
 ~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘FILE’,
‘WORKING-STORAGE’, ‘LOCAL-STORAGE’, ‘LINKAGE’, ‘REPORT’

   The ‘USAGE’ clause defines the format that will be used to store the
value of a data item.
  1. The reserved word ‘IS’ is optional and may be omitted.  The
     presence or absence of this word has no effect upon the program.

  2. The following table summarizes the various USAGE specifications
     available in GnuCOBOL.

     BINARY
     ~~~~~~

          Range of Values:              Defined by the quantity of ‘9’s and
                                        the presence or absence of an ‘S’ in
                                        the ‘PICTURE’
                                        
          Storage Format:               Compatible Binary Integer
                                        
          Negative Values Allowed?:     If ‘PICTURE’ contains ‘S’
                                        
          ‘PICTURE’ Used?:              Yes
                                        

     BINARY-C-LONG [ SIGNED ]
     ~~~~~~~~~~~~~

          Range of Values:              Depending on the system hardware, the
                                        range is either 0 to 2**31 or 0 to
                                        2**63.

     BINARY-C-LONG UNSIGNED
     ~~~~~~~~~~~~~ ~~~~~~~~

          Range of Values:              Depending on the system hardware, the
                                        range is either 0 to 2**32 or 0 to
                                        2**64.
                                        
          Restrictions:                 This USAGE should only be used for
                                        direct CALLs into C and otherwise
                                        should not be used (and it won't
                                        compile with any strict -std as it is
                                        a GnuCOBOL-only extension).

     BINARY-CHAR [ SIGNED ]
     ~~~~~~~~~~~

          Range of Values:              -128 - 127
                                        
          Storage Format:               Native Binary Integer
                                        
          Negative Values Allowed?:     Yes
                                        
          ‘PICTURE’ Used?:              No

     BINARY-CHAR UNSIGNED
     ~~~~~~~~~~~ ~~~~~~~~

          Range of Values:              0 - 255
                                        
          Storage Format:               Native Binary Integer
                                        
          Negative Values Allowed?:     No
                                        
          ‘PICTURE’ Used?:              No

     BINARY-DOUBLE [ SIGNED ]
     ~~~~~~~~~~~~~

          Range of Values:              -9,223,372,036,854,775,808 -
                                        9,223,372,036,854,775,807
                                        
          Storage Format:               Native Binary Integer
                                        
          Negative Values Allowed?:     Yes
                                        
          ‘PICTURE’ Used?:              No

     BINARY-DOUBLE UNSIGNED
     ~~~~~~~~~~~~~ ~~~~~~~~

          Range of Values:              0 - 18,446,744,073,709,551,615
                                        
          Storage Format:               Native Binary Integer
                                        
          Negative Values Allowed?:     No
                                        
          ‘PICTURE’ Used?:              No

     BINARY-INT
     ~~~~~~~~~~

          Same as ‘BINARY-LONG SIGNED’

     BINARY-LONG [ SIGNED ]
     ~~~~~~~~~~~

          Range of Values:              -2,147,483,648 - 2,147,483,647
                                        
          Storage Format:               Native Binary Integer
                                        
          Negative Values Allowed?:     Yes
                                        
          ‘PICTURE’ Used?:              No

     BINARY-LONG UNSIGNED
     ~~~~~~~~~~~ ~~~~~~~~

          Range of Values:              0 - 4,294,967,295
                                        
          Storage Format:               Native Binary Integer
                                        
          Negative Values Allowed?:     No
                                        
          ‘PICTURE’ Used?:              No

     BINARY-LONG-LONG
     ~~~~~~~~~~~~~~~~

          Same as ‘BINARY-DOUBLE SIGNED’

     BINARY-SHORT [ SIGNED ]
     ~~~~~~~~~~~~

          Range of Values:              -32,768 - 32,767
                                        
          Storage Format:               Native Binary Integer
                                        
          Negative Values Allowed?:     Yes
                                        
          ‘PICTURE’ Used?:              No

     BINARY-SHORT UNSIGNED
     ~~~~~~~~~~~~ ~~~~~~~~

          Range of Values:              0 - 65,535
                                        
          Storage Format:               Native Binary Integer
                                        
          Negative Values Allowed?:     No
                                        
          ‘PICTURE’ Used?:              No

     COMPUTATIONAL
     COMP

          Same as ‘BINARY’

     COMPUTATIONAL-1
     COMP-1

          Same as ‘FLOAT-SHORT’

     COMPUTATIONAL-2
     COMP-2

          Same as ‘FLOAT-LONG’

     COMPUTATIONAL-3
     COMP-3

          Same as ‘PACKED-DECIMAL’

     COMPUTATIONAL-4
     COMP-4

          Same as ‘BINARY’

     COMPUTATIONAL-5
     COMP-5

          Range of Values:              Depends on number of ‘9’s in the
                                        ‘PICTURE’ and the ‘binary-size’
                                        setting of the configuration file used
                                        to compile the program
                                        
          Storage Format:               Native Binary Integer
                                        
          Negative Values Allowed?:     If ‘PICTURE’ contains ‘S’
                                        
          ‘PICTURE’ Used?:              Yes

     COMPUTATIONAL-6
     COMP-6

          Range of Values:              Defined by the quantity of ‘9’s and
                                        the presence or absence of an ‘S’ in
                                        the ‘PICTURE’
                                        
          Storage Format:               Unsigned Packed Decimal
                                        
          Negative Values Allowed?:     No
                                        
          ‘PICTURE’ Used?:              Yes

     COMPUTATIONAL-X
     COMP-X

          Range of Values:              If used with ‘PIC X’, allocates one
                                        byte of storage per ‘X’; range of
                                        values is 0 to max storable in that
                                        many bytes.  If used with ‘PIC 9’,
                                        range of values depends on number of
                                        ‘9’s in PICTURE
                                        
          Storage Format:               Native unsigned (X) or signed (9)
                                        Binary
                                        
          Negative Values Allowed?:     If ‘PICTURE’ 9 and contains ‘S’
                                        
          ‘PICTURE’ Used?:              Yes

     DISPLAY
     ~~~~~~~

          Range of Values:              Depends on ‘PICTURE’ -- One character
                                        per X, A, 9, period, $, Z, 0, *, S (if
                                        ‘SEPARATE CHARACTER’ specified), +, -
                                        or B symbol in ‘PICTURE’; Add 2 more
                                        bytes if the ‘DB’ or ‘CR’ editing
                                        symbol is used
                                        
          Storage Format:               Characters
                                        
          Negative Values Allowed?:     If ‘PICTURE’ contains ‘S’
                                        
          ‘PICTURE’ Used?:              Yes

     FLOAT-DECIMAL-16
     ~~~~~~~~~~~~~~~~

          Range of Values:              -9.999999999999999 * 10^{383} -
                                        9.999999999999999 * 10^{384}
                                        
          Storage Format:               Native IEEE 754 Decimal64
                                        Floating-point
                                        
          Negative Values Allowed?:     Yes
                                        
          ‘PICTURE’ Used?:              No

     FLOAT-DECIMAL-34
     ~~~~~~~~~~~~~~~~

          Range of Values:              -9.99999...  * 10^{6143} - 9.99999...
                                        * 10^{6144}
                                        
          Storage Format:               Native IEEE 754 Decimal128
                                        Floating-point
                                        
          Negative Values Allowed?:     Yes
                                        
          ‘PICTURE’ Used?:              No

     FLOAT-LONG
     ~~~~~~~~~~

          Range of Values:              Approximately -1.797693134862316 *
                                        10^{308} - 1.797693134862316 *
                                        10^{308}
                                        
          Storage Format:               Native IEEE 754 Binary64
                                        Floating-point
                                        
          Negative Values Allowed?:     Yes
                                        
          ‘PICTURE’ Used?:              No

     FLOAT-SHORT
     ~~~~~~~~~~~

          Range of Values:              Approximately -3.4028235 * 10^{38} -
                                        3.4028235 * 10^{38}
                                        
          Storage Format:               Native IEEE 754 Binary32
                                        
          Negative Values Allowed?:     Yes
                                        
          ‘PICTURE’ Used?:              No

     INDEX
     ~~~~~

          Range of Values:              0 to maximum address possible (32 or
                                        64 bits)
                                        
          Storage Format:               Native Binary Integer
                                        
          Negative Values Allowed?:     No
                                        
          ‘PICTURE’ Used?:              No

     NATIONAL
     ~~~~~~~~

          ‘USAGE NATIONAL’, while syntactically recognized, is not supported
          by GnuCOBOL

     PACKED-DECIMAL
     ~~~~~~~~~~~~~~

          Range of Values:              Defined by the quantity of ‘9’s and
                                        the presence or absence of an ‘S’ in
                                        the PICTURE
                                        
          Storage Format:               Signed Packed Decimal
                                        
          Negative Values Allowed?:     If ‘PICTURE’ contains ‘S’
                                        
          ‘PICTURE’ Used?:              Yes

     POINTER
     ~~~~~~~

          Range of Values:              0 to maximum address possible (32 or
                                        64 bits)
                                        
          Storage Format:               Native Binary Integer
                                        
          Negative Values Allowed?:     No
                                        
          ‘PICTURE’ Used?:              No

     PROCEDURE-POINTER
     ~~~~~~~~~~~~~~~~~

          Same as ‘PROGRAM-POINTER’

     PROGRAM-POINTER
     ~~~~~~~~~~~~~~~

          Range of Values:              0 to maximum address possible (32 or
                                        64 bits)
                                        
          Storage Format:               Native Binary Integer
                                        
          Negative Values Allowed?:     No
                                        
          ‘PICTURE’ Used?:              No

     SIGNED-INT
     ~~~~~~~~~~

          Same as ‘BINARY-LONG SIGNED’

     SIGNED-LONG
     ~~~~~~~~~~~

          Same as ‘BINARY-DOUBLE SIGNED’

     SIGNED-SHORT
     ~~~~~~~~~~~~

          Same as ‘BINARY-SHORT SIGNED’

     UNSIGNED-INT
     ~~~~~~~~~~~~

          Same as ‘BINARY-LONG UNSIGNED’

     UNSIGNED-LONG
     ~~~~~~~~~~~~~

          Same as ‘BINARY-DOUBLE UNSIGNED’

     UNSIGNED-SHORT
     ~~~~~~~~~~~~~~

          Same as ‘BINARY-SHORT UNSIGNED’

  3. USAGE IS type-name-1
     ~~~~~ ~~

  4. This USAGE clause indicates that the data description of the
     subject of the entry is specified by a user-defined data type.  The
     user-defined data type is defined using the TYPEDEF clause, which
     is described in TYPEDEF clause.


          Example 1:

          01 struct-1     TYPEDEF.
              05  part-1  pic x(20).
              05  part-2  pic x(10).
          01  a.
              05  b       USAGE struct-1.
              05  x       USAGE USHORT.
          01 USHORT       pic 9(04) comp-5 typedef.

          Which would be interpreted as if it had been coded as:

           01  a.
               05  b.
                   10  part-1 pic x(20).
                   10  part-2 pic x(10).
               05  x          pic 9(04) comp-5.

          Example 2:

             IDENTIFICATION   DIVISION.
             PROGRAM-ID.      prog.
             DATA             DIVISION.
             WORKING-STORAGE  SECTION.
             01 MAIN-FILE-NAME-T     PIC X(50) IS TYPEDEF.
             01 DETAIL-NO-T          PIC 9999  IS TYPEDEF.
             01 MAIN-FILE-NAME-2T              IS TYPEDEF.
                05 FILLER            PIC 9999.
                05 DETAIL-NO             USAGE DETAIL-NO-T.

             01  MESSAGE-TEXT-2T               IS TYPEDEF.
               02 MAIN-FILE-NAME         USAGE MAIN-FILE-NAME-T.
               02 FILLER            REDEFINES MAIN-FILE-NAME.
                   05 FILLER         PIC 9999.
               02 MAIN-FILE-NAME-2       USAGE MAIN-FILE-NAME-2T.
               02 FILLER                 USAGE MAIN-FILE-NAME-T.

             01  MESSAGE-TEXT-2 EXTERNAL USAGE MESSAGE-TEXT-2T.

             77 OUTPUT-NAME              USAGE DETAIL-NO-T GLOBAL.

             01 Z-MESSAGE-T2             USAGE MAIN-FILE-NAME-2T.
             01 Z-MESSAGE-T3.
                49 MT3                   USAGE MESSAGE-TEXT-2T.
                49 MT3-REN REDEFINES MT3 USAGE MESSAGE-TEXT-2T.

             PROCEDURE DIVISION.
                 DISPLAY MAIN-FILE-NAME OF MESSAGE-TEXT-2
                 DISPLAY DETAIL-NO         OF Z-MESSAGE-T2
                 DISPLAY MAIN-FILE-NAME OF MT3
                 DISPLAY OUTPUT-NAME
                 GOBACK.

          Example 3:

             77  INT                     PIC S9(09) COMP-5 IS TYPEDEF.
             01  Z-RETURNCODE            USAGE INT VALUE 0.
             01  MESSAGE-TEXT-2                      IS TYPEDEF.
                 02 MAIN-FILE-NAME       PIC X(50).
                 02 FILLER               PIC X(79).
             01 Z-MESSAGE-T2 USAGE MESSAGE-TEXT-2.
             77 VIRMSG-TEXT              PIC  X(129) IS TYPEDEF.
             01  MESSAGE-TEXT-2                      IS TYPEDEF.
                 02 MAIN-FILE-NAME       PIC X(50).
                 02 FILLER               PIC X(79).
             01 Z-MESSAGE-TEXT           USAGE VIRMSG-TEXT.
             01 Z-MESSAGE-T2 REDEFINES Z-MESSAGE-TEXT USAGE MESSAGE-TEXT-2.
             01  W102-TYPE IS TYPEDEF.
                 COPY SERVERFIELDS.
             01 T-A                      USAGE W102-TYPE.
             01 T-N                      USAGE W102-TYPE.

  5. Binary data (integer or floating-point) can be stored in either a
     Big-Endian or Little-Endian form.

     Big-endian data allocation calls for the bytes that comprise a
     binary item to be allocated such that the least-significant byte is
     the right-most byte.  For example, a four-byte binary item having a
     value of decimal 20 would be big-endian allocated as 00000014
     (shown in hexadecimal notation).

     Little-endian data allocation calls for the bytes that comprise a
     binary item to be allocated such that the least-significant byte is
     the left-most byte.  For example, a four-byte binary item having a
     value of decimal 20 would be little-endian allocated as 14000000
     (shown in hexadecimal notation).

     All CPUs are capable of understanding big-endian format, which
     makes it the most compatible form of binary storage across computer
     systems.

     Some CPUs -- such as the Intel/AMD i386/x64 architecture processors
     used in most Windows PCs -- prefer to process binary data stored in
     a little-endian format.  Since that format is more efficient on
     those systems, it is referred to as the native binary format.

     On a system supporting only one format of binary storage
     (generally, that would be big-endian), the terms most efficient and
     native format are synonymous.

  6. Data items that have the ‘UNSIGNED’ attribute explicitly coded, or
     ‘DISPLAY’, ‘PACKED-DECIMAL’, ‘COMP-5’, ‘COMP-X’ items that do not
     have an ‘S’ symbol in their picture clause cannot preserve negative
     values that may be stored into them.  Storing a negative value into
     such a field will actually result in the sign being stripped,
     essentially saving the absolute value in the data item.

  7. Packed-decimal (i.e.  ‘USAGE PACKED-DECIMAL’, ‘USAGE COMP-3’ or
     ‘USAGE COMP-6’) data is stored as a series of bytes such that each
     byte contains two 4-bit fields, referred to as “nibbles” (since
     they comprise half a "byte", they're just "nibbles" -- don't groan,
     I don't just make this stuff up!).  Each nibble represents a ‘9’ in
     the ‘PICTURE’ and each holds a single decimal digit encoded as its
     binary value (0 = 0000, 1 = 0001, ... , 9 = 1001).

     The last byte of a ‘PACKED-DECIMAL’ or ‘COMP-3’ data item will
     always have its left nibble corresponding to the last ‘9’ in the
     ‘PICTURE’ and its right nibble reserved as a sign indicator.  This
     sign indicator is always present regardless of whether or not the
     ‘PICTURE’ included an ‘S’ symbol.

     The first byte of the data item will contain an unused left nibble
     if the ‘PICTURE’ had an even number of ‘9’ symbols in it.

     The sign indicator will have a value of a hexadecimal A through F.
     Traditional packed decimal encoding rules call for hexadecimal
     values of F, A, C or E ("FACE") in the sign nibble to indicate a
     positive value and B or D to represent a negative value
     (hexadecimal digits 0-9 are undefined).  Testing with a Windows
     MinGW/GnuCOBOL implementation shows that -- in fact -- hex digit D
     represents a negative number and any other hexadecimal digit
     denotes a positive number.  Therefore, a ‘PIC S9(3) COMP-3’
     packed-decimal field with a value of -15 would be stored internally
     as a hexadecimal 015D in GnuCOBOL.

     If you attempt to store a negative number into a packed decimal
     field that has no ‘S’ in its ‘PICTURE’, the absolute value of the
     negative number will actually be stored.

     ‘USAGE COMP-6’ does not allow for negative values, therefore no
     sign nibble will be allocated.  A ‘USAGE COMP-6’ data item
     containing an odd number of ‘9’ symbols in its ‘PICTURE’ will leave
     its leftmost nibble unused.

  8. The ‘USAGE’ specifications ‘FLOAT-DECIMAL-16’ and
     ‘FLOAT-DECIMAL-34’ will encode data using IEEE 754 Decimal64 and
     Decimal128 format, respectively.  The former allows for up to 16
     digits of exact precision while the latter offers 34.  The phrase
     "exact precision" is used because the traditional binary renderings
     of decimal real numbers in a floating-point format (‘FLOAT-LONG’
     and ‘FLOAT-SHORT’, for example) only yield an approximation of the
     actual value because many decimal fractions cannot be precisely
     rendered in binary.  The Decimal64 and Decimal128 renderings,
     however, render decimal real numbers in encoded decimal form in
     much the same way that ‘PACKED-DECIMAL’ renders a decimal integer
     in digit-by-digit decimal form.  The exact manner in which this
     rendering is performed is complex (Wikipedia has an excellent
     article on the subject -- just search for Decimal64).

  9. GnuCOBOL stores ‘FLOAT-DECIMAL-16’ and ‘FLOAT-DECIMAL-34’ data
     items using either Big-Endian or Little-Endian form, whichever is
     native to the system.

  10. The ‘USAGE’ specifications ‘FLOAT-LONG’ and ‘FLOAT-SHORT’ use the
     IEEE 754 Binary64 and Binary32 formats, respectively.  These are
     binary encodings of real decimal numbers, and as such cannot
     represent every possible value between the minimum and maximum
     values in the range for those usages.  Wikipedia has an excellent
     article on the Binary64 and Binary32 encoding schemes -- just
     search on Binary32 or Binary64.

     GnuCOBOL stores ‘FLOAT-LONG’ and ‘FLOAT-SHORT’ data items using
     either Big-Endian or Little-Endian form, whichever is native to the
     system.

  11. A ‘USAGE’ clause specified at the group item level will apply that
     ‘USAGE’ to all subordinate data items, except those that themselves
     have a ‘USAGE’ clause.

  12. The only ‘USAGE’ that is allowed in the report section is ‘USAGE
     DISPLAY’.


File: gnucobpg.info,  Node: USING,  Next: VALUE,  Prev: USAGE,  Up: Data Description Clauses

6.9.64 USING
------------

                          USING Clause Syntax
=======================================================================

 USING identifier-1
 ~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘SCREEN’

   This clause logically attaches a screen section data item to another
data item defined elsewhere in the data division.
  1. When the screen item whose definition this clause is part of is
     displayed, the value currently in IDENTIFIER-1 will be
     automatically moved into the screen item first.

  2. When the screen item whose definition this clause is part of (or
     its parent) is accepted, the current contents of the screen item
     will be saved back to IDENTIFIER-1 at the conclusion of the
     ‘ACCEPT’.

  3. The ‘FROM’ (*note FROM::), ‘TO’ (*note TO::), ‘USING’ and ‘VALUE’
     (*note VALUE::) clauses are mutually-exclusive in any screen
     section data item's definition.


File: gnucobpg.info,  Node: VALUE,  Prev: USING,  Up: Data Description Clauses

6.9.65 VALUE
------------

                 VALUE (Condition Names) Clause Syntax
=======================================================================

 { VALUE IS   } {literal-1 [ THRU|THROUGH literal-2 ]}...
 { ~~~~~      }              ~~~~ ~~~~~~~
 { VALUES ARE }
   ~~~~~~
     [ WHEN SET TO FALSE IS literal-3 ]
                   ~~~~~


=======================================================================
                    VALUE (Other Data Items) Syntax
=======================================================================

 VALUE IS [ ALL ] literal-1
 ~~~~~      ~~~


=======================================================================
                       VALUE (For Tables) Syntax
=======================================================================

 { VALUE IS  } {{literal-1}.. FROM ({subscript-1}..) [ TO ({subscript-2}.. )]}..
 { ~~~~~     }                ~~~~                     ~~
 { VALUES ARE }
   ~~~~~~


=======================================================================
   This syntax is valid in the following sections: ‘FILE’,
‘WORKING-STORAGE’, ‘LOCAL-STORAGE’, ‘LINKAGE’, ‘REPORT’, ‘SCREEN’

   The ‘VALUE’ clause is used to define condition names or to assign
values (at compilation time) to data items.
  1. The reserved words ‘ARE’ and ‘IS’ are optional and may be omitted.
     The presence or absence of these words has no effect upon the
     program.

  2. This clause cannot be specified on the same data item as a ‘FROM’
     (*note FROM::), ‘TO’ (*note TO::) or ‘USING’ (*note USING::)
     clause.

  3. The following points apply to using the ‘VALUE’ clause in the
     definition of a condition name:
       A. The clauses ‘VALUE IS’ and ‘VALUES ARE’ are interchangeable.

       B. The reserved words ‘THRU’ and ‘THROUGH’ are interchangeable.

       C. *Note 88-Level Data Items::, for a discussion of how this
          format of ‘VALUE’ is used to create condition names.

       D. *Note Condition Names::, for a discussion of how condition
          names are used.
  4. The following points apply to using the ‘VALUE’ clause in the
     definition of any other data item:
       A. In this context, ‘VALUE’ specifies an initial compilation-time
          value that will be assigned to the storage occupied by the
          data item in the program object code generated by the
          compiler.

       B. The ‘VALUE’ clause is ignored on ‘EXTERNAL’ (*note EXTERNAL::)
          data items or on any data items defines as subordinate to an
          ‘EXTERNAL’ data item.

       C. This format of the ‘VALUE’ clause may not be used anywhere in
          the description of an 01 item (or any of its subordinate
          items) serving as an ‘FD’ or ‘SD’ record description.

       D. If the optional ‘ALL’ clause is used, it may only be used with
          an alphanumeric literal value; the value will be repeated as
          needed to completely fill the data item.  Here are some
          examples with and without ‘ALL’ (the symbol b denotes a
          space):

               PIC X(5) VALUE ‘A’      *> Abbbb
               PIC X(5) VALUE ALL ‘A’  *> AAAAA
               PIC 9(3) VALUE 1        *> 001
               PIC 9(3) VALUE ALL ‘1’  *> 111
       E. When used in the definition of a screen data item:
            a. A figurative constant may not be supplied as LITERAL-1.

            b. Any ‘FROM’ (*note FROM::), ‘TO’ (*note TO::) or ‘USING’
               (*note USING::) clause in the same data item's definition
               will be ignored.

            c. If there is no picture clause specified, the size of the
               screen data item will be the length of the LITERAL-1
               value.

            d. If there is no picture clause and the ‘ALL’ option is
               specified, the ‘ALL’ option will be ignored.
       F. Giving a table an initial, compile-time value is one of the
          trickier aspects of COBOL data definition.  There are
          basically three standard techniques and a fourth that people
          familiar with other COBOL implementations but new to GnuCOBOL
          may find interesting.  So, here are the three standard
          approaches:
            a. Don't bother worrying about it at compile-time.  Use the
               ‘INITIALIZE’ (*note INITIALIZE::) to initialize all data
               item occurrences in a table (at run-time) to their
               data-type-specific default values (numerics: 0,
               alphabetic and alphanumerics: spaces).

            b. Initialize small tables at compile time by including a
               ‘VALUE’ clause on the group item that serves as a parent
               to the table, as follows:

                    05  SHIRT-SIZES          VALUE "S 14M 15L 16XL17".
                        10 SHIRT-SIZE-TBL    OCCURS 4 TIMES.
                           15 SST-SIZE       PIC X(2).
                           15 SST-NECK       PIC 9(2).
            c. Initialize tables of almost any size at compilation time
               by utilizing the ‘REDEFINES’ (*note REDEFINES::) clause:

                    05  SHIRT-SIZE-VALUES.
                        10 PIC X(4)          VALUE "S 14".
                        10 PIC X(4)          VALUE "M 15".
                        10 PIC X(4)          VALUE "L 16".
                        10 PIC X(4)          VALUE "XL17".
                    05  SHIRT-SIZES          REDEFINES SHIRT-SIZE-VALUES.
                        10 SHIRT-SIZE-TBL    OCCURS 4 TIMES.
                           15 SST-SIZE       PIC X(2).
                           15 SST-NECK       PIC 9(2).

               Admittedly, this table is much more verbose than the one
               shown with a group ‘VALUE’.  What is good about this
               initialization technique, however, is that you can have
               as many ‘FILLER’ and ‘VALUE’ items as you need for a
               larger table, and those values can be as long as
               necessary!

       G. Many COBOL compilers do not allow the use of ‘VALUE’ and
          ‘OCCURS’ (*note OCCURS::) on the same data item; additionally,
          they don't allow a ‘VALUE’ clause on a data item subordinate
          to an ‘OCCURS’.  GnuCOBOL, however, has neither of these
          restrictions!

          Observe the following example, which illustrates a fourth
          manner in which tables may be initialized in GnuCOBOL:

               05  X           OCCURS 6 TIMES.
                   10 A        PIC X(1) VALUE '?'.
                   10 B        PIC X(1) VALUE '%'.
                   10 N        PIC 9(2) VALUE 10.

          In this example, all six ‘A’ items will be initialized to ‘?’,
          all six ‘B’ items will be initialized to ‘%’ and all six ‘N’
          items will be initialized to 10.  It's not clear exactly how
          many times this sort of initialization will be useful, but
          it's there if you need it.

  5. The ‘FROM’ (*note FROM::), ‘TO’ (*note TO::), ‘USING’ (*note
     USING::) and ‘VALUE’ clauses are mutually-exclusive in any screen
     section data item's definition.

  6. Format-3 (Table): The value clause for tables specifies the initial
     value of working-storage section and local-storage section data
     items.

          Example 1: Table value clause

           03  Level-1      occurs 10 times.
               05  Level-2  occurs 3 times PIC X.
                               value "A" "B" "C" FROM (2 2) to (3 1)
                                     "X" "Y" "Z" FROM (1 1) to (! 3)
                                     space       FROM (3 2).

          Example 2: Table value clause with Initialize

            01  Group-Items.
                03                  value "Implicit Filler".
                03  filler   pic 1  value B"1".
                03  Var-Table   occurs 10 times
                      pic 9   value 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, (1) to (10).
            . . .
             initialize Group-Items
                       with filler
                         All to value.



File: gnucobpg.info,  Node: PROCEDURE DIVISION,  Next: Functions,  Prev: DATA DIVISION,  Up: Top

7 PROCEDURE DIVISION
********************

                       PROCEDURE DIVISION Syntax
=======================================================================

   PROCEDURE DIVISION [ { USING Subprogram-Argument...     } ]
   ~~~~~~~~~ ~~~~~~~~   { ~~~~~                            }
                        { CHAINING Main-Program-Argument...}
                          ~~~~~~~~
                      [ RETURNING identifier-1 ] .
 [ DECLARATIVES. ]      ~~~~~~~~~
   ~~~~~~~~~~~~
 [ Event-Handler-Routine... . ]

 [ END DECLARATIVES. ]
   ~~~ ~~~~~~~~~~~~
   General-Program-Logic

 [ Nested-Subprogram... ]

 [ END PROGRAM|FUNCTION name-1 ]
   ~~~ ~~~~~~~ ~~~~~~~~


=======================================================================
   The ‘PROCEDURE DIVISION’ of any GnuCOBOL program marks the point
where all executable code is written.
* Menu:

* PROCEDURE DIVISION USING.
* PROCEDURE DIVISION CHAINING.
* PROCEDURE DIVISION RETURNING.
* PROCEDURE DIVISION Sections and Paragraphs.
* DECLARATIVES.
* Common Clauses on Executable Statements.
* AT END + NOT AT END.
* CORRESPONDING.
* INVALID KEY + NOT INVALID KEY.
* ON EXCEPTION + NOT ON EXCEPTION.
* ON OVERFLOW + NOT ON OVERFLOW.
* ON SIZE ERROR + NOT ON SIZE ERROR.
* ROUNDED.
* Special Registers.
* GnuCOBOL Statements.


File: gnucobpg.info,  Node: PROCEDURE DIVISION USING,  Next: PROCEDURE DIVISION CHAINING,  Up: PROCEDURE DIVISION

7.1 PROCEDURE DIVISION USING
============================

             PROCEDURE DIVISION Subprogram-Argument Syntax
=======================================================================

 [ BY { REFERENCE [ OPTIONAL ]                       } ] identifier-1
      { ~~~~~~~~~   ~~~~~~~~                         }
      { VALUE [ [ UNSIGNED ] SIZE IS { AUTO      } ] }
        ~~~~~     ~~~~~~~~   ~~~~    { ~~~~      }
                                     { DEFAULT   }
                                     { ~~~~~~~   }
                                     { integer-1 }


=======================================================================
   The ‘USING’ clause defines the arguments that will be passed to a
GnuCOBOL program which is serving as a subprogram.
  1. The reserved words ‘BY’ and ‘IS’ are optional and may be omitted.
     The presence or absence of these words have no effect upon the
     program.

  2. The ‘USING’ clause should only be used on the procedure division
     header of subprograms (subroutines or user-defined functions).

  3. The calling program will pass zero or more data items, known as
     arguments, to this subprogram -- there must be exactly as many
     IDENTIFIER-1 data items specified on the ‘USING’ clause as the
     maximum number of arguments the subprogram will ever be passed.

  4. If a subprogram does not expect any arguments, it should not have a
     ‘USING’ clause specified on its procedure division header.

  5. The order in which arguments are defined on the ‘USING’ clause must
     correspond to the order in which those arguments will be passed to
     the subprogram by the calling program.

  6. The identifiers specified on the ‘USING’ clause must be defined in
     the linkage section of the subprogram.  No storage is actually
     allocated for those identifiers in the subprogram as the actual
     storage for them will exist in the calling program.

  7. A GnuCOBOL subprogram expects that all arguments to it will be one
     of two things:
        • The memory address of the actual data item (allocated in the
          calling program) that is being passed to the subprogram.

        • A numeric, full-word, binary value (i.e.  ‘USAGE BINARY-LONG’
          (*note USAGE::)) which is the actual argument being passed to
          the subprogram.

     In the case of the former, the ‘USING’ clause on the procedure
     division header should describe the argument via the ‘BY REFERENCE’
     clause -- in the latter case, a ‘BY VALUE’ specification should be
     coded.  This allows the code generated by the compiler to properly
     reference the subprogram arguments at run-time.

  8. ‘BY REFERENCE’ is the assumed default for the first ‘USING’
     argument should no ‘BY’ clause be specified for it.  Subsequent
     arguments will assume the ‘BY’ specification of the argument prior
     to them should they lack a ‘BY’ clause of their own.

  9. Changes made by a subprogram to the value of an argument specified
     on the ‘USING’ clause will "be visible" to the calling program only
     if ‘BY REFERENCE’ was explicitly specified or implicitly assumed
     for the argument on the subprogram's procedure division header and
     the argument was passed to the subprogram ‘BY REFERENCE’ by the
     calling program.  *Note Subprogram Arguments::, for additional
     information on the mechanics of how arguments are passed to
     subprograms.

  10. The optional ‘SIZE’ clause allows you to specify the number of
     bytes a ‘BY VALUE’ argument will occupy, with ‘SIZE DEFAULT’
     specifying 4 bytes (this is the default if no ‘SIZE’ clause is
     used), ‘SIZE AUTO’ specifying the size of the argument in the
     calling program and ‘SIZE INTEGER-1’ specifying a specific byte
     count.

  11. The optional ‘UNSIGNED’ keyword, legal only if ‘SIZE AUTO’ or
     ‘SIZE INTEGER-1’ are coded, will add the ‘unsigned’ attribute to
     the argument's specification in the C-language function header code
     generated for the subprogram.  While not of any benefit when the
     calling program is a GnuCOBOL program, this can improve
     compatibility with a C-language calling program.

  12. The ‘OPTIONAL’ keyword, legal only on ‘BY REFERENCE’ arguments,
     allows calling programs to code ‘OMITTED’ for that corresponding
     argument when they call this subprogram.  *Note CALL::.  for
     additional information on this feature.


File: gnucobpg.info,  Node: PROCEDURE DIVISION CHAINING,  Next: PROCEDURE DIVISION RETURNING,  Prev: PROCEDURE DIVISION USING,  Up: PROCEDURE DIVISION

7.2 PROCEDURE DIVISION CHAINING
===============================

            PROCEDURE DIVISION Main-Program-Argument Syntax
=======================================================================

 [ BY REFERENCE ] [ OPTIONAL ] identifier-1
      ~~~~~~~~~     ~~~~~~~~


=======================================================================
   The ‘CHAINING’ term provides one mechanism a programmer may use to
retrieve command-line arguments passed to a program at execution time.
  1. ‘PROCEDURE DIVISION CHAINING’ may only be coded in a main program
     (that is, the first program executed when a compiled GnuCOBOL
     compilation unit is executed).  It cannot be used in any form of
     subprogram.

  2. The ‘CHAINING’ clause defines arguments that will be passed to a
     main program from the operating system.  The argument identifiers
     specified on the ‘CHAINING’ clause will be populated by character
     strings comprised of the parameters specified to the program on the
     command line that executed it, as follows:
       A. When a GnuCOBOL program is executed from a command-line, the
          complete command line text will be broken into a series of
          tokens, where each token is identified as being a word
          separated from the others in the command text by at least one
          space.  For example, if the command line was
          ‘/usr/local/myprog THIS IS A TEST’, there will be five tokens
          identified by the operating system -- ‘/usr/local/myprog’,
          ‘THIS’, ‘IS’, ‘A’ and ‘TEST’.

       B. Multiple space-delimited tokens may be treated as a single
          token by enclosing them in quotes.  For example, there are
          only three tokens generated from the command line
          ‘C:\Pgms\myprog.exe ‘THIS IS A’ TEST’ -- ‘C:\Pgms\myprog.exe’,
          ‘THIS IS A’ and ‘TEST’.  When quote characters are used to
          create multi-word tokens, the quote characters themselves are
          stripped from the token's value.

       C. Once tokens have been identified, the first one (the command)
          will be discarded; the rest will be stored into the ‘CHAINING’
          arguments when the program begins execution, with the 2nd
          token going to the 1^{st} argument, the 3rd token going to the
          2nd argument and so forth.

       D. If there are more tokens than there are arguments, the excess
          tokens will be discarded.

       E. If there are fewer tokens than there are arguments, the excess
          arguments will be initialized as if the ‘INITIALIZE
          IDENTIFIER-1’ (*note INITIALIZE::) statement were executed.

       F. All identifiers specified on the ‘CHAINING’ clause should be
          defined as ‘PIC X, PIC A’, group items (which are treated
          implicitly as ‘PIC X’) or as ‘PIC 9 USAGE DISPLAY’.  The use
          of ‘USAGE BINARY’ (or the like) data items as ‘CHAINING’
          arguments is not recommended as all command-line tokens will
          be retained in their original character form as they are moved
          into the argument data items.

       G. If an argument identifier is smaller in storage size than the
          token value to be stored in it, the right-most excess
          characters of the token value will be truncated as the value
          is moved in.  Any ‘JUSTIFIED RIGHT’ clause on such an argument
          identifier will be ignored.

       H. If an argument is larger in storage size than the token value
          to be stored in it, the token value will be moved into the
          argument identifier in a left-justified manner.
          unmodified-modified byte positions in the identifier will be
          space filled, unless the argument identifier is defined as
          ‘PIC 9 USAGE DISPLAY’, in which case unmodified bytes will be
          filled with ‘0’ characters from the systems native character
          set.

          This behaviour when the argument is defined as ‘PIC 9’ may be
          unacceptable, as an argument defined as ‘PIC 9(3)’ but passed
          in a value of ‘1’ from the command line will receive a value
          of ‘100’, not ‘001’.  Consider defining "numeric" command line
          arguments as ‘PIC X’ and then using the ‘NUMVAL’ intrinsic
          function (*note NUMVAL::) function to determine the proper
          numeric value.


File: gnucobpg.info,  Node: PROCEDURE DIVISION RETURNING,  Next: PROCEDURE DIVISION Sections and Paragraphs,  Prev: PROCEDURE DIVISION CHAINING,  Up: PROCEDURE DIVISION

7.3 PROCEDURE DIVISION RETURNING
================================

                  PROCEDURE DIVISION RETURNING Syntax
=======================================================================

 RETURNING identifier-1
 ~~~~~~~~~


=======================================================================
   The RETURNING clause on the PROCEDURE DIVISION header documents that
the subprogram in which the clause appears will be returning a numeric
value back to the program that called it.  This is only available for
functions as it does not work for programs and has issues depending on
the platform (operating system) in use - You must test for this for the
specific platform.
  1. The ‘RETURNING’ clause is optional within a subroutine, as not all
     subroutines return a value to their caller.

  2. The ‘RETURNING’ clause is mandatory within a user-defined function,
     as all such must return a numeric result.

  3. The IDENTIFIER-1 data item should be defined as a ‘USAGE
     BINARY-LONG’ data item.

  4. Main programs that wish to "pass back" a return code value to the
     operating system when they exit do not use ‘RETURNING’ - they do so
     simply by MOVEing a value to the ‘RETURN-CODE’ special register.

  5. This is not the only mechanism that a subprogram may use to pass a
     value back to its caller.  Other possibilities are:
       A. The subprogram may modify any argument that is specified as
          ‘BY REFERENCE’ on its ‘PROCEDURE DIVISION’ header.  Whether
          the calling program can actually "see" any modifications
          depends upon how the calling program passed the argument to
          the subprogram.  *Note CALL::, for more information.

       B. A data item with the ‘GLOBAL’ (*note GLOBAL::) attribute
          specified in its description in the calling program is
          automatically visible to and updatable by a subprogram nested
          with the calling program.  *Note Independent vs Contained vs
          Nested Subprograms::, for more information on subprogram
          nesting.

       C. A data item defined with the ‘EXTERNAL’ (*note EXTERNAL::)
          attribute in a subprogram and the calling program (same name
          in both programs) is automatically visible to and updatable by
          both programs, even if those programs are compiled separately
          from one another.


File: gnucobpg.info,  Node: PROCEDURE DIVISION Sections and Paragraphs,  Next: DECLARATIVES,  Prev: PROCEDURE DIVISION RETURNING,  Up: PROCEDURE DIVISION

7.4 PROCEDURE DIVISION Sections and Paragraphs
==============================================

The procedure division is the only one of the COBOL divisions that
allows you to create your own sections and paragraphs.  These are
collectively referred to as “Procedures”, and the names you create for
those sections and paragraphs are called “Procedure Names”.

   Procedure names are optional in the procedure division and -- when
used -- are named entirely according to the needs and whims of the
programmer.

   Procedure names may be up to thirty one (31) characters long and may
consist of letters, numbers, dashes and underscores.  A procedure name
may neither begin nor end with a dash (‘-’) or underscore (‘_’)
character.  This means that ‘Main’, ‘0100-Read-Transaction’ and ‘17’ are
all perfectly valid procedure names.

   There are three circumstances under which the use of certain GnuCOBOL
statements or options will require the specification of procedures.
These situations are:
  1. When ‘DECLARATIVES’ (*note DECLARATIVES::) are specified.

  2. When the ‘ENTRY’ statement (*note ENTRY::) is being used.

  3. When any procedure division statement that references procedures is
     used.  These statements are:
        • ‘ALTER PROCEDURE-NAME’

        • ‘GO TO PROCEDURE-NAME’

        • ‘MERGE ... OUTPUT PROCEDURE PROCEDURE-NAME’

        • ‘PERFORM PROCEDURE-NAME’

        • ‘SORT ... INPUT PROCEDURE PROCEDURE-NAME’ and/or ‘SORT ...
          OUTPUT PROCEDURE PROCEDURE-NAME’


File: gnucobpg.info,  Node: DECLARATIVES,  Next: Common Clauses on Executable Statements,  Prev: PROCEDURE DIVISION Sections and Paragraphs,  Up: PROCEDURE DIVISION

7.5 DECLARATIVES
================

                          DECLARATIVES Syntax
=======================================================================

 [ DECLARATIVES.                                         ]
 [ ~~~~~~~~~~~~~                                         ]
 [ {section-name-1 SECTION.                              ]
 [                 ~~~~~~~~                              ]
 [ USE statement.                                      ]
 [                                                       ]
 [ [sentence]...[paragraph-name-1. [sentence]...]...}...]
 [                                                       ]
 [ END DECLARATIVES.                                     ]
 [ ~~~~~~~~~~~~~~~~~                                     ]

Where the USE statement can be one of 4 formats:
 1.FILE EXCEPTIONS procedure,
 2.DEBUGGING procedures,
 3.REPORTING procedure to be executed before the printing of the designated
   Report Group,
 4.EXCEPTION CONDITIONS procedures to be executed after detection of exception
   conditions.

 USE { [ GLOBAL ] AFTER STANDARD { EXCEPTION } PROCEDURE ON { INPUT           } }
 ~~~ {   ~~~~~~                  { ~~~~~~~~~ }              { ~~~~~           } }
     {                           { ERROR     }              { OUTPUT          } }
     {                           { ~~~~~     }              { ~~~~~~          } }
     {                                                      { I-O             } }
     {                                                      { ~~~             } }
     {                                                      { EXTEND          } }
     {                                                      { ~~~~~~          } }
     {                                                      { {file-name-1 }..} }
     {                                                                          }
     {                                                                          }
     { FOR DEBUGGING ON { procedure-name-1           }                          }
     {     ~~~~~~~~~    { ALL PROCEDURES             }                          }
     {                  { ~~~ ~~~~~~~~~~             }                          }
     {                  { REFERENCES OF identifier-1 }                          }
     {                                                                          }
     { [ GLOBAL ] BEFORE REPORTING identifier-2                                 }
     {  ~~~~~~   ~~~~~~ ~~~~~~~~~                                               }
     {                                                                          }
     { AFTER {EC|EXCEPTION CONDITION} {exception-name-1                       } }
     {       ~~ ~~~~~~~~~ ~~~~~~~~~   {exception-name-2 {FILE file-name-2}..} } }
     {                                                   ~~~~                   }

   The ‘AFTER EXCEPTION CONDITION’ and ‘AFTER EC’ clauses are
syntactically recognized but are otherwise non-functional.

=======================================================================
   The ‘DECLARATIVES’ area of the procedure division allows the
programmer to define a series of "trap" procedures (referred to as
declarative procedures) capable of intercepting certain events that may
occur at program execution time.  The syntax diagram above shows the
format of a single such procedure.

  1. The reserved words ‘AFTER’, ‘FOR’, ‘ON’, ‘PROCEDURE’ and ‘STANDARD’
     are optional and may be omitted.  The presence or absence of these
     words has no effect upon the program.

  2. ‘EC’ and ‘EXCEPTION CONDITION’ are interchangeable.

  3. The declaratives area may contain any number of declarative
     procedures, but no two declarative procedures should be coded to
     trap the same event.

  4. The following points apply to the ‘USE BEFORE REPORTING’ clause:
       A. IDENTIFIER-2 must be a report group.

       B. At run-time, the declaratives procedure will be executed prior
          to the processing of the specified report group's
          presentation; within the procedure you may take either of the
          following actions:
             • You may adjust the value(s) of any items referenced in
               ‘SUM’ (*note SUM::) or ‘SOURCE’ (*note SOURCE::) clauses
               in the report group.

             • You may execute the ‘SUPPRESS’ (*note SUPPRESS::)
               statement to squelch the presentation of the specified
               report group altogether.  Note that you will be
               suppressing this one specific instance of that group's
               presentation and not all of them.
  5. The following points apply to the ‘USE FOR DEBUGGING’ clause:
       A. This clause allows you to define a declarative procedure that
          will be invoked whenever...
             • ...IDENTIFIER-1 is referenced on any statement.

             • ...PROCEDURE-NAME-1 is executed.

             • ...any procedure is executed (‘ALL PROCEDURES’).
       B. A ‘USE FOR DEBUGGING’ declarative procedure will be ignored at
          compilation time unless ‘WITH DEBUGGING MODE’ is specified in
          the ‘SOURCE-COMPUTER’ (*note SOURCE-COMPUTER::) paragraph.
          Neither the compiler's ‘-fdebugging-line’ switch nor ‘-debug’
          switch will activate this feature.

       C. Any ‘USE FOR DEBUGGING’ declarative procedures will be ignored
          at execution time unless the ‘COB_SET_DEBUG’ run-time
          environment variable (*note Run Time Environment Variables::)
          has been set to a value of ‘Y’, ‘y’ or ‘1’.

       D. The typical use of a ‘USE FOR DEBUGGING’ declarative procedure
          is to display the ‘DEBUG-ITEM’ special register, which will be
          implicitly and automatically created in your program for you
          if ‘WITH DEBUGGING MODE’ is active.

          The structure of ‘DEBUG-ITEM’ will be as follows:

               01  DEBUG-ITEM.
                   05 DEBUG-LINE      PIC X(6).
                   05 FILLER          PIC X(1) VALUE SPACE.
                   05 DEBUG-NAME      PIC X(31).
                   05 FILLER          PIC X(1) VALUE SPACE.
                   05 DEBUG-SUB-1     PIC S9(4) SIGN LEADING SEPARATE.
                   05 FILLER          PIC X(1) VALUE SPACE.
                   05 DEBUG-SUB-2     PIC S9(4) SIGN LEADING SEPARATE.
                   05 FILLER          PIC X(1) VALUE SPACE.
                   05 DEBUG-SUB-3     PIC S9(4) SIGN LEADING SEPARATE.
                   05 FILLER          PIC X(1) VALUE SPACE.
                   05 DEBUG-CONTENTS  PIC X(31).

          where...
          ‘DEBUG-LINE’
               ... is the program line number of the statement that
               triggered the declaratives procedure.

          ‘DEBUG-NAME’
               ... is the procedure name or identifier name that
               triggered the declaratives procedure.

          ‘DEBUG-SUB-1’
               ... is the first subscript value (if any) for the
               reference of the identifier that triggered the
               declaratives procedure.

          ‘DEBUG-SUB-2’
               ... is the second subscript value (if any) for the
               reference of the identifier that triggered the
               declaratives procedure.

          ‘DEBUG-SUB-3’
               ... is the third subscript value (if any) for the
               reference of the identifier that triggered the
               declaratives procedure.

          ‘DEBUG-CONTENTS’
               ... is a (brief) statement of the manner in which the
               procedure that triggered the declaratives procedure was
               executed or the first 31 characters of the value of the
               identifier whose reference triggered the declaratives
               procedure (the value after the statement was executed).
  6. The ‘USE AFTER STANDARD ERROR PROCEDURE’ clause defines a
     declarative procedure invoked any time a failure is encountered
     with the specified I/O type (or against the specified file(s)).

  7. The ‘GLOBAL’ (*note GLOBAL::) option, if used, allows a declarative
     procedure to be used across the program containing the ‘USE’
     statement and any subprograms nested within that program.

  8. Declarative procedures may not reference any other procedures
     defined outside the scope of DECLARATIVES.


File: gnucobpg.info,  Node: Common Clauses on Executable Statements,  Next: Special Registers,  Prev: DECLARATIVES,  Up: PROCEDURE DIVISION

7.6 Common Clauses on Executable Statements
===========================================

* Menu:

* AT END + NOT AT END.
* CORRESPONDING.
* INVALID KEY + NOT INVALID KEY.
* ON EXCEPTION + NOT ON EXCEPTION.
* ON OVERFLOW + NOT ON OVERFLOW.
* ON SIZE ERROR + NOT ON SIZE ERROR.
* ROUNDED.


File: gnucobpg.info,  Node: AT END + NOT AT END,  Next: CORRESPONDING,  Up: Common Clauses on Executable Statements

7.6.1 AT END + NOT AT END
-------------------------

                             AT END Syntax
=======================================================================

 [ AT END imperative-statement-1 ]
      ~~~
 [ NOT AT END imperative-statement-2 ]
   ~~~    ~~~


=======================================================================
   ‘AT END’ clauses may be specified on ‘READ’ (*note READ::), ‘RETURN’
(*note RETURN::), ‘SEARCH’ (*note SEARCH::) and ‘SEARCH ALL’ (*note
SEARCH ALL::) statements.
  1. The following points pertain to the use of these clauses on ‘READ’
     (*note READ::) and ‘RETURN’ (*note RETURN::) statements:
       A. The ‘AT END’ clause will -- if present -- cause
          IMPERATIVE-STATEMENT-1 (*note Imperative Statement::) to be
          executed if the statement fails due to a file status of 10
          (end-of-file).  *Note File Status Codes::, for a list of
          possible File Status codes.

          An ‘AT END’ clause will not detect other non-zero file-status
          values.

          Use a ‘DECLARATIVES’ (*note DECLARATIVES::) routine or an
          explicitly-declared file status field tested after the ‘READ’
          or ‘RETURN’ to detect error conditions other than end-of-file.

       B. A ‘NOT AT END’ clause will cause IMPERATIVE-STATEMENT-2 to be
          executed if the ‘READ’ or ‘RETURN’ attempt is successful.

  2. The following points pertain to the use of these clauses on
     ‘SEARCH’ (*note SEARCH::) and ‘SEARCH ALL’ (*note SEARCH ALL::)
     statements:
       A. An ‘AT END’ clause detects and handles the case where either
          form of table search has failed to locate an entry that
          satisfies the search conditions being used.

       B. The ‘NOT AT END’ clause is not allowed on either form of table
          search.


File: gnucobpg.info,  Node: CORRESPONDING,  Next: INVALID KEY + NOT INVALID KEY,  Prev: AT END + NOT AT END,  Up: Common Clauses on Executable Statements

7.6.2 CORRESPONDING
-------------------

Three GnuCOBOL statements -- ‘ADD’ (*note ADD CORRESPONDING::), ‘MOVE’
(*note MOVE CORRESPONDING::) and ‘SUBTRACT’ (*note SUBTRACT
CORRESPONDING::) support the use of a ‘CORRESPONDING’ option:
ADD CORRESPONDING group-item-1 TO group-item-2
MOVE CORRESPONDING group-item-1 TO group-item-2
SUBTRACT CORRESPONDING group-item-1 FROM group-item-2

   This option allows one or more data items within one group item
(GROUP-ITEM-1 -- the first named on the statement) to be paired with
correspondingly-named (hence the name) in a second group item
(GROUP-ITEM-2 -- the second named on the statement).  The contents of
GROUP-ITEM-1 will remain unaffected by the statement while one or more
data items within GROUP-ITEM-2 will be changed.

   In order for DATA-ITEM-1, defined subordinate to group item
GROUP-ITEM-1 to be a corresponding match to DATA-ITEM-2 which is
subordinate to GROUP-ITEM-2, each of the following must be true:
  1. Both DATA-ITEM-1 and DATA-ITEM-2 must have the same name, and that
     name may not explicitly or implicitly be ‘FILLER’.

  2. Both DATA-ITEM-1 and DATA-ITEM-2...
       A. ...must exist at the same relative structural "depth" of
          definition within GROUP-ITEM-1 and GROUP-ITEM-2, respectively

       B. ...and all "parent" data items defined within each group item
          must have identical (but non-‘FILLER’) names.
  3. When used with a ‘MOVE’ verb...
       A. ...one of DATA-ITEM-1 or DATA-ITEM-2 (but not both) is allowed
          to be a group item

       B. ...and it must be valid to move DATA-ITEM-1 TO DATA-ITEM-2.
  4. When used with ‘ADD’ or ‘SUBTRACT’ verbs, both DATA-ITEM-1 and
     DATA-ITEM-2 must be numeric, elementary, unedited items.

  5. Neither DATA-ITEM-1 nor DATA-ITEM-2 may be a ‘REDEFINES’ (*note
     REDEFINES::) or ‘RENAMES’ (*note RENAMES::) of another data item.

  6. Neither DATA-ITEM-1 nor DATA-ITEM-2 may have an ‘OCCURS’ (*note
     OCCURS::) clause, although either may contain subordinate data
     items that do have an ‘OCCURS’ clause (assuming rule 3a applies)

   Observe the definitions of data items ‘Q’ and ‘Y’...

     01  Q.                           01  Y.
         03 X.                            02 A         PIC X(1).
            05 A         PIC 9(1).        02 G1.
            05 G1.                           03 G2.
               10 G2.                           04 B   PIC X(1).
                  15 B   PIC X(1).        02 C         PIC X(1).
            05 C.                         02 G3.
               10 FILLER PIC X(1).           03 G5.
            05 G3.                              04 D   PIC X(1).
               10 G4.                        03 G6     PIC X(1).
                  15 D   PIC X(1).        02 E         PIC 9(1).
            05 E         PIC X(1).        02 F         PIC X(1).
            05 F         REDEFINES V1     02 G         PIC X(4).
                         PIC X(1).        02 H         OCCURS 4 TIMES
            05 G.                                      PIC X(1).
               10 G6     OCCURS 4 TIMES   66 I         RENAMES E.
                         PIC X(1).        02 J.
            05 H         PIC X(4).           03 K.
            05 I         PIC 9(1).              04 L.
            05 J.                                  05 M.
               10 K.
                  15 M   PIC X(1).

   The following are the valid ‘CORRESPONDING’ matches, assuming the
statement ‘MOVE CORRESPONDING X TO Y’ is being executed (there are no
valid corresponding matches for ‘ADD CORRESPONDING’ or ‘SUBTRACT
CORRESPONDING’ because every potential match up violates rule #4):

                              A, B, C, G

   The following are the ‘CORRESPONDING’ match ups that passed rule #1
(but failed on another rule), and the reasons why they failed.

Data    Failure Reason
Item
--------------------------------------------------------------------------
‘D’     Fails due to rule #2b
‘E’     Fails due to rule #3b
‘F’     Fails due to rule #5
‘G1’    Fails due to rule #3a
‘G2’    Fails due to rule #3a
‘G3’    Fails due to rule #3a
‘G4’    Fails due to rule #1
‘G5’    Fails due to rule #1
‘G6’    Fails due to rule #6
‘H’     Fails due to rule #6
‘I’     Fails due to rule #5
‘J’     Fails due to rule #3a
‘K’     Fails due to rule #3a
‘L’     Fails due to rule #1
‘M’     Fails due to rule #2a


File: gnucobpg.info,  Node: INVALID KEY + NOT INVALID KEY,  Next: ON EXCEPTION + NOT ON EXCEPTION,  Prev: CORRESPONDING,  Up: Common Clauses on Executable Statements

7.6.3 INVALID KEY + NOT INVALID KEY
-----------------------------------

                          INVALID KEY Syntax
=======================================================================

 [ INVALID KEY imperative-statement-1 ]
   ~~~~~~~
 [ NOT INVALID KEY imperative-statement-2 ]
   ~~~ ~~~~~~~


=======================================================================
   ‘INVALID KEY’ clauses may be specified on ‘DELETE’ (*note DELETE::),
‘READ’ (*note Random READ::), ‘REWRITE’ (*note REWRITE::), ‘START’
(*note START::) and ‘WRITE’ (*note WRITE::) statements.

   Specification of an ‘INVALID KEY’ clause will allow your program to
trap an I/O failure condition (with an I/O error code in the file's
‘FILE-STATUS’ (*note SELECT::) field) that has occurred due to a
record-not-found condition and handle it gracefully by executing
IMPERATIVE-STATEMENT-1 (*note Imperative Statement::).

   An optional ‘NOT INVALID KEY’ clause will cause
IMPERATIVE-STATEMENT-2 to be executed if the statement's execution was
successful.


File: gnucobpg.info,  Node: ON EXCEPTION + NOT ON EXCEPTION,  Next: ON OVERFLOW + NOT ON OVERFLOW,  Prev: INVALID KEY + NOT INVALID KEY,  Up: Common Clauses on Executable Statements

7.6.4 ON EXCEPTION + NOT ON EXCEPTION
-------------------------------------

                          ON EXCEPTION Syntax
=======================================================================

 [ ON EXCEPTION imperative-statement-1 ]
      ~~~~~~~~~
 [ NOT ON EXCEPTION imperative-statement-2 ]
   ~~~    ~~~~~~~~~


=======================================================================
   ‘EXCEPTION’ clauses may be specified on ‘ACCEPT’ (*note ACCEPT::),
‘CALL’ (*note CALL::) and ‘DISPLAY’ (*note DISPLAY::) statements.

   Specification of an exception clause will allow your program to trap
a failure condition that has occurred and handle it gracefully by
executing IMPERATIVE-STATEMENT-1 (*note Imperative Statement::).  If
such a condition occurs at runtime without having one of these clauses
specified, an error message will be generated (by the GnuCOBOL runtime
library) to the ‘SYSERR’ device (pipe 2).  The program may also be
terminated, depending upon the type and severity of the error.

   An optional ‘NOT ON EXCEPTION’ clause will cause
IMPERATIVE-STATEMENT-2 to be executed if the statement's execution was
successful.


File: gnucobpg.info,  Node: ON OVERFLOW + NOT ON OVERFLOW,  Next: ON SIZE ERROR + NOT ON SIZE ERROR,  Prev: ON EXCEPTION + NOT ON EXCEPTION,  Up: Common Clauses on Executable Statements

7.6.5 ON OVERFLOW + NOT ON OVERFLOW
-----------------------------------

                          ON OVERFLOW Syntax
=======================================================================

 [ ON OVERFLOW imperative-statement-1 ]
      ~~~~~~~~
 [ NOT ON OVERFLOW imperative-statement-2 ]
   ~~~    ~~~~~~~~


=======================================================================
   ‘OVERFLOW’ clauses may be specified on ‘CALL’ (*note CALL::),
‘STRING’ (*note STRING::) and ‘UNSTRING’ (*note UNSTRING::) statements.

   An ‘ON OVERFLOW’ clause will allow your program to trap a failure
condition that has occurred and handle it gracefully by executing
IMPERATIVE-STATEMENT-1 (*note Imperative Statement::).  If such a
condition occurs at runtime without having one of these clauses
specified, an error message will be generated (by the GnuCOBOL runtime
library) to the ‘SYSERR’ device (pipe 2).  The program may also be
terminated, depending upon the type and severity of the error.

   An optional ‘NOT ON OVERFLOW’ clause will cause
IMPERATIVE-STATEMENT-2 to be executed if the statement's execution was
successful.


File: gnucobpg.info,  Node: ON SIZE ERROR + NOT ON SIZE ERROR,  Next: ROUNDED,  Prev: ON OVERFLOW + NOT ON OVERFLOW,  Up: Common Clauses on Executable Statements

7.6.6 ON SIZE ERROR + NOT ON SIZE ERROR
---------------------------------------

                         ON SIZE ERROR Syntax
=======================================================================

 [ ON SIZE ERROR imperative-statement-1 ]
      ~~~~ ~~~~~
 [ NOT ON SIZE ERROR imperative-statement-2 ]
   ~~~    ~~~~ ~~~~~


=======================================================================
   ‘SIZE ERROR’ clauses may be included on ‘ADD’ (*note ADD::),
‘COMPUTE’ (*note COMPUTE::), ‘DIVIDE’ (*note DIVIDE::), ‘MULTIPLY’
(*note MULTIPLY::) and ‘SUBTRACT’ (*note SUBTRACT::) statements.

   Including an ‘ON SIZE ERROR’ clause on an arithmetic statement will
allow your program to trap a failure of an arithmetic statement (either
generating a result too large for the receiving field, or attempting to
divide by zero) and handle it gracefully by executing
IMPERATIVE-STATEMENT-1 (*note Imperative Statement::).  Field size
overflow conditions occur silently, usually without any runtime messages
being generated, even though such events rarely lend themselves to
generating correct results.  Division by zero errors, when no ‘ON SIZE
ERROR’ clause exists, will produce an error message (by the GnuCOBOL
runtime library) to the ‘SYSERR’ device (pipe 2) and will also abort the
program.

   An optional ‘NOT ON SIZE ERROR’ clause will cause
IMPERATIVE-STATEMENT-2 to be executed if the arithmetic statement's
execution was successful.


File: gnucobpg.info,  Node: ROUNDED,  Prev: ON SIZE ERROR + NOT ON SIZE ERROR,  Up: Common Clauses on Executable Statements

7.6.7 ROUNDED
-------------

                            ROUNDED Syntax
=======================================================================

 ROUNDED [ MODE IS { AWAY-FROM-ZERO         }
 ~~~~~~~   ~~~~    { ~~~~~~~~~~~~~~         }
                   { NEAREST-AWAY-FROM-ZERO }
                   { ~~~~~~~~~~~~~~~~~~~~~~ }
                   { NEAREST-EVEN           }
                   { ~~~~~~~~~~~~           }
                   { NEAREST-TOWARD-ZERO    }
                   { ~~~~~~~~~~~~~~~~~~~    }
                   { PROHIBITED             }
                   { ~~~~~~~~~~             }
                   { TOWARD-GREATER         }
                   { ~~~~~~~~~~~~~~         }
                   { TOWARD-LESSER          }
                   { ~~~~~~~~~~~~~          }
                   { TRUNCATION             }
                     ~~~~~~~~~~


=======================================================================
   GnuCOBOL provides for control over the final rounding process applied
to the receiving fields on all arithmetic verbs.  Each of the arithmetic
statements (‘ADD’ (*note ADD::), ‘COMPUTE’ (*note COMPUTE::), ‘DIVIDE’
(*note DIVIDE::), ‘MULTIPLY’ (*note MULTIPLY::) and ‘SUBTRACT’ (*note
SUBTRACT::)) statements allow an optional ‘ROUNDED’ clause to be applied
to each receiving data item.

   The following rules apply to the rounding behaviour induced by this
clause.
  1. Rounding only applies when the result being saved to a receiving
     field with a ‘ROUNDED’ clause is a non-integer value.

  2. Absence of a ‘ROUNDED’ clause is the same as specifying ‘ROUNDED
     MODE IS TRUNCATION’.

  3. Use of a ‘ROUNDED’ clause without a ‘MODE’ specification is the
     same as specifying ‘ROUNDED MODE IS NEAREST-AWAY-FROM-ZERO’.

   The behaviour of the eight different rounding modes is defined in the
following table.  Note that a ‘...’ indicates the last digit repeats.
The examples assume an integer receiving field.
‘AWAY-FROM-ZERO’
     Rounding is to the nearest value of larger magnitude.
     -3.510 ⇒ -4                          +3.510 ⇒ +4
     -3.500 ⇒ -4                          +3.500 ⇒ +4
     -3.499... ⇒ -4                       +3.499... ⇒ +4
     -2.500 ⇒ -3                          +2.500 ⇒ +3
     -2.499... ⇒ -3                       +2.499... ⇒ +3
‘NEAREST-AWAY-FROM-ZERO’
     Rounding is to the nearest value (larger or smaller).  If two
     values are equally near, the value with the larger absolute value
     is selected.
     -3.510 ⇒ -4                          +3.510 ⇒ +4
     -3.500 ⇒ -4                          +3.500 ⇒ +4
     -3.499... ⇒ -3                       +3.499... ⇒ +3
     -2.500 ⇒ -3                          +2.500 ⇒ +3
     -2.499... ⇒ -2                       +2.499... ⇒ +2
‘NEAREST-EVEN’
     Rounding is to the nearest value (larger or smaller).  If two
     values are equally near, the value whose rightmost digit is even is
     selected.  This mode is sometimes called "Banker's rounding".
     -3.510 ⇒ -4                          +3.510 ⇒ +4
     -3.500 ⇒ -4                          +3.500 ⇒ +4
     -3.499... ⇒ -3                       +3.499... ⇒ +3
     -2.500 ⇒ -2                          +2.500 ⇒ +2
     -2.499... ⇒ -2                       +2.499... ⇒ +2
‘NEAREST-TOWARD-ZERO’
     Rounding is to the nearest value (larger or smaller).  If two
     values are equally near, the value with the smaller absolute value
     is selected.
     -3.510 ⇒ -4                          +3.510 ⇒ +4
     -3.500 ⇒ -3                          +3.500 ⇒ +3
     -3.499... ⇒ -3                       +3.499... ⇒ +3
     -2.500 ⇒ -2                          +2.500 ⇒ +2
     -2.499... ⇒ -2                       +2.499... ⇒ +2
‘PROHIBITED’
     No rounding is performed.  If the value cannot be represented
     exactly in the desired format, the ‘EC-SIZE-TRUNCATION’ condition
     (exception code 1005) is set (and may be retrieved via the ‘ACCEPT’
     (*note ACCEPT FROM Runtime-Info::) statement) and the results of
     the operation are undefined.
     -3.510 ⇒ Undefined                   +3.510 ⇒ Undefined
     -3.500 ⇒ Undefined                   +3.500 ⇒ Undefined
     -3.499... ⇒ Undefined                +3.499... ⇒ Undefined
     -2.500 ⇒ Undefined                   +2.500 ⇒ Undefined
     -2.499... ⇒ Undefined                +2.499... ⇒ Undefined
‘TOWARD-GREATER’
     Rounding is toward the nearest value whose algebraic value is
     larger.
     -3.510 ⇒ -3                          +3.510 ⇒ +4
     -3.500 ⇒ -3                          +3.500 ⇒ +4
     -3.499... ⇒ -3                       +3.499... ⇒ +4
     -2.500 ⇒ -2                          +2.500 ⇒ +3
     -2.499... ⇒ -2                       +2.499... ⇒ +3
‘TOWARD-LESSER’
     Rounding is toward the nearest value whose algebraic value is
     smaller.
     -3.510 ⇒ -4                          +3.510 ⇒ +3
     -3.500 ⇒ -4                          +3.500 ⇒ +3
     -3.499... ⇒ -4                       +3.499... ⇒ +3
     -2.500 ⇒ -3                          +2.500 ⇒ +2
     -2.499... ⇒ -3                       +2.499... ⇒ +2
‘TRUNCATION’
     Rounding is to the nearest value whose magnitude is smaller.
     -3.510 ⇒ -3                          +3.510 ⇒ +3
     -3.500 ⇒ -3                          +3.500 ⇒ +3
     -3.499... ⇒ -3                       +3.499... ⇒ +3
     -2.500 ⇒ -2                          +2.500 ⇒ +2
     -2.499... ⇒ -2                       +2.499... ⇒ +2


File: gnucobpg.info,  Node: Special Registers,  Next: GnuCOBOL Statements,  Prev: Common Clauses on Executable Statements,  Up: PROCEDURE DIVISION

7.7 Special Registers
=====================

GnuCOBOL, like other COBOL dialects, includes a number of data items
that are automatically available to a programmer without the need to
actually define them in the data division.  COBOL refers to such items
as registers or special registers.  The special registers available to a
GnuCOBOL program are as follows:
‘COB-CRT-STATUS’
     PIC 9(4) -- This is the default data item allocated for use by the
     ‘ACCEPT DATA-ITEM’ statement (*note ACCEPT data-item::), if no ‘CRT
     STATUS’ (*note SPECIAL-NAMES::) clause was specified..

‘DEBUG-ITEM’
     Group Item -- A group item in which debugging information generated
     by a ‘USE FOR DEBUGGING’ section in the declaratives area of the
     procedure division will place information documenting why the ‘USE
     FOR DEBUGGING’ procedure was invoked.  Consult the ‘DECLARATIVES’
     (*note DECLARATIVES::) documentation for information on the
     structure of this register.

‘LINAGE-COUNTER’
     ‘BINARY-LONG SIGNED’ -- An occurrence of this register exists for
     each selected file having a ‘LINAGE’ (*note
     File/Sort-Description::) clause.  If there are multiple files whose
     file descriptions have ‘LINAGE’ clauses, any explicit references to
     this register will require qualification (using ‘OF file-name’).
     The value of this register will be the current logical line number
     within the page body.  The value of this register cannot be
     modified.

‘LINE-COUNTER’
     ‘BINARY-LONG SIGNED’ -- An occurrence of this register exists for
     each report defined in the program (via an ‘RD’ (*note REPORT
     SECTION::)).  If there are multiple reports, any explicit
     references to this register not made in the report section will
     require qualification (‘OF report-name’).  The value of this
     register will be the current logical line number on the current
     page.  The value of this register cannot be modified.

‘NUMBER-OF-CALL-PARAMETERS’
     ‘BINARY-LONG SIGNED’ -- This register contains the number of
     arguments passed to a subroutine -- the same value that would be
     returned by the ‘C$NARG’ built-in system subroutine (*note
     C$NARG::).  Its value will be zero when referenced in a main
     program.  This register, when referenced from within a user-defined
     function, returns a value of one (‘1’) if the function has any
     number of arguments and a zero if it has no arguments.

‘PAGE-COUNTER’
     ‘BINARY-LONG SIGNED’ -- An occurrence of this register exists for
     each report having an ‘RD’ (*note REPORT SECTION::).  If there are
     multiple such reports, any explicit references to this register not
     made in the report section will require qualification ( ‘OF
     report-name’).  The value of this register will be the current
     report page number.  The value of this register cannot be modified.

‘RETURN-CODE’
     ‘BINARY-LONG SIGNED’ -- This register provides a numeric data item
     into which a subroutine may ‘MOVE’ (*note MOVE::) a value (which
     will then be available to the calling program) prior to
     transferring control back to the program that called it, or into
     which a main program may ‘MOVE’ a value before returning control to
     the operating system.  Many built-in subroutines will return a
     value using this register.  These values are -- by convention --
     used to signify success (usually with a value of 0) or failure
     (usually with a non-zero value) of the process the program was
     attempting to perform.  This register may also be modified by a
     subprogram as a result of that subprogram's use of the ‘RETURNING’
     (*note PROCEDURE DIVISION RETURNING::) clause.

‘SORT-RETURN’
     ‘BINARY-LONG SIGNED’ -- This register is used to report the
     success/fail status of a ‘RELEASE’ (*note RELEASE::) or ‘RETURN’
     (*note RETURN::) statement.  A value of 0 is reported on success.
     A value of 16 denotes failure.  An ‘AT END’ (*note AT END + NOT AT
     END::) condition on a ‘RETURN’ is not considered a failure.

‘WHEN-COMPILED’
     ‘PIC X(16)’ -- This register contains the date and time the program
     was compiled in the format ‘mm/dd/yyhh.mm.ss’.  Note that only a
     two-digit year is provided.
                           LENGTH OF Syntax
=======================================================================

 LENGTH OF numeric-literal-1 | identifier-1
 ~~~~~~


=======================================================================
   Alphanumeric literals and identifiers may optionally be prefixed with
the ‘LENGTH OF’ clause.  The compile-time value generated by this clause
will be the number of bytes in the alphanumeric literal or the defined
size (in bytes) of the identifier.
  1. The reserved word ‘OF’ is optional and may be omitted.  The
     presence or absence of this word has no effect upon the program.
     Here is an example.  The following two GnuCOBOL statements both
     display the same result (27):

          01  Demo-Identifier          PIC X(27).
          ...
              DISPLAY LENGTH OF "This is a LENGTH OF Example"
              DISPLAY LENGTH OF Demo-Identifier

  2. The ‘LENGTH OF’ clause on a literal or identifier reference may
     generally be used anywhere a numeric literal might be specified,
     with the following exceptions:
        • As part of the ‘FROM’ clause of a ‘WRITE’ (*note WRITE::) or
          ‘RELEASE’ statement (*note RELEASE::).

        • As part of the ‘TIMES’ clause of a ‘PERFORM’ statement (*note
          PERFORM::).


File: gnucobpg.info,  Node: GnuCOBOL Statements,  Prev: Special Registers,  Up: PROCEDURE DIVISION

7.8 GnuCOBOL Statements
=======================


* Menu:

* ACCEPT::
* ADD::
* ALLOCATE::
* ALTER::
* CALL::
* CANCEL::
* CLOSE::
* COMMIT::
* COMPUTE::
* CONTINUE::
* DELETE::
* DISPLAY::
* DIVIDE::
* ENTRY::
* EVALUATE::
* EXAMINE::
* EXHIBIT::
* EXIT::
* FREE::
* GENERATE::
* GOBACK::
* GO TO::
* IF::
* INITIALIZE::
* INITIATE::
* INSPECT::
* JSON GENERATE::
* JSON PARSE::
* MERGE::
* MOVE::
* MULTIPLY::
* OPEN::
* PERFORM::
* READ::
* READY TRACE::
* RELEASE::
* RESET TRACE::
* RETURN::
* REWRITE::
* ROLLBACK::
* SEARCH::
* SEARCH ALL::
* SET::
* SORT::
* START::
* STOP::
* STRING::
* SUBTRACT::
* SUPPRESS::
* TERMINATE::
* TRANSFORM::
* UNLOCK::
* UNSTRING::
* WRITE::
* XML GENERATE::
* XML PARSE::


File: gnucobpg.info,  Node: ACCEPT,  Next: ADD,  Up: GnuCOBOL Statements

7.8.1 ACCEPT
------------

* Menu:

* ACCEPT FROM CONSOLE
* ACCEPT FROM COMMAND-LINE
* ACCEPT FROM ENVIRONMENT
* ACCEPT data-item
* ACCEPT FROM DATE/TIME
* ACCEPT FROM Screen-Info
* ACCEPT FROM Runtime-Info
* ACCEPT OMITTED
* ACCEPT FROM EXCEPTION STATUS


File: gnucobpg.info,  Node: ACCEPT FROM CONSOLE,  Next: ACCEPT FROM COMMAND-LINE,  Up: ACCEPT

7.8.1.1 ACCEPT FROM CONSOLE
...........................

                      ACCEPT FROM CONSOLE Syntax
=======================================================================

   ACCEPT { identifier-1 }   [ FROM mnemonic-name-1 ]
   ~~~~~~                      ~~~~
          { OMITTED      }
            ~~~~~~~

 [ END-ACCEPT ]
   ~~~~~~~~~~


=======================================================================
   This format of the ‘ACCEPT’ statement is used to read a value from
the console window or the standard input device and store it into a data
item (IDENTIFIER-1).

  1. If no ‘FROM’ clause is specified, ‘FROM CONSOLE’ is assumed.

  2. The specified MNEMONIC-NAME-1 must either be one of the built-in
     device names ‘CONSOLE’, ‘STDIN’, ‘SYSIN’ or ‘SYSIPT’, or a
     user-defined (*note SPECIAL-NAMES::) mnemonic name attached to one
     of those four device names.

  3. Input will be read either from the console window (‘CONSOLE’) or
     from the system-standard input (pipe 0 = ‘STDIN’, ‘SYSIN’ or
     ‘SYSIPT’) and will be saved in IDENTIFIER-1.

  4. If IDENTIFIER-1 is a numeric data item, the character value read
     from the console or standard-input device will be parsed according
     to the rules for input to the ‘NUMVAL’ intrinsic function (*note
     NUMVAL::), except that none of the trailing sign formats are
     honoured.


File: gnucobpg.info,  Node: ACCEPT FROM COMMAND-LINE,  Next: ACCEPT FROM ENVIRONMENT,  Prev: ACCEPT FROM CONSOLE,  Up: ACCEPT

7.8.1.2 ACCEPT FROM COMMAND-LINE
................................

                    ACCEPT FROM COMMAND-LINE Syntax
=======================================================================

   ACCEPT identifier-1
   ~~~~~~
          FROM { COMMAND-LINE                                }
          ~~~~ { ~~~~~~~~~~~~                                }
               { ARGUMENT-NUMBER                             }
               { ~~~~~~~~~~~~~~~                             }
               { ARGUMENT-VALUE                              }
               { ~~~~~~~~~~~~~~                              }
               [ ON EXCEPTION imperative-statement-1 ]
                    ~~~~~~~~~
               [ NOT ON EXCEPTION imperative-statement-2 ]
                 ~~~    ~~~~~~~~~
 [ END-ACCEPT ]
   ~~~~~~~~~~


=======================================================================
   This format of the ‘ACCEPT’ statement is used to retrieve information
from the program's command line.

  1. The reserved word ‘ON’ is optional and may be omitted.  The
     presence or absence of this word has no effect upon the program.

  2. When you accept from the ‘COMMAND-LINE’ option, you will retrieve
     the entire set of arguments entered on the command line that
     executed the program, exactly as they were specified.  Parsing that
     returned data into its meaningful information will be your
     responsibility.

  3. Using ‘COMMAND-LINE’ or ‘ARGUMENT-VALUE’ in a *nix based platform
     and that includes Linux, OSX, BSD and under windows running msys or
     MinGW etc, the shell process will expand any arguments that have a
     ‘*’ in the list -- such as ‘a*’, ‘abc*.*’, etc.  -- and create a
     list of all files that match the pattern.  To avoid this if not
     wanted, put all such argument within quotes, e.g., ‘progundertest
     "a*" b c d "ef*" "*hg"’ and the text within quotes will be passed
     verbatim to the program (as in the example ‘progundertest’).

  4. By accepting from ‘ARGUMENT-NUMBER’, you will be asking the
     GnuCOBOL run-time system to parse the arguments from the command
     line and return the number of arguments found.  Parsing will be
     conducted according to the following rules:
       A. Arguments will be separated by treating spaces and/or tab
          characters as the delimiters between arguments.  The number of
          such delimiters separating two non-blank argument values is
          irrelevant.

       B. Strings enclosed in double-quote characters (‘"’) will be
          treated as a single argument, regardless of how many spaces or
          tab characters (if any) might be embedded within the quotation
          characters.

       C. On Windows systems, single-quote, or apostrophe, characters
          (‘'’) will be treated just like any other data character and
          will not delineate argument strings.

  5. By accepting from ‘ARGUMENT-VALUE’, you will be asking the GnuCOBOL
     run-time system to parse the arguments from the command line and
     return the "current" argument.  You specify which argument number
     is "current" via the ‘ARGUMENT-NUMBER’ option on the ‘DISPLAY’
     statement (*note DISPLAY UPON COMMAND-LINE::).  Parsing of
     arguments will be conducted according to the rules set forth above.

  6. The optional ‘ON EXCEPTION’ and ‘NOT ON EXCEPTION’ clauses may be
     used to detect and react to the failure or success, respectively,
     of an attempt to retrieve an ‘ARGUMENT-VALUE’.  *Note ON EXCEPTION
     + NOT ON EXCEPTION::, for additional information.


File: gnucobpg.info,  Node: ACCEPT FROM ENVIRONMENT,  Next: ACCEPT data-item,  Prev: ACCEPT FROM COMMAND-LINE,  Up: ACCEPT

7.8.1.3 ACCEPT FROM ENVIRONMENT
...............................

                    ACCEPT FROM ENVIRONMENT Syntax
=======================================================================

   ACCEPT identifier-1
   ~~~~~~
          FROM { ENVIRONMENT-VALUE            }
          ~~~~ { ~~~~~~~~~~~~~~~~~            }
               { ENVIRONMENT { literal-1    } }
               { ~~~~~~~~~~~ { identifier-1 } }
        [ ON EXCEPTION imperative-statement-1 ]
             ~~~~~~~~~
        [ NOT ON EXCEPTION imperative-statement-2 ]
          ~~~    ~~~~~~~~~
 [ END-ACCEPT ]
   ~~~~~~~~~~


=======================================================================
   This format of the ‘ACCEPT’ statement is used to retrieve environment
variable values.

  1. The reserved word ‘ON’ is optional and may be omitted.  The
     presence or absence of this word has no effect upon the program.

  2. By accepting from ‘ENVIRONMENT-VALUE’, you will be asking the
     GnuCOBOL run-time system to retrieve the value of the environment
     variable whose name is currently in the ‘ENVIRONMENT-NAME’
     register.  A value may be placed into the ‘ENVIRONMENT-NAME’
     register using the ‘ENVIRONMENT-NAME’ option of the ‘DISPLAY’
     statement (*note DISPLAY UPON ENVIRONMENT-NAME::).

  3. A simpler approach to retrieving an environment variables value is
     to use the ‘ENVIRONMENT’ option, where you specify the environment
     variable whose value is to be retrieved right on the ‘ACCEPT’
     statement itself.

  4. With the option ACCEPT "var" FROM ENVIRONMENT runtime-config-option
     you can receive the value set in one of the
     runtime-configuration-options listed in chapter 10.2.3 Run Time
     Environment Variables.  As an example: ACCEPT identifier-1 FROM
     ENVIRONMENT 'COB_INSERT_MODE' returns whether insert mode is active
     ( = 'true' or 1 ) or inactive ( = 'false' or 0 ).

  5. The optional ‘ON EXCEPTION’ and ‘NOT ON EXCEPTION’ clauses may be
     used to detect and react to an attempt to retrieve the value of a
     non-existent environment variable or the successful retrieval of an
     environment variable's value, respectively.  *Note ON EXCEPTION +
     NOT ON EXCEPTION::, for additional information.


File: gnucobpg.info,  Node: ACCEPT data-item,  Next: ACCEPT FROM DATE/TIME,  Prev: ACCEPT FROM ENVIRONMENT,  Up: ACCEPT

7.8.1.4 ACCEPT data-item
........................

                        ACCEPT data-item Syntax
=======================================================================

   ACCEPT { identifier-1 }
   ~~~~~~ { OMITTED      }
          { ~~~~~~~      }

          [ { FROM EXCEPTION-STATUS } ]
             ~~~~ ~~~~~~~~~~~~~~~~
          [ FROM CRT ] [ MODE IS BLOCK ]
            ~~~~ ~~~     ~~~~    ~~~~~

          [ AT { LINE                          NUMBER { integer-1    } ]
          [ ~~ { ~~~~                                 { identifier-2 } ]
          [    { COLUMN | COL | POSITION | POS NUMBER { integer-2    } ]
          [    { ~~~~~~   ~~~   ~~~~~~~~   ~~~        { identifier-3 } ]
          [    { { integer-3    }                                    } ]
          [    { { identifier-4 }                                    } ]

          [ WITH [ AUTO | AUTO-SKIP | AUTOTERMINATE | TAB ]
            ~~~~   ~~~~   ~~~~~~~~~   ~~~~~~~~~~~~~   ~~~
                 [ [ NO ] { BELL } ]
                 [   ~~   { ~~~~ } ]
                 [        { BEEP } ]
                            ~~~~
                 [ PROMPT [ CHARACTER IS literal-2 | identifier-5 ]
                   ~~~~~~   ~~~~~~~~~
                 [ BACKGROUND-COLOR|BACKGROUND-COLOUR IS integer-4|identifier-6]
                   ~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~
                 [ FOREGROUND-COLOR|FOREGROUND-COLOUR IS integer-5|identifier-7]
                   ~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~
                 [ HIGHLIGHT | LOWLIGHT ]
                   ~~~~~~~~~   ~~~~~~~~
                 [ BLINK ]
                   ~~~~~
                 [ REVERSE-VIDEO | REVERSE | REVERSED ]
                   ~~~~~~~~~~~~~   ~~~~~~~   ~~~~~~~~
                 [ LEFTLINE ] [ OVERLINE ] [ UNDERLINE ]
                   ~~~~~~~~     ~~~~~~~~     ~~~~~~~~~

                 [ REQUIRED | EMPTY-CHECK ]
                   ~~~~~~~~   ~~~~~~~~~~~
                 [ FULL | LENGTH-CHECK ]
                   ~~~~   ~~~~~~~~~~~~
                 [ NO ECHO | NO-ECHO | OFF | SECURE ]
                   ~~~~~~~   ~~~~~~~   ~~~   ~~~~~~
                 [ LOWER | UPPER ]
                   ~~~~~   ~~~~~
                 [ SCROLL [ UP   ] [ { integer-6    } LINE|LINES ] ]
                 [ ~~~~~~ [ ~~   ] [ { identifier-8 } ~~~~ ~~~~~ ] ]
                 [        [ DOWN ]                                 ]
                            ~~~~
                 [ { TIMEOUT|TIME-OUT AFTER } { integer-7    } ]
                 [ { ~~~~~~~ ~~~~~~~~       } { identifier-9 } ]
                 [ { BEFORE TIME            }                  ]
                            ~~~~
                 [ CONVERSION ]
                   ~~~~~~~~~~
                 [ [ NO ] { UPDATE  } ]
                 [   ~~   { ~~~~~~  } ]
                 [        { DEFAULT } ]
                            ~~~~~~~
                 [ CURSOR { identifier-10 } ]
                   ~~~~~~
                 [ PROTECTED SIZE IS  { integer-8     } ]
                 [           ~~~~     { identifier-11 } ]

                 [ CONTROL        { literal-8     } ]
                 [ ~~~~~~~        { identifier-12 } ]

                 [ { COLOUR } IS  { integer-9     } ]
                 [ { COLOR  }     { identifier-13 } ]
                 [ { ~~~~~~ }                       ]

         [ ON EXCEPTION|ESCAPE     imperative-statement-1 ]
              ~~~~~~~~~ ~~~~~~
         [ NOT ON EXCEPTION|ESCAPE imperative-statement-2 ]
           ~~~    ~~~~~~~~~ ~~~~~~
 [ END-ACCEPT ]
   ~~~~~~~~~~

   The ‘FROM CRT’, ‘MODE IS BLOCK’ and ‘CONVERSION’ clauses are
syntactically recognized but are otherwise non-functional.

=======================================================================
   This format of the ‘ACCEPT’ statement is used to retrieve data from a
working storage item or a formatted console window screen.

  1. The reserved words ‘AFTER’, ‘IS’, ‘NUMBER’ and ‘ON’ are optional
     and may be omitted.  The presence or absence of these words has no
     effect upon the program.

  2. The reserved words ‘COLUMN’, ‘COL’ and ‘POSITION’ are
     interchangeable.

  3. The reserved words ‘TIMEOUT’ and ‘TIME-OUT’ are interchangeable.

  4. If IDENTIFIER-1 is defined in the ‘SCREEN SECTION’ (*note SCREEN
     SECTION::), any ‘AT’, ATTRIBUTE-SPECIFICATION, ‘LOWER’, ‘UPPER’ or
     ‘SCROLL’ clauses will be ignored.  In these cases, an implied
     ‘DISPLAY’ (*note DISPLAY data-item::) of IDENTIFIER-1 will occur
     before input is accepted.  Coding an explicit ‘DISPLAY
     identifier-1’ before an ‘ACCEPT identifier-1’ is redundant and will
     incur the performance penalty of painting the screen contents
     twice.

  5. The various ‘AT’ clauses provide a means of positioning the cursor
     to a specific spot on the screen before the screen is read.  One or
     the other (but not both) may be used, as follows:
       A. The ‘LINE’ and ‘COLUMN’ clauses provide one mechanism for
          specifying the line and column position to which the cursor
          will be positioned before allowing the user to enter data.  In
          the absence of one or the other, a value of 1 will be assumed
          for the one that is missing.  The author's personal
          preference, however, is to explicitly code both.

       B. The LITERAL-3 or IDENTIFIER-4 value, if specified, must be a
          four- or six-digit value with the 1^{st} half of the number
          indicating the line where the cursor should be positioned and
          the second half indicating the column.  You may code only one
          of each clause on any ‘ACCEPT’.

  6. ‘WITH’ options (including the various individual
     ATTRIBUTE-SPECIFICATIONS) should be coded only once.

  7. The following ATTRIBUTE-SPECIFICATION clauses are allowed on the
     ‘ACCEPT’ statement; these are the same as those allowed for ‘SCREEN
     SECTION’ data items.  A particular ATTRIBUTE-SPECIFICATION may be
     used only once in any ‘ACCEPT’:
        • ‘AUTO’ (*note AUTO::), ‘AUTO-SKIP’ (*note AUTO-SKIP::),
          ‘AUTOTERMINATE’ (*note AUTOTERMINATE::), ‘TAB’

        • ‘BACKGROUND-COLOR’ (*note BACKGROUND-COLOR::)

        • ‘BEEP’ (*note BEEP::), ‘BELL’ (*note BELL::)

        • ‘BEFORE TIME’ (*note BEFORE TIME::)

        • ‘BLINK’ (*note BLINK::)

        • ‘FOREGROUND-COLOR’ (*note FOREGROUND-COLOR::)

        • ‘FULL’ (*note FULL::), ‘LENGTH-CHECK’ (*note LENGTH-CHECK::)

        • ‘HIGHLIGHT’ (*note HIGHLIGHT::)

        • ‘LEFTLINE’ (*note LEFTLINE::)

        • ‘LOWER’ (*note LOWER::)

        • ‘LOWLIGHT’ (*note LOWLIGHT::)

        • ‘NO UPDATE’ (*note NO UPDATE::)

        • ‘OVERLINE’ (*note OVERLINE::)

        • ‘PROMPT’ (*note PROMPT::)

        • ‘PROTECTED’ (*note PROTECTED::)

        • ‘REQUIRED’ (*note REQUIRED::), ‘EMPTY-CHECK’ (*note
          EMPTY-CHECK::)

        • ‘REVERSE-VIDEO’ (*note REVERSE-VIDEO::)

        • ‘SCROLL DOWN’ (*note SCROLL DOWN::)

        • ‘SCROLL UP’ (*note SCROLL UP::)

        • ‘SIZE’ (*note SIZE::)

        • ‘SECURE’ (*note SECURE::), ‘NO-ECHO’ (*note NO-ECHO::)

        • ‘TIME OUT’ (*note TIME OUT::)

        • ‘UPDATE’ (*note UPDATE::)

        • ‘UPPER’ (*note UPPER::)

        • ‘UNDERLINE’ (*note UNDERLINE::)

  8. The ‘CURSOR’ offset into the field at ACCEPT termination is
     returned to the program in identifier-10.  Identifier-10, can also
     be used to indicate, as an offset, where you want the cursor to be
     positioned when the ACCEPT is executed.

  9. The ‘SCROLL’ option will cause the entire contents of the screen to
     be scrolled ‘UP’ or ‘DOWN’ by the specified number of lines before
     any value is displayed on the screen.  It is syntactically
     allowable to specify a ‘SCROLL UP’ clause as well as a ‘SCROLL
     DOWN’ clause.  In such an instance, it is the last one specified
     that will be honoured.  If no ‘LINES’ specification is made, ‘1
     LINE’ will be assumed.

  10. The ‘TIMEOUT’ option will cause the ‘ACCEPT’ to wait no more than
     the specified number of seconds for input.  The wait count may be
     specified as a positive integer or a numeric data item with a
     positive value.

  11. The ‘UPDATE’ option will enable the supplied data field to be
     updated having been displayed on screen prior to data being entered
     by overwriting, if needed.  When this option is not used the input
     field is cleared prior to input and this is the default but can be
     changed by the use of compiler steering command
     -faccept-with-update that can be input when starting the compiler
     or included in the configuration file e.g., default.conf used when
     selected by default ‘-std=default’.  For more information see *note
     cobc - The GnuCOBOL Compiler:: option switches) and *note Compiler
     Configuration Files::.

  12. This format of the ‘ACCEPT’ statement will be terminated by any of
     the following events:
       A. When the <Enter> key is pressed.

       B. Expiration of the ‘TIMEOUT’ timer -- this will be treated as
          if the <Enter> key had been pressed with no data being
          entered.

       C. When a function key (<FN>) is pressed.

       D. The pressing of the <PgUp> or <PgDn> keys, if the
          ‘COB_SCREEN_EXCEPTIONS’ run-time environment variable (*note
          Run Time Environment Variables::) is set to any non-blank
          value.

       E. The pressing of the <Esc> key if both the ‘COB_SCREEN_ESC’
          run-time environment variable as well as
          ‘COB_SCREEN_EXCEPTIONS’ run-time environment variable are set
          to any non-blank value.

       F. The pressing of the <Up-arrow>, <Down-Arrow> or <PrtSc> (Print
          Screen) keys.  These keys are not detectable on Windows
          systems, however.

  13. The following apply when IDENTIFIER-1 is defined in the ‘SCREEN
     SECTION’:
       A. Alphanumeric data entered into IDENTIFIER-1 or any screen data
          item subordinate to it must be consistent with the ‘PICTURE’
          (*note PICTURE::) clause of that item.  This will be enforced
          at runtime by the ‘ACCEPT’ statement.

       B. If IDENTIFIER-1 or any screen data item subordinate to it are
          defined as numeric, entered data must be acceptable as
          ‘NUMVAL’ intrinsic function (*note NUMVAL::) input (no decimal
          points are allowed, however).  The value stored into the
          screen data item will be as if the input were passed to that
          function.

       C. If IDENTIFIER-1 or any screen data item subordinate to it are
          defined as numeric edited, entered data must be acceptable as
          ‘NUMVAL-C’ intrinsic function (*note NUMVAL-C::) input (again,
          no decimal points are allowed).  The value stored into the
          screen data item will be as if the input were passed to that
          function.

  14. The following apply when IDENTIFIER-1 is not defined in the
     ‘SCREEN SECTION’:
       A. Alphanumeric data entered into IDENTIFIER-1 should be
          consistent with the ‘PICTURE’ (*note PICTURE::) clause of that
          item, although that will not be enforced by the ‘ACCEPT’
          statement.  You may use ‘Class Conditions’ (*note Class
          Conditions::) after the data is accepted to enforce the data
          type.

       B. If IDENTIFIER-1 is defined as numeric, entered data must be
          acceptable as ‘NUMVAL’ intrinsic function (*note NUMVAL::)
          input (no decimal points are allowed, however).  The value
          stored into IDENTIFIER-1 will be as if the input were passed
          to that function.

       C. If IDENTIFIER-1 is defined as numeric edited, entered data
          must be acceptable as ‘NUMVAL-C’ intrinsic function (*note
          NUMVAL-C::) input (again, no decimal points are allowed).  The
          value stored into IDENTIFIER-1 will be as if the input were
          passed to that function.

  15. The optional ‘ON EXCEPTION’ and ‘NOT ON EXCEPTION’ clauses may be
     used to detect and react to the failure or success, respectively,
     of the screen I/O attempt.  *Note ON EXCEPTION + NOT ON
     EXCEPTION::, for additional information.  The ESCAPE sub clause is
     allowed instead of EXCEPTION as a synonymous, with the same
     meaning.

     After this format of the ‘ACCEPT’ statement is executed, the
     program's ‘CRT STATUS’ (*note SPECIAL-NAMES::) identifier will be
     populated with one of the following:

     Code        Meaning
     --------------------------------------------------------------------------
     0000        <ENTER> key pressed
     1001-1064   <F1>-<F64>, respectively, were pressed
     2001        <PgUp> was pressed
     2002        <PgDn> was pressed
     2003        <Up-Arrow> was pressed
     2004        <Down-Arrow> was pressed
     2005        <Esc> was pressed
     2006        <PrtSc> (Print Screen) was pressed
     2007        <Tab>
     2008        <Back Tab>
     2009        <Key Left>
     2010        <Key Right>
     2011        <Insert> Key on accept omitted
     2012        <Delete> Key on accept omitted
     2013        <Backspace> Key on accept omitted
     2014        <Home> Key on accept omitted
     2015        <End> Key on accept omitted
     2040-       2095 Exception keys for Mouse Handling
     2040        Mouse Move
     2041        Left Pressed
     2042        Left Released
     2043        Left Dbl Click
     2044        Mid Pressed
     2045        Mid Released
     2046        Mid Dbl Click
     2047        Right Pressed
     2048        Right Released
     2049        Right Dbl Click
     2050        Shift Move
     2051        Shift Left Pressed
     2052        Shift Left Released
     2053        Shift Left Dbl Click
     2054        Shift Mid Pressed
     2055        Shift Mid Released
     2056-       Shift Mid Dbl Click
     2057        Shift Right Pressed
     2058        Shift Right Released
     2059        Shift Right Dbl Click
     2060        Ctrl Move
     2061        Ctrl Left Pressed
     2062        Ctrl Left Released
     2063        Ctrl Left Dbl Click
     2064        Ctrl Mid Pressed
     2065        Ctrl Mid Released
     2066        Ctrl Mid Dbl Click
     2067        Ctrl Right Pressed
     2068        Ctrl Right Released
     2069        Ctrl Right Dbl Click
     2070        Alt Move
     2071        Alt Left Pressed
     2072        Alt Left Released
     2073-       Alt Left Dbl Click
     2074        Alt Mid Pressed
     2075        Alt Mid Released
     2076        Alt Mid Dbl Click
     2077        Alt Right Pressed
     2078        Alt Right Released
     2079        Alt Right Dbl Click
     2080        Wheel Up
     2081        Wheel Down
     2082        Wheel Left
     2083        Wheel Right
     2084        Shift Wheel Up
     2085        Shift Wheel Down
     2086        Shift Wheel Left
     2087        Shift Wheel Right
     2088        Ctrl Wheel Up
     2089        Ctrl Wheel Down
     2090        Ctrl Wheel Left
     2091        Ctrl Wheel Right
     2092        Alt Wheel Up
     2093        Alt Wheel Down
     2094        Alt Wheel Left
     2095        Alt Wheel Right
                 Input validation
     8000        NO Field
     8001        Time Out
                 Other errors
     9000        Fatal
     9001        Max Field

  16. The actual key pressed to generate a function key (<FN>) will
     depend on the type of terminal device you're using (PC, Macintosh,
     VT100, etc.)  and what type of enhanced display driver was
     configured with the version of GnuCOBOL you're using.

     For example, on a GnuCOBOL build for a Windows PC using MinGW and
     "PDCurses", <F1>-<F12> are the actual F-keys on the PC keyboard,
     <F13>-<F24> are entered by shifting the F-keys, <F25>-<F36> are
     entered by holding Ctrl while pressing an F-key and <F37>-<F48> are
     entered by holding Alt while pressing an F-key.  On the other hand,
     a GnuCOBOL implementation built for Windows using Cygwin and
     NCurses treats the PCs <F1>-<F12> keys as the actual <F1>-<F12>,
     while shifted F-keys will enter <F11>-<F2>0.  With Cygwin/NCurses,
     Ctrl- and Alt-modified F-keys aren't recognized, nor are
     <Shift-F11> or <Shift-F12>.

     Mouse Key codes are populated only if mouse management has been
     enabled.  To enable mouse it is first necessary to set
     ‘COB_MOUSE_FLAGS’ (either externally via terminal command, or
     internally via ‘SET ENVIRONMENT’ to the applicable ?mouse mask?
     (specifying which activities you wish the program to detect).  Here
     is an example of setting the mask from a COBOL program:

          COPY screenio.cpy.

          01  mouse-flags PIC 9(4).

          ...

              COMPUTE mouse-flags = COB-AUTO-MOUSE-HANDLING
                                  + COB-ALLOW-LEFT-DOWN
                                  + COB-ALLOW-MIDDLE-DOWN
                                  + COB-ALLOW-RIGHT-DOWN

              SET ENVIRONMENT "COB_MOUSE_FLAGS" TO MOUSE-FLAGS.

  17. Once that has been done, every (extended) ACCEPT, will return a
     value in COB_CRT_STATUS reflecting mouse activity, when such
     activity occurs.  The applicable values are shown in screenio.cpy
     under ?Exception keys for mouse handling?.  If you define a
     variable in SPECIAL NAMES as follows:
     SPECIAL-NAMES.
        CURSOR IS data-name.   *> where data-name is PIC 9(4) or 9(6).

  18. The cursor or mouse position will be returned as well.  The
     position is expressed as row and column (rrcc or rrrccc).

  19. Numeric keypad keys are not recognizable on Windows MinGW/PDCurses
     builds of GnuCOBOL, regardless of the number lock settings.
     Windows Cygwin/NCurses builds recognize numeric keypad inputs
     properly.  Although not tested during the preparation of this
     documentation, I would expect native Windows builds using PDCurses
     to behave as MinGW builds do and native Unix builds using NCurses
     to behave as do Cygwin builds.

  20. The optional ‘EXCEPTION-STATUS’ clause may be used to detect
     exceptions from a prior arithmetic verb such as COMPUTE to recover
     any errors produced.  These are recovered using the function
     ‘EXCEPTION-STATUS’.

  21. The use of ‘CONTROL’ The value of literal-8 and identifier-8 in
     the CONTROL phrase is used to specify a dynamic option list.  The
     value must be a character-string consisting of a series of keywords
     delimited by commas; Some keywords allow assignment of a value by
     following the keyword with an equal sign and the value.  Blanks are
     ignored in the character-string.  Lowercase letters are treated as
     uppercase letters within keywords.  Keywords specified override
     corresponding static options specified as phrases for the same
     identifier-1.  Keywords may be specified in any order.  Keywords,
     which specify options that do not apply to the statement, are
     ignored.

     The keywords that affect an ACCEPT statement are BEEP, BLINK, ECHO,
     PROMPT, REVERSE, TAB, UNDERLINE, UPDATE, ERASE, ERASE EOL, ERASE
     EOS, HIGH, LOW, UPPER, NO BEEP, NO BLINK, NO ECHO, NO PROMPT, NO
     REVERSE, NO TAB, NO UNDERLINE, NO UPDATE, NO ERASE.

     The meanings of these keywords when they appear in the value of the
     CONTROL phrase operand are the same as the corresponding phrases
     which may be written as static options of the ACCEPT statement,
     with the addition of the negative forms to allow suppression of
     statically declared options.

     The keywords UNDERLINE and UPPER are not available as static
     options of the ACCEPT statement.  When specified, UPPER causes all
     lowercase alphabetic characters contained in the screen field to be
     changed to uppercase alphabetic characters before input data
     conversion and storing in the receiving field.

     When specified, UNDERLINE causes the field on the screen to be
     shown in underlined mode, provided the terminal supports that mode.

     GnuCOBOL provides two additional keywords in the CONTROL phrase
     that affect an ACCEPT field.

     1.  FCOLOR = color-name

     When FCOLOR is present, color-name specifies the foreground color
     of the ACCEPT field.  This name is then used as the default value
     for subsequent ACCEPT statements in the program.  The initial
     default for color-name is white.

     2.  BCOLOR = color-name

     When BCOLOR is present, color-name specifies the background color
     of the DISPLAY field.  This value is then used as the default value
     for subsequent ACCEPT statements in the program.  The initial
     default for color-name is black.

     Following table contains a list of all the possible names for
     color-name.  The left column contains the valid color name.  The
     right column shows the color that appears when high intensity is
     specified (the default intensity).
     
     	+--------------------------------------------------------------+
     	|                 Valid COBOL Color Names                      |
     	+-------------------+------------------------------------------+
     	|Valid Color Names  |  High-Intensity Color Values (Defaults)  |
     	+-------------------+------------------------------------------+
     	|Black              |  Gray                                    |
     	|Blue               |  Light Blue                              |
     	|Green              |  Light Green                             |
     	|Cyan               |  Light Cyan                              |
     	|Red                |  Light Red                               |
     	|Magenta            |  Light Magenta                           |
     	|Brown              |  Yellow                                  |
     	|White              |  High-Intensity White                    |
     	+-------------------+------------------------------------------+
     
  22. COLOR Phrase

     The COLOR phrase provides an alternate method for setting video
     attributes.  Integer-9 must be a numeric literal.  Identifier-9
     must be a numeric data item.  It also allows the specification of
     colors for screen fields and controls.  They can be set to
     different numeric values to express various combinations of colors
     and video attributes.

     You may make combinations by adding the appropriate values
     together.  The following color values are accepted:

     
     	+--------+--------------+-------------+
     	|Color   |  Foreground  | Background  |
     	+--------+--------------+-------------+
     	|Black   |      1       |     32      |
     	|Blue    |      2       |     64      |
     	|Green   |      3       |     96      |
     	|Cyan    |      4       |    128      |
     	|Red     |      5       |    160      |
     	|Magenta |      6       |    192      |
     	|Brown   |      7       |    224      |
     	|White   |      8       |    256      |
     	+--------+--------------+-------------+
     
  23. You may specify other video attributes by adding the following
     values:
     
     	+-------------------------+--------+
     	|Reverse video            |   1024 |
     	|Low intensity            |   2048 |
     	|High intensity           |   4096 |
     	|Underline                |   8192 |
     	|Blink                    |  16384 |
     	|Protected                |  32768 |
     	|Background low-intensity |  65536 |
     	|Background high-intensity| 131072 |
     	+-------------------------+--------+
     
  24. You may also specify high intensity by adding "8" to the
     foreground color value.



File: gnucobpg.info,  Node: ACCEPT FROM DATE/TIME,  Next: ACCEPT FROM Screen-Info,  Prev: ACCEPT data-item,  Up: ACCEPT

7.8.1.5 ACCEPT FROM DATE/TIME
.............................

                     ACCEPT FROM DATE/TIME Syntax
=======================================================================

   ACCEPT identifier-1 FROM { DATE [ YYYYMMDD ] }
   ~~~~~~              ~~~~ { ~~~~   ~~~~~~~~   }
                            { DAY [ YYYYDDD ]   }
                            { ~~~   ~~~~~~~     }
                            { DAY-OF-WEEK       }
                            { ~~~~~~~~~~~       }
                            { TIME              }
                            { ~~~~              }
                            { MICROSECOND-TIME  }
                            { ~~~~~~~~~~~~~~~~  }
 [ END-ACCEPT ]
   ~~~~~~~~~~


=======================================================================
   This format of the ‘ACCEPT’ statement is used to retrieve the current
system date, time or current day of the week and store it into a data
item.

  1. The data retrieved from the system and the format in which it is
     structured will vary, as follows:
     Syntax                 Data Retrieved                       Format
     ---------------------------------------------------------------------------
     ‘DATE’                 Current date in Gregorian form       yymmdd
     ‘DATE YYYYMMDD’        Current date in Gregorian form       yyyymmdd
     ‘DAY’                  Current date in Julian form          yyddd
     ‘DAY YYYYDDD’          Current date in Julian form          yyyyddd
     ‘DAY-OF-WEEK’          Current day within a week where 1    d
                            = Monday.., 7 = Sunday
     ‘TIME’                 Time, including hundredths of a      hhmmssnn
                            second (n)
     ‘MICROSECOND-TIME’     Time, including micro seconds (u)    hhmmssuuuuuu
                                                                 

  2. When using one of ‘--std=acu’ or ‘--std=acu-strict’, ACCEPT FROM
     TIME data-item with data-item providing more than 12 digits behaves
     as if ACCEPT FROM MICROSECOND-TIME data-item is used (six decimal
     places for fractional seconds).

  3. Consider using the standard ‘FUNCTION FORMATTED-CURRENT-DATE’ if
     you need a high precision (up to eight decimal places for
     fractional seconds).



File: gnucobpg.info,  Node: ACCEPT FROM Screen-Info,  Next: ACCEPT FROM Runtime-Info,  Prev: ACCEPT FROM DATE/TIME,  Up: ACCEPT

7.8.1.6 ACCEPT FROM Screen-Info
...............................

                    ACCEPT FROM Screen-Info Syntax
=======================================================================

   ACCEPT identifier-1
   ~~~~~~
          FROM { LINES|LINE-NUMBER }
          ~~~~ { ~~~~~ ~~~~~~~~~~~ }
               { COLS|COLUMNS      }
               { ~~~~ ~~~~~~~      }
               { ESCAPE KEY        }
                 ~~~~~~ ~~~
 [ END-ACCEPT ]
   ~~~~~~~~~~


=======================================================================
   This format of the ‘ACCEPT’ statement is used to retrieve information
about the console window or about the user's interactions with it.

  1. The reserved words ‘LINES’ and ‘LINE-NUMBER’ are interchangeable.

  2. The reserved words ‘COLS’ and ‘COLUMNS’ are interchangeable.

  3. The following points pertain to the use of the ‘LINES’ and
     ‘COLUMNS’ options:
       A. The ‘LINES’ and ‘COLUMNS’ options will retrieve the respective
          components of the size of the console display.

       B. When the console is running in a windowed environment, this
          will be the sizing of the window in which the program is
          executing, in terms of horizontal (‘COLUMNS’) or vertical
          (‘LINES’) character counts -- not pixels.

       C. When the system is not running a windowing environment, the
          physical console screen attributes will be returned.

       D. Values of 0 will be returned if GnuCOBOL was not generated to
          include screen I/O.

       E. See the documentation on the ‘CBL_GET_SCR_SIZE’ built-in
          system subroutine (*note CBL_GET_SCR_SIZE::) for another way
          to retrieve this information.

  4. The ‘ESCAPE KEY’ option may be used after an ACCEPT data-item has
     been used to retrieve data off a formatted screen.  The result
     returned, will be the four-digit key id of the special key that was
     pressed to terminate the ACCEPT data-item (a 0000 is returned for
     the Enter key).

     If you specify the CRT STATUS is Identifier-1 clause in SPECIAL
     NAMES, then for an ACCEPT data-item, the system sets a code in the
     identifier-1 field that indicates which key ended the ACCEPT
     data-item.

     If the CRT STATUS clause IS identifier-1 is not specified in
     SPECIAL NAMES. then within the program, you can write two
     consecutive ACCEPTs:

          ACCEPT data-item
          ACCEPT identifier-1 FROM ESCAPE KEY

     In this way in the identifier-1 field you will have the return code
     which indicates which key completed the ACCEPT data-item.



File: gnucobpg.info,  Node: ACCEPT FROM Runtime-Info,  Next: ACCEPT OMITTED,  Prev: ACCEPT FROM Screen-Info,  Up: ACCEPT

7.8.1.7 ACCEPT FROM Runtime-Info
................................

                    ACCEPT FROM Runtime-Info Syntax
=======================================================================

   ACCEPT identifier-1
   ~~~~~~
          FROM { EXCEPTION STATUS }
          ~~~~ { ~~~~~~~~~ ~~~~~~ }
               { USER NAME        }
                 ~~~~ ~~~~
 [ END-ACCEPT ]
   ~~~~~~~~~~


=======================================================================
   This format of the ‘ACCEPT’ statement is used to retrieve run-time
information such as the most-recent error exception code and the current
user's user name.
  1. The following points pertain to the use of the ‘EXCEPTION STATUS’
     option:
       A. IDENTIFIER-1 must be defined as a ‘PIC X(4)’ item.

       B. *Note Error Exception Codes::, for a complete list of the
          exception codes and their meanings.

       C. An alternative to the use of ‘ACCEPT FROM Runtime-Info’ is to
          use the ‘EXCEPTION-STATUS’ intrinsic function (*note
          EXCEPTION-STATUS::).

  2. The following points pertain to the use of the ‘USER NAME’ option:
       A. The returned result is the userid that was used to login to
          the system with, and not any actual first and/or last name of
          the user in question (unless, of course, that is the
          information used as a logon id).  It is not the PID or UID
          numbers but the name associated with the UID under *nix based
          systems.

       B. IDENTIFIER-1 should be defined large enough to receive the
          longest user-name on the system.

       C. If insufficient space is allocated, the returned value will be
          truncated.

       D. If excess space is allocated, the returned value will be
          padded with spaces (to the right).


File: gnucobpg.info,  Node: ACCEPT OMITTED,  Next: ACCEPT FROM EXCEPTION STATUS,  Prev: ACCEPT FROM Runtime-Info,  Up: ACCEPT

7.8.1.8 ACCEPT OMITTED
......................

                         ACCEPT OMITTED Syntax
=======================================================================

   ACCEPT OMITTED
   ~~~~~~

   1.  For console : See 6.17.1.1 (ACCEPT FROM CONSOLE Syntax)

   2.  For Screen  : See 6.17.1.4 (ACCEPT screen-data-item Syntax)

 [ END-ACCEPT ]
   ~~~~~~~~~~


=======================================================================
   This format of the ‘ACCEPT’ statement will wait for a keyboard event
that terminates input; function keys, or Enter/Return, among others.
CRT STATUS (COB-CRT-STATUS ‘CRT STATUS’ (*note SPECIAL-NAMES::) if not
explicitly defined) is set with the keycode, listed in
copy/screenio.cpy.  It also handles a few other keycode terminations not
normally used to complete an extended accept.

  1. The following are examples of keycodes that can be used:
     COB-SCR-INSERT
     COB-SCR-DELETE
     COB-SCR-BACKSPACE
     COB-SCR-KEY-HOME
     COB-SCR-KEY-END

  2. You can use extended attributes, useful for setting timeouts or
     positioning.


File: gnucobpg.info,  Node: ACCEPT FROM EXCEPTION STATUS,  Prev: ACCEPT OMITTED,  Up: ACCEPT

7.8.1.9 ACCEPT FROM EXCEPTION STATUS
....................................

                  ACCEPT FROM EXCEPTION STATUS Syntax
=======================================================================

   ACCEPT exception-status-pic-9-4   FROM EXCEPTION STATUS
   ~~~~~~                            ~~~~ ~~~~~~~~~ ~~~~~~

 [ END-ACCEPT ]
   ~~~~~~~~~~


=======================================================================
   This format of the ‘ACCEPT’ statement will receive the status for any
exceptions resulting from a previous valid verb.

  1. The following is an example of usage:
      In WS:
      01  exception-status  pic 9(4).
     ..
      In PD:
     
      ACCEPT unexpected-rounding  FROM EXCEPTION STATUS
      IF unexpected-rounding NOT EQUAL "0000" THEN
         DISPLAY "Unexpected rounding. Code " unexpected-rounding
                  UPON SYSERR
      END-IF


File: gnucobpg.info,  Node: ADD,  Next: ALLOCATE,  Prev: ACCEPT,  Up: GnuCOBOL Statements

7.8.2 ADD
---------

* Menu:

* ADD TO
* ADD GIVING
* ADD CORRESPONDING


File: gnucobpg.info,  Node: ADD TO,  Next: ADD GIVING,  Up: ADD

7.8.2.1 ADD TO
..............

                             ADD TO Syntax
=======================================================================

   ADD { literal-1    }...
   ~~~ { identifier-1 }

       TO { identifier-2
       ~~
          [ ROUNDED [ MODE IS { AWAY-FROM-ZERO         } ] ] }...
            ~~~~~~~   ~~~~    { ~~~~~~~~~~~~~~         }
                              { NEAREST-AWAY-FROM-ZERO }
                              { ~~~~~~~~~~~~~~~~~~~~~~ }
                              { NEAREST-EVEN           }
                              { ~~~~~~~~~~~~           }
                              { NEAREST-TOWARD-ZERO    }
                              { ~~~~~~~~~~~~~~~~~~~    }
                              { PROHIBITED             }
                              { ~~~~~~~~~~             }
                              { TOWARD-GREATER         }
                              { ~~~~~~~~~~~~~~         }
                              { TOWARD-LESSER          }
                              { ~~~~~~~~~~~~~          }
                              { TRUNCATION             }
                                ~~~~~~~~~~
     [ ON SIZE ERROR imperative-statement-1 ]
          ~~~~ ~~~~~
     [ NOT ON SIZE ERROR imperative-statement-2 ]
       ~~~    ~~~~ ~~~~~
 [ END-ADD ]
   ~~~~~~~


=======================================================================
   This format of the ‘ADD’ statement generates an intermediate
arithmetic sum of the values of all IDENTIFIER-1 and LITERAL-1) items.
The value of each IDENTIFIER-2 will be replaced, in turn, by the sum of
that IDENTIFIER-2s value and the intermediate sum.

  1. The reserved words ‘IS’ and ‘ON’ are optional and may be omitted.
     The presence or absence of these words has no effect upon the
     program.

  2. Both IDENTIFIER-1 and IDENTIFIER-2 must be numeric unedited data
     items while LITERAL-1 must be a numeric literal.

  3. An IDENTIFIER-1 data item may also be coded as an IDENTIFIER-2.
     Note, however, that the value of such a data item will therefore be
     included twice in the result.

  4. The contents of each IDENTIFIER-1 will remain unchanged by this
     statement.

  5. The optional ‘ROUNDED’ (*note ROUNDED::) clause available to each
     IDENTIFIER-2 will control how non-integer results will be saved.

  6. The optional ‘ON SIZE ERROR’ and ‘NOT ON SIZE ERROR’ clauses may be
     used to detect and react to the failure or success, respectively,
     of an attempt to perform a calculation.  In this case, failure is
     defined as being an IDENTIFIER-2 with an insufficient number of
     digit positions available to the left of any implied decimal point.
     *Note ON SIZE ERROR + NOT ON SIZE ERROR::, for additional
     information.


File: gnucobpg.info,  Node: ADD GIVING,  Next: ADD CORRESPONDING,  Prev: ADD TO,  Up: ADD

7.8.2.2 ADD GIVING
..................

                           ADD GIVING Syntax
=======================================================================

   ADD { literal-1    }...
   ~~~ { identifier-1 }

     [ TO identifier-2 ]
       ~~
       GIVING { identifier-3
       ~~~~~~
         [ ROUNDED [ MODE IS { AWAY-FROM-ZERO         } ] ] }...
           ~~~~~~~   ~~~~    { ~~~~~~~~~~~~~~         }
                             { NEAREST-AWAY-FROM-ZERO }
                             { ~~~~~~~~~~~~~~~~~~~~~~ }
                             { NEAREST-EVEN           }
                             { ~~~~~~~~~~~~           }
                             { NEAREST-TOWARD-ZERO    }
                             { ~~~~~~~~~~~~~~~~~~~    }
                             { PROHIBITED             }
                             { ~~~~~~~~~~             }
                             { TOWARD-GREATER         }
                             { ~~~~~~~~~~~~~~         }
                             { TOWARD-LESSER          }
                             { ~~~~~~~~~~~~~          }
                             { TRUNCATION             }
                               ~~~~~~~~~~
     [ ON SIZE ERROR imperative-statement-1 ]
          ~~~~ ~~~~~
     [ NOT ON SIZE ERROR imperative-statement-2 ]
       ~~~    ~~~~ ~~~~~
 [ END-ADD ]
   ~~~~~~~


=======================================================================
   This format of the ‘ADD’ statement generates the arithmetic sum of
the values of all IDENTIFIER-1, LITERAL-1) and IDENTIFIER-2 (if any)
items and then saves that sum to each IDENTIFIER-3.

  1. The reserved words ‘IS’ and ‘ON’ are optional and may be omitted.
     The presence or absence of these words has no effect upon the
     program.

  2. Both IDENTIFIER-1 and IDENTIFIER-2 must be numeric unedited data
     items while LITERAL-1 must be a numeric literal; IDENTIFIER-3 may
     be either a numeric or numeric edited data item.

  3. An IDENTIFIER-1 or IDENTIFIER-2 data item may be used as an
     IDENTIFIER-3, if desired.

  4. The contents of each IDENTIFIER-1 and IDENTIFIER-2 will remain
     unchanged by this statement, unless they happen to also be
     specified as an IDENTIFIER-3.

  5. The current value in each IDENTIFIER-3 at the start of the
     statement's execution is irrelevant, since the contents of each
     IDENTIFIER-3 will simply be replaced with the computed sum.

  6. The optional ‘ROUNDED’ (*note ROUNDED::) clause available to each
     IDENTIFIER-3 will control how non-integer results will be saved.

  7. The optional ‘ON SIZE ERROR’ and ‘NOT ON SIZE ERROR’ clauses may be
     used to detect and react to the failure or success, respectively,
     of an attempt to perform a calculation.  In this case, failure is
     defined as being an IDENTIFIER-3 with an insufficient number of
     digit positions available to the left of any implied decimal point.
     *Note ON SIZE ERROR + NOT ON SIZE ERROR::, for additional
     information.

