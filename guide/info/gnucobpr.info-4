This is gnucobpr.info, produced by makeinfo version 7.2 from
gnucobpr.texi.

This manual documents GnuCOBOL 3.2 - Final, 1 January 2025 at 00:01 GMT.
build.


   Document Copyright 2009-2014 Gary L. Cutler & FSF (Free Software
Foundation).
Updates: Copyright 2014-2025 Vincent B. Coen, Gary L. Cutler & FSF.

     The authors and copyright holders of the COBOL programming language
     itself used herein:

     FLOW-MATIC (trademark for Sperry Rand Corporation) Programming for
     the Univac(R) I & II. Data Automation Systems copyrighted 1958,
     1959, by Sperry Rand Corporation; IBM commercial translator form
     F28-8013, copyrighted 1959 by IBM; FACT DSI27A5260-2760,
     copyrighted 1960 by Minneapolis-Honeywell, have specifically
     authorised the use of this material in whole or in part of the
     COBOL specifications.  Such authorisation extends to the
     reproduction & use of COBOL specifications in programming manuals
     or similar publications.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License
     [FDL], Version 1.3 or any later version published by the Free
     Software Foundation; with Invariant Section "Introduction", no
     Front-Cover Texts, and no Back-Cover Texts.  A copy of the license
     is included in the section entitled "GNU Free Documentation
     License".

     Permission is granted to make and distribute verbatim copies of
     this manual provided the copyright notice and this permission
     notice are preserved on all copies.

     Permission is granted to copy and distribute modified versions of
     this manual under the conditions for verbatim copying, provided
     that the entire resulting derived work is distributed under the
     terms of a permission notice identical to this one.

     Permission is granted to copy and distribute translations of this
     manual into another language, under the above conditions for
     modified versions, except that this permission notice may be stated
     in a translation approved by the Free Software Foundation.

INFO-DIR-SECTION GNU-COBOL
START-INFO-DIR-ENTRY
* GNU-COBOL: (gnucobpr)        GnuCOBOL Programmer's Reference
END-INFO-DIR-ENTRY


File: gnucobpr.info,  Node: XML PARSE,  Prev: XML GENERATE,  Up: GnuCOBOL Statements

7.8.56 XML PARSE
----------------

                           XML PARSE Syntax
=======================================================================

XML PARSE identiﬁer-1
~~~ ~~~~~
    WITH ENCODING identiﬁer-2
         ~~~~~~~~
                  literal-1

    RETURNING NATIONAL
    ~~~~~~~~~ ~~~~~~~~
  VALIDATING WITH identiﬁer-3
  ~~~~~~~~~~
  PROCESSING PROCEDURE IS procedure-name-1  { THROUGH }
  ~~~~~~~~~~ ~~~~~~~~~                      { THRU    } procedure-name-2
  ON EXCEPTION imperative-statement-1
     ~~~~~~~~~
  NOT ON EXCEPTION imperative-statement-2
  ~~~    ~~~~~~~~~
  END-XML
  ~~~~~~~


=======================================================================
   The ‘XML PARSE’ statement starts an event-driven XML parser, the
processing procedure is performed as each component of the XML document
is identiﬁed in order.



File: gnucobpr.info,  Node: Functions,  Next: Report Writer Usage,  Prev: PROCEDURE DIVISION,  Up: Top

8 Functions
***********

* Menu:

* Intrinsic Functions.
* Built-In System Subroutines.


File: gnucobpr.info,  Node: Intrinsic Functions,  Next: Built-In System Subroutines,  Up: Functions

8.1 Intrinsic Functions
=======================

GnuCOBOL supports a wide variety of "intrinsic functions" that may be
used anywhere in the PROCEDURE DIVISION where a literal is allowed.  For
example:


     MOVE FUNCTION LENGTH(Employee-Last-Name) TO Employee-LN-Len

   Note how the word ‘FUNCTION’ is part of the syntax when you use an
intrinsic function.  You can use intrinsic functions without having to
include the reserved word ‘FUNCTION’ via settings in the ‘REPOSITORY’
(*note REPOSITORY::) paragraph.  You may accomplish the same thing by
specifying the ‘-fintrinsics’ switch to the GnuCOBOL compiler when you
compile your programs.

   User-written functions (*note Subprogram Types::) never require the
‘FUNCTION’ keyword when they are executed, because each user-written
function a program uses must be included in that program's ‘REPOSITORY’
paragraph, which therefore makes the ‘FUNCTION’ keyword optional.

   The following intrinsic functions, known to other "dialects" of
COBOL, are defined to GnuCOBOL as reserved words but are not otherwise
implemented currently.  Any attempts to use these functions will result
in a compile-time error message.  However they are described at the end
of this chapter.

     BOOLEAN-OF-INTEGER
     CHAR-NATIONAL
     DISPLAY-OF
     EXCEPTION-FILE-N
     EXCEPTION-LOCATION-N
     INTEGER-OF-BOOLEAN
     NATIONAL-OF
     STANDARD-COMPARE


Date and Time Formats
~~~~~~~~~~~~~~~~~~~~~

   For functions ‘FORMATTED-CURRENT-DATE’, ‘FORMATTED-DATE’,
‘FORMATTED-TIME’, and ‘FORMATTED-DATETIME’, the format literal argument
indicates the format of the date or time value that is the result of the
function.  The result of the function will have the same type as its
format literal, which can be alphanumeric, national or UTF-8.

   For functions ‘INTEGER-OF-FORMATTED-DATE’,
‘SECONDS-FROM-FORMATTED-TIME’, and ‘TEST-FORMATTED-DATETIME’, the format
literal indicates the format of the date or time value specified as the
second argument of the function.

   The permissible format strings are listed as follows.  For a full
description of each subfield in the format literals, including a range
of permissible values in data associated with the formats, see the Value
meanings and limits section.


Integer date form:
~~~~~~~~~~~~~~~~~

   A value in integer date form is a positive integer that represents
the number of days since 31 December, 1600 in the Gregorian calendar.

   It must be greater than zero and less than or equal to the value of
FUNCTION INTEGER-OF-DATE (99991231), which is 3,067,671.


Standard date form:
~~~~~~~~~~~~~~~~~~

   A value in standard date form is an integer of the form YYYYMMDD,
calculated using (YYYY * 10,000) + (MM * 100) + DD, where:

   YYYY represents the year in the Gregorian calendar.  It must be an
integer in the range [1601, 9999].

   MM represents a month and must be an integer in the range [01, 12].

   DD represents a day and must be an integer in the range [01, 31],
valid for the specified month and year combination.


Julian date form:
~~~~~~~~~~~~~~~~

   A value in Julian date form is an integer of the form YYYYDDD,
calculated using (YYYY * 1000) + DDD, where:

   YYYY represents the year in the Gregorian calendar.  It must be an
integer in the range [1601, 9999].

   DDD represents the day of the year.  It must be a positive integer in
the range [1, 366], valid for the year specified.


UTC offset value:
~~~~~~~~~~~~~~~~

   A UTC offset value is an integer representation of offset from UTC
(Coordinated Universal Time) expressed in minutes.  The value must be
greater than or equal to -1439 and less than or equal to 1439.

   Note: The offset value 1439 represents 23 hours 59 minutes, which is
one minute less than a day.  Standard numeric time form

   A value in standard numeric time form is a numeric value representing
seconds past midnight.  The value must be greater than or equal to zero
and less than 86,400


Date and time formats:
~~~~~~~~~~~~~~~~~~~~~

   For functions ‘FORMATTED-CURRENT-DATE’, ‘FORMATTED-DATE’,
‘FORMATTED-TIME’, and ‘FORMATTED-DATETIME’, the format literal argument
indicates the format of the date or time value that is the result of the
function.  The result of the function will have the same type as its
format literal, which can be alphanumeric, national or UTF-8.

   For functions ‘INTEGER-OF-FORMATTED-DATE’,
‘SECONDS-FROM-FORMATTED-TIME’, and ‘TEST-FORMATTED-DATETIME’, the format
literal indicates the format of the date or time value specified as the
second argument of the function.

   The permissible format strings are listed as follows.  For a full
description of each subfield in the format literals, including a range
of permissible values in data associated with the formats, see Value
meanings and limits.


Date formats            Format literals
~~~~~~~~~~~~            ~~~~~~~~~~~~~~~

Basic calendar date     YYYYMMDD
Extended calendar date  YYYY-MM-DD
Basic ordinal date      YYYYDDD
Extended ordinal date   YYYY-DDD
Basic week date         YYYYWwwD
Extended week date      YYYY-Www-D

Integer-seconds time formats:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Integer-seconds time formats            Format literals

Basic local time                        hhmmss
Extended local time                     hh:mm:ss
Basic Coordinated Universal Time (UTC) 	hhmmssZ
Extended UTC time                       hh:mm:ssZ
Basic offset time                       hhmmss+hhmm
Extended offset time                   	hh:mm:ss+hh:mm

Fractional-seconds time formats:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Fractional-seconds time formats         Format literals
Basic local time                        hhmmss.ssss
Extended local time                     hh:mm:ss.ssss
Basic Coordinated Universal Time (UTC) 	hhmmss.ssssZ
Extended UTC time                       hh:mm:ss.ssssZ
Basic offset time                       hhmmss.ssss+hhmm
Extended offset time                    hh:mm:ss.ssss+hh:mm

   Note: The period is used as the decimal separator, and four "s"
characters after the period are used for illustrative purposes.  The
number of "s" characters that might be specified after the decimal
separator in these formats might range from 1 to 9.


Value meanings and limits:
~~~~~~~~~~~~~~~~~~~~~~~~~

The permissible date and time formats have the following meanings and limits:

Format    Meaning and limits
YYYY      Year, 1601-9999
MM        Month, 01-12
DD        Day of month, 01-{28|29|30|31} dependent on month sub-field
DDD       Day of year for ordinal date formats, 001-365|366
ww        Week of year, 01-53
D         Day of week, 1-7
W
-
hh        Hours, 00-23
mm        Minutes, 00-59
ss        Seconds, 00-59
.s        Fractional seconds, always prefixed with '.' then 1-9 's'
+|-hh:mm  UTC offset hours (extended times only), the offset can be adjusted
          upward (by a '+' prefix) or downward (by a - prefix). A prefix of 0
          (zero) indicates that an offset of UTC is not available on the system.
Z         UTC time indicator


Value meanings and limits:
~~~~~~~~~~~~~~~~~~~~~~~~~

The permissible date and time formats have the following meanings and limits:

Format 	Meaning and limits:
~~~~~~~~~~~~~~~~~~~~~~~~~~

YYYY      Year, 1601-9999
MM        Month, 01-12
DD        Day of month, 01-{28|29|30|31} dependent on month sub-field
DDD       Day of year for ordinal date formats, 001-365|366
ww        Week of year, 01-53
D         Day of week, 1-7
W
-
hh        Hours, 00-23
mm        Minutes, 00-59
ss        Seconds, 00-59
.s        Fractional seconds, always prefixed with '.' then 1-9 's'
+|-hh:mm  UTC offset hours (extended times only), the offset can be adjusted
          upward (by a '+' prefix) or downward (by a - prefix).

          A prefix of 0 (zero) indicates that an offset of UTC is not available
          on the system.
Z 	       UTC time indicator

   The supported intrinsic functions are listed in the following
sections, along with their syntax and usage notes.
* Menu:

* ABS
* ACOS
* ANNUITY
* ASIN
* ATAN
* BIT-OF
* BIT-TO-CHAR
* BYTE-LENGTH
* CHAR
* COMBINED-DATETIME
* CONCAT
* CONCATENATE
* CONTENT-LENGTH
* CONTENT-OF
* COS
* CURRENCY-SYMBOL
* CURRENT-DATE
* DATE-OF-INTEGER
* DATE-TO-YYYYMMDD
* DAY-OF-INTEGER
* DAY-TO-YYYYDDD
* E
* EXCEPTION-FILE
* EXCEPTION-LOCATION
* EXCEPTION-STATEMENT
* EXCEPTION-STATUS
* EXP
* EXP10
* FACTORIAL
* FORMATTED-CURRENT-DATE
* FORMATTED-DATE
* FORMATTED-DATETIME
* FORMATTED-TIME
* FRACTION-PART
* HEX-OF
* HEX-TO-CHAR
* HIGHEST-ALGEBRAIC
* INTEGER
* INTEGER-OF-DATE
* INTEGER-OF-DAY
* INTEGER-OF-FORMATTED-DATE
* INTEGER-PART
* LENGTH
* LENGTH-AN
* LOCALE-COMPARE
* LOCALE-DATE
* LOCALE-TIME
* LOCALE-TIME-FROM-SECONDS
* LOG
* LOG10
* LOWER-CASE
* LOWEST-ALGEBRAIC
* MAX
* MEAN
* MEDIAN
* MIDRANGE
* MIN
* MOD
* MODULE-CALLER-ID
* MODULE-DATE
* MODULE-FORMATTED-DATE
* MODULE-ID
* MODULE-PATH
* MODULE-SOURCE
* MODULE-TIME
* MONETARY-DECIMAL-POINT
* MONETARY-THOUSANDS-SEPARATOR
* NUMERIC-DECIMAL-POINT
* NUMERIC-THOUSANDS-SEPARATOR
* NUMVAL
* NUMVAL-C
* NUMVAL-C-V2
* NUMVAL-F
* ORD
* ORD-MAX
* ORD-MIN
* PI
* PRESENT-VALUE
* RANDOM
* RANGE
* REM
* REVERSE
* SECONDS-FROM-FORMATTED-TIME
* SECONDS-PAST-MIDNIGHT
* SIGN
* SIN
* SQRT
* STANDARD-DEVIATION
* STORED-CHAR-LENGTH
* SUBSTITUTE
* SUBSTITUTE-CASE
* SUM
* TAN
* TEST-DATE-YYYYMMDD
* TEST-DAY-YYYYDDD
* TEST-FORMATTED-DATETIME
* TEST-NUMVAL
* TEST-NUMVAL-C
* TEST-NUMVAL-F
* TRIM
* UPPER-CASE
* VARIANCE
* WHEN-COMPILED
* YEAR-TO-YYYY
* BOOLEAN-OF-INTEGER
* CHAR-NATIONAL
* DISPLAY-OF
* EXCEPTION-FILE-N
* EXCEPTION-LOCATION-N
* INTEGER-OF-BOOLEAN
* NATIONAL-OF
* STANDARD-COMPARE



File: gnucobpr.info,  Node: ABS,  Next: ACOS,  Up: Intrinsic Functions

8.1.1 ABS
---------

                          ABS Function Syntax
=======================================================================

 ABS(number)
 ~~~


=======================================================================
   This function determines and returns the absolute value of NUMBER (a
numeric literal or data item) supplied as an argument.

   Note that ‘ABSOLUTE-VALUE’ has an alias for this function.


File: gnucobpr.info,  Node: ACOS,  Next: ANNUITY,  Prev: ABS,  Up: Intrinsic Functions

8.1.2 ACOS
----------

                         ACOS Function Syntax
=======================================================================

 ACOS(cosine)
 ~~~~


=======================================================================
   The ‘ACOS’ function determines and returns the trigonometric
arc-cosine, or inverse cosine, of COSINE value (a numeric literal or
data item) supplied as an argument.

   The result will be an angle, expressed in radians.  You may convert
this to an angle measured in degrees, as follows:

     COMPUTE DEGREES = ( RADIANS * 180 ) / FUNCTION PI


File: gnucobpr.info,  Node: ANNUITY,  Next: ASIN,  Prev: ACOS,  Up: Intrinsic Functions

8.1.3 ANNUITY
-------------

                        ANNUITY Function Syntax
=======================================================================

 ANNUITY(interest-rate, number-of-periods)
 ~~~~~~~


=======================================================================
   This function returns a numeric value approximating the ratio of an
annuity paid at INTEREST-RATE (numeric data item or literal) for each of
NUMBER-OF-PERIODS (numeric data items or literals).

   INTEREST-RATE is the rate of interest paid at each payment.  If you
only have an annual interest rate and you wish to compute monthly
annuity payments, divide the annual interest rate by 12 and use that
value for INTEREST-RATE.

   Multiply the result of this function times the desired principal
amount to determine the amount of each period's payment.

   A note for the financially challenged: an annuity is basically a
reverse loan; an accountant would take the result of this function
multiplied by -1 times the principal amount to compute a loan payment
you are making.

  1. Here is an example of a program using this function.  Given a total
     amount of 100,000 USD and an annual interest of 5% the program
     calculates the monthly payment for the duration of one year, two
     years ...  up to 10 years.
     
              >>SOURCE FREE
     IDENTIFICATION DIVISION.
     PROGRAM-ID. PANNUITY.
     *> Given a total amount of 100,000 and an annual interest of 5%
     *> the program calculates monthly payment for a duration of 1 year, 2 years
     *> ...up to 10 years.
     DATA DIVISION.
     WORKING-STORAGE SECTION.
     01 Total-Loan       Pic 9(9)V99 value 100000.
     01 Interest-Rate    Pic 999V99  value 0.05.
     01 Interest-RateP   Pic 999V99  value zero.
     01 Months           Pic 999     value zero.
     01 Years            Pic 999     value zero.
     01 Monthly-Payment  Pic 9(9)V99.
     01 Total-Payments   Pic 9(9)V99.
     
     PROCEDURE DIVISION.
     DISPLAY SPACE
     COMPUTE Interest-RateP = Interest-Rate * 100
     DISPLAY 'Total Loan: ' Total-Loan ' USD - Interest Rate: ' Interest-RateP '%'
     DISPLAY SPACE
     DISPLAY ' Y   M  Monthly Amount    Total Payments'
     DISPLAY '--- ---  -------------    --------------'
     PERFORM 10 TIMES
       ADD 12 to Months
       COMPUTE Monthly-Payment = Total-Loan * FUNCTION ANNUITY ((Interest-Rate / 12),
                      Months)
       COMPUTE Total-Payments = Monthly-payment * Months
       COMPUTE Years = Months / 12
       DISPLAY Years ' ' Months '   ' Monthly-Payment ' USD  ' Total-Payments
     END-PERFORM
     ACCEPT omitted
     GOBACK.
     
  2. Other additional documentation:

  3. When the value of Interest-Rate is zero, the value returned by the
     function is the approximation of: (1 / Number-Periods) When the
     value of Interest-Rate is not zero, the value of the function is
     the approximation of: (Interest-Rate / (1 - (1 + Interest-Rate) **
     (- (Number-Periods))))



File: gnucobpr.info,  Node: ASIN,  Next: ATAN,  Prev: ANNUITY,  Up: Intrinsic Functions

8.1.4 ASIN
----------

                         ASIN Function Syntax
=======================================================================

 ASIN(sine)
 ~~~~


=======================================================================
   The ‘ASIN’ function determines and returns the trigonometric
arc-sine, or inverse sine, of SINE value (a numeric literal or data
item) supplied as an argument.

   The result will be an angle, expressed in radians.  You may convert
this to an angle measured in degrees, as follows:

     COMPUTE DEGREES = ( RADIANS * 180 ) / FUNCTION PI


File: gnucobpr.info,  Node: ATAN,  Next: BIT-OF,  Prev: ASIN,  Up: Intrinsic Functions

8.1.5 ATAN
----------

                         ATAN Function Syntax
=======================================================================

 ATAN(tangent)
 ~~~~


=======================================================================
   Use this function to determine and return the trigonometric
arc-tangent, or inverse tangent, of TANGENT value (a numeric literal or
data item) supplied as an argument.

   The result will be an angle, expressed in radians.  You may convert
this to an angle measured in degrees, as follows:

     COMPUTE DEGREES = ( RADIANS * 180 ) / FUNCTION PI


File: gnucobpr.info,  Node: BIT-OF,  Next: BIT-TO-CHAR,  Prev: ATAN,  Up: Intrinsic Functions

8.1.6 BIT-OF
------------

                        BIT-OF Function Syntax
=======================================================================

 BIT-OF (argument-1)
 ~~~~~~


=======================================================================
   ‘BIT-OF’ function returns an alphanumeric character string of '1' and
'0' characters, which represents the binary value of each byte in the
argument used on input.
  1. The function type is alphanumeric.
  2. ARGUMENT-1 must be a data item, literal, or an intrinsic function
     result of any data class.
Returned values:

  1. An alphanumeric character string consisting of the binary
     representation of each byte in ARGUMENT-1.
  2. The length of the character string returned, in bytes, is eight
     times the length of ARGUMENT-1, in bytes.


             >>SOURCE FREE
     *> Example of use of function BIT-OF
     identification division.
     program-id. pgmbitof.
     environment division.
     configuration section.
        repository. function all intrinsic.
     data division.
     working-storage section.
     01 AAA PIC XXX VALUE "1 2".
     01 BBB PIC XXX VALUE "A B".

     procedure division.
       display BIT-OF(1)     at 0110
       display BIT-OF(2)     at 0210
       display BIT-OF(3)     at 0310
       display BIT-OF(0123)  at 0410
       display BIT-OF(AAA)   at 0510
       display BIT-OF(BBB)   at 0610
       accept omitted
       stop run.

     Produces :

     00110001
     00110010
     00110011
     00110000001100010011001000110011
     001100010010000000110010
     010000010010000001000010



File: gnucobpr.info,  Node: BIT-TO-CHAR,  Next: BYTE-LENGTH,  Prev: BIT-OF,  Up: Intrinsic Functions

8.1.7 BIT-TO-CHAR
-----------------

                      BIT-TO-CHAR Function Syntax
=======================================================================

 BIT-TO-CHAR {argument-1)
 ~~~~~~~~~~~


=======================================================================
   ‘BIT-TO-CHAR’ function returns a character string that represents a
bit pattern supplied on input.
  1. The function type is alphanumeric.
  2. ARGUMENT-1 must be an alphanumeric literal, alphanumeric data item,
     or alphanumeric group item.
  3. ARGUMENT-1 must consist only of the characters "0" and "1".
  4. The length of ARGUMENT-1 must be a multiple of 8 bytes.

Returned values:
  1. A character string consisting of bytes representing the sequence of
     "0" and "1" characters in ARGUMENT-1.
  2. The length of the result string is equal to the length of the input
     string divided by 8.


             >>SOURCE FREE
     *> Example of use of function BIT-TO-CHAR
     identification division.
     program-id. pgmbittochar.
     environment division.
     configuration section.
       repository. function all intrinsic.
     data division.
     working-storage section.
     01 AAA PIC X(8) VALUE "0110000".

     procedure division.
       display BIT-TO-CHAR("00110000") at 0610
       display BIT-TO-CHAR("00110001") at 0710
       display BIT-TO-CHAR("00110010") at 0810
       display BIT-TO-CHAR("00110011") at 0910
       display BIT-TO-CHAR(AAA)        at 1010
       accept omitted
       stop run.

     Produces:

         0
         1
         2
         3
         a



File: gnucobpr.info,  Node: BYTE-LENGTH,  Next: CHAR,  Prev: BIT-TO-CHAR,  Up: Intrinsic Functions

8.1.8 BYTE-LENGTH
-----------------

                      BYTE-LENGTH Function Syntax
=======================================================================

 BYTE-LENGTH(string)
 ~~~~~~~~~~~


=======================================================================
   ‘BYTE-LENGTH’ returns the length -- in bytes -- of STRING (a group
item, ‘USAGE DISPLAY’ elementary item or alphanumeric literal).  This
intrinsic function is identical to the ‘LENGTH-AN’ (*note LENGTH-AN::)
function.  Note that the value returned by this function is not
necessarily the number of characters comprising STRING, but rather the
number of actual bytes required to store it.

   For example, if STRING is encoded using a double-byte character set
such as Unicode UTF-16 (where each character is represented by 16 bits
of storage, not the 8-bits inherent to character sets like ASCII or
EBCDIC), then calling this function with a STRING argument whose
‘PICTURE’ (*note PICTURE::) is ‘N(4)’ would return a value of 8 rather
than the value 4.

   Contrast this with the ‘LENGTH’ (*note LENGTH::) function.


File: gnucobpr.info,  Node: CHAR,  Next: COMBINED-DATETIME,  Prev: BYTE-LENGTH,  Up: Intrinsic Functions

8.1.9 CHAR
----------

                         CHAR Function Syntax
=======================================================================

 CHAR(integer)
 ~~~~


=======================================================================
   This function returns the character in the ordinal position specified
by INTEGER (a numeric integer literal or data item with a value of 1 or
greater) from the ‘COLLATING SEQUENCE’ (*note OBJECT-COMPUTER::) being
used by the program.

   For example, if the program is using the (default) ASCII character
set, CHAR(34) returns the 34th character in the ASCII character set --
an exclamation-point (‘!’).  If you are using this function to convert a
numeric value to its corresponding ASCII character, you must use an
argument value one greater than the numeric value.

   If an argument whose value is less than 1 or greater than 256 is
specified, the character in the program collating sequence corresponding
to a value of all zero bits is returned.

   The following code is an alternative approach when you just wish to
convert a number to its ASCII equivalent:

     01  Char-Value.
         05 Numeric-Value        USAGE BINARY-CHAR.
     ...
         MOVE numeric-character-value TO Numeric-Value

   The ‘Char-Value’ item now has the corresponding ASCII character
value.


File: gnucobpr.info,  Node: COMBINED-DATETIME,  Next: CONCAT,  Prev: CHAR,  Up: Intrinsic Functions

8.1.10 COMBINED-DATETIME
------------------------

                   COMBINED-DATETIME Function Syntax
=======================================================================

 COMBINED-DATETIME(days, seconds)
 ~~~~~~~~~~~~~~~~~


=======================================================================
   This function returns a 12-digit numeric result, the first seven
digits of which are the integer value of DAYS argument (a numeric data
item or literal) and the last five of which are the integer value of
SECONDS argument (also a numeric data item or literal).

   If DAYS is less than 1 or greater than 3,067,671, or if SECONDS is
less than 1 or greater than 86,400, a value of 0 is returned and a
runtime error will result.

   DAYS Must be in integer date form.  For details, see Integer date
form.  A value in integer date form is a positive integer that
represents a number of days succeeding 31 December 1600, in the
Gregorian calendar.  It is based on a starting date of Monday, 1 January
1601 and integer date 1 represents Monday, 1 January 1601.

   SECONDS Must be in standard numeric time form.  For details, see
Standard numeric time form.  A value in standard numeric time form is a
numeric value representing seconds past midnight.

   The returned value is determined by arithmetic expression Days-1 +
(Seconds-2/100000).  The date occupies the integer part of the returned
value and the time is represented in the fractional part of the returned
value.

   Example Given the integer date form value "143951", which represents
the date 15 February 1995, and the standard numeric time form value
"18867.812479168304", which represents the time "05:14:27.812479168304",
the returned value would be exactly "143951.1886781247".



File: gnucobpr.info,  Node: CONCAT,  Next: CONCATENATE,  Prev: COMBINED-DATETIME,  Up: Intrinsic Functions

8.1.11 CONCAT
-------------

                        CONCAT Function Syntax
=======================================================================

 CONCAT | CONCATENATE (argument-1 [, argument-2 ]...)
 ~~~~~~   ~~~~~~~~~~~


=======================================================================
   This function concatenates the ARGUMENT-1, ARGUMENT-2, ... (group
items, ‘USAGE DISPLAY’ elementary items and/or alphanumeric literals)
together into a single string result.

   If a numeric literal or ‘PIC 9’ identifier is specified as an
argument, decimal points, if any, will be removed and negative signs in
‘PIC S9’ fields or numeric literals will be inserted as defined by the
‘SIGN IS’ (*note SIGN IS::) clause (or absence thereof) of the field.
Numeric literals are processed as if ‘SIGN IS TRAILING SEPARATE’ were in
effect.



File: gnucobpr.info,  Node: CONCATENATE,  Next: CONTENT-LENGTH,  Prev: CONCAT,  Up: Intrinsic Functions

8.1.12 CONCATENATE
------------------

                      CONCATENATE Function Syntax
=======================================================================

 CONCAT | CONCATENATE (argument-1 [, argument-2 ]...)
 ~~~~~~   ~~~~~~~~~~~


=======================================================================
   This function concatenates the STRING-1, STRING-2, ... (group items,
‘USAGE DISPLAY’ elementary items and/or alphanumeric literals) together
into a single string result.

   If a numeric literal or ‘PIC 9’ identifier is specified as an
argument, decimal points, if any, will be removed and negative signs in
‘PIC S9’ fields or numeric literals will be inserted as defined by the
‘SIGN IS’ (*note SIGN IS::) clause (or absence thereof) of the field.
Numeric literals are processed as if ‘SIGN IS TRAILING SEPARATE’ were in
effect.

   CONCATENATE is a GnuCOBOL extention BUT also see the ISO standard
CONCAT function.



File: gnucobpr.info,  Node: CONTENT-LENGTH,  Next: CONTENT-OF,  Prev: CONCATENATE,  Up: Intrinsic Functions

8.1.13 CONTENT-LENGTH
---------------------

                    CONTENT-LENGTH Function Syntax
=======================================================================

  CONTENT-LENGTH argument-1
  ~~~~~~~~~~~~~~


=======================================================================
   Scans for a NUL byte delimiter of the data starting at address in
given pointer, and returns the length.  The NUL byte is not included in
the count.  An EC-DATA-PTR-NUL exception is set to exist if the pointer
is NUL, and a zero length is returned.

   Function CONTENT-LENGTH is a GnuCOBOL extention.

Example:

 01  ptr USAGE POINTER.
 01  str  PIC X(4)  VALUE z"abc".

     SET      ptr TO ADDESS OF str.
     DISPLAY  FUNCTION CONTENT-LENGTH (str).

 Will display 3.



File: gnucobpr.info,  Node: CONTENT-OF,  Next: COS,  Prev: CONTENT-LENGTH,  Up: Intrinsic Functions

8.1.14 CONTENT-OF
-----------------

                      CONTENT-OF Function Syntax
=======================================================================

  CONTENT-OF pointer-1 { length }
  ~~~~~~~~~~


=======================================================================
   Takes a pointer and optional length.  Returns a character field of
the data addressed by the pointer, either up to a NUL byte or to the
given length.

   The NUL byte is not included in the data when no optional length is
given.  With an optional count, the character field can hold any content
including NUL bytes,

   An EC-DATA-PTR-NUL exception is set to exist if the pointer is NUL,
and a zero length space is returned.

   An EC-SIZE-TRANCATION is set if the resulting field would exceed
character field limits and the data is truncated.

   Reference modification is allowed on resulting field.

   Function CONTENT-OF is a GnuCOBOL extention.



File: gnucobpr.info,  Node: COS,  Next: CURRENCY-SYMBOL,  Prev: CONTENT-OF,  Up: Intrinsic Functions

8.1.15 COS
----------

                          COS Function Syntax
=======================================================================

 COS(angle)
 ~~~


=======================================================================
   The ‘COS’ function determines and returns the trigonometric cosine of
ANGLE (a numeric literal or data item) supplied as an argument.

   ANGLE is assumed to be a value expressed in radians.  If you need to
determine the cosine of an angle measured in degrees, you first need to
convert that angle to radians as follows:

     COMPUTE RADIANS = ( DEGREES * FUNCTION PI) / 180


File: gnucobpr.info,  Node: CURRENCY-SYMBOL,  Next: CURRENT-DATE,  Prev: COS,  Up: Intrinsic Functions

8.1.16 CURRENCY-SYMBOL
----------------------

                    CURRENCY-SYMBOL Function Syntax
=======================================================================

 CURRENCY-SYMBOL
 ~~~~~~~~~~~~~~~


=======================================================================
   The ‘CURRENCY-SYMBOL’ function returns the currency symbol character
currently in effect for the locale under which your program is running.
On UNIX systems, your locale is established via the ‘LANG’ run-time
environment variable (*note Run Time Environment Variables::)
environment variable.  On Windows, the Control Panel's "Regional and
Language Options" define the locale.

   Changing the currency symbol via the ‘SPECIAL-NAMES’ (*note
SPECIAL-NAMES::) paragraph's ‘CURRENCY SYMBOL’ setting will not affect
the value returned by this function.


File: gnucobpr.info,  Node: CURRENT-DATE,  Next: DATE-OF-INTEGER,  Prev: CURRENCY-SYMBOL,  Up: Intrinsic Functions

8.1.17 CURRENT-DATE
-------------------

                     CURRENT-DATE Function Syntax
=======================================================================

 CURRENT-DATE
 ~~~~~~~~~~~~


=======================================================================
   Returns the current date and time as the following 21-character
structure:

     01  CURRENT-DATE-AND-TIME.
         05 CDT-Year                PIC 9(4).
         05 CDT-Month               PIC 9(2). *> 01-12
         05 CDT-Day                 PIC 9(2). *> 01-31
         05 CDT-Hour                PIC 9(2). *> 00-23
         05 CDT-Minutes             PIC 9(2). *> 00-59
         05 CDT-Seconds             PIC 9(2). *> 00-59
         05 CDT-Hundredths-Of-Secs  PIC 9(2). *> 00-99
         05 CDT-GMT-Diff-Hours      PIC S9(2)
                                    SIGN LEADING SEPARATE.
         05 CDT-GMT-Diff-Minutes    PIC 9(2). *> 00 or 30

   Since this function has no arguments, no parenthesis should be
specified.


File: gnucobpr.info,  Node: DATE-OF-INTEGER,  Next: DATE-TO-YYYYMMDD,  Prev: CURRENT-DATE,  Up: Intrinsic Functions

8.1.18 DATE-OF-INTEGER
----------------------

                    DATE-OF-INTEGER Function Syntax
=======================================================================

 DATE-OF-INTEGER(integer)
 ~~~~~~~~~~~~~~~


=======================================================================
   This function returns a numeric calendar date in yyyymmdd (i.e.
Gregorian) format.  The date is determined by adding the number of days
specified as INTEGER (a numeric integer data item or literal) to the
date December 31, 1600.  For example, ‘DATE-OF-INTEGER(1)’ returns
16010101 while ‘DATE-OF-INTEGER(150000)’ returns 20110908.

   A value less than 1 or greater than 3067671 (9999/12/31) will return
a result of 0.


File: gnucobpr.info,  Node: DATE-TO-YYYYMMDD,  Next: DAY-OF-INTEGER,  Prev: DATE-OF-INTEGER,  Up: Intrinsic Functions

8.1.19 DATE-TO-YYYYMMDD
-----------------------

                   DATE-TO-YYYYMMDD Function Syntax
=======================================================================

 DATE-TO-YYYYMMDD(yymmdd [, yy-cutoff [, yy-execution-time ]])
 ~~~~~~~~~~~~~~~~


=======================================================================
   You can use this function to convert the six-digit Gregorian date
specified as YYMMDD (a numeric integer data item or literal) to an
eight-digit format (yyyymmdd).

   The optional YY-CUTOFF (a numeric integer data item or literal)
argument is the year cutoff used to delineate centuries; if the year
component of the date meets or exceeds this cutoff value, the result
will be 19yymmdd; if the year component of the date is less than the
cutoff value, the result will be 20yymmdd.  The default cutoff value if
no second argument is given will be 50.

   The optional YY-EXECUTION-TIME argument (a numeric integer data item
or literal) The default execution time value if no third argument is
given will be now equivalent to specifying ‘(FUNCTION NUMVAL (FUNCTION
CURRENT-DATE (1:4)))’.


File: gnucobpr.info,  Node: DAY-OF-INTEGER,  Next: DAY-TO-YYYYDDD,  Prev: DATE-TO-YYYYMMDD,  Up: Intrinsic Functions

8.1.20 DAY-OF-INTEGER
---------------------

                    DAY-OF-INTEGER Function Syntax
=======================================================================

 DAY-OF-INTEGER(integer)
 ~~~~~~~~~~~~~~


=======================================================================
   This function returns a calendar date in yyyyddd (i.e.  Julian)
format.  The date is determined by adding the number of days specified
as integer (a numeric integer data item or literal) to December 31,
1600.  For example, ‘DAY-OF-INTEGER(1)’ returns 1601001 while
‘DAY-OF-INTEGER(250000)’ returns 2011251.

   A value less than 1 or greater than 3067671 (9999/12/31) will return
a result of 0.


File: gnucobpr.info,  Node: DAY-TO-YYYYDDD,  Next: E,  Prev: DAY-OF-INTEGER,  Up: Intrinsic Functions

8.1.21 DAY-TO-YYYYDDD
---------------------

                    DAY-TO-YYYYDDD Function Syntax
=======================================================================

 DAY-TO-YYYYDDD(yyddd [, yy-cutoff [, yy-execution-time ]])
 ~~~~~~~~~~~~~~


=======================================================================
   You can use this function to convert the five-digit Julian date
specified as YYDDD (a numeric integer data item or literal) to a
seven-digit numeric Julian format (yyyyddd).

   The optional YY-CUTOFF argument (a numeric integer data item or
literal) is the year cutoff used to delineate centuries; if the year
component of the date meets or exceeds this cutoff value, the result
will be 19yyddd; if the year component of the date is less than the
cutoff, the result will be 20yyddd.  The default cutoff value if no
second argument is given will be 50.

   The optional YY-EXECUTION-TIME argument (a numeric integer data item
or literal) The default execution time value if no third argument is
given will be now equivalent to specifying (FUNCTION NUMVAL (FUNCTION
CURRENT-DATE (1:4))).


File: gnucobpr.info,  Node: E,  Next: EXCEPTION-FILE,  Prev: DAY-TO-YYYYDDD,  Up: Intrinsic Functions

8.1.22 E
--------

                           E Function Syntax
=======================================================================

 E
 ~


=======================================================================
   This function returns the mathematical constant E (the base of
natural logarithms).  The maximum precision with which this value may be
returned is 2.7182818284590452353602874713526625.

   Since this function has no arguments, no parenthesis should be
specified.


File: gnucobpr.info,  Node: EXCEPTION-FILE,  Next: EXCEPTION-LOCATION,  Prev: E,  Up: Intrinsic Functions

8.1.23 EXCEPTION-FILE
---------------------

                    EXCEPTION-FILE Function Syntax
=======================================================================

 EXCEPTION-FILE
 ~~~~~~~~~~~~~~


=======================================================================
   This function returns I/O exception information from the
most-recently executed input or output statement.  The information is
returned as a 34-character string, where the first two characters are
the two-digit file status value (*note File Status Codes::) and the
remaining 32 are the FILE-NAME-1 specification from the file's ‘SELECT’
(*note SELECT::) statement.

   The name returned after the file status information will be returned
only if the returned file status value is not 00.

   Since this function has no arguments, no parenthesis should be
specified.

   The documentation of the ‘CBL_ERROR_PROC’ built-in system subroutine
(*note CBL_ERROR_PROC::) built-in subroutine illustrates the use of this
function.


File: gnucobpr.info,  Node: EXCEPTION-LOCATION,  Next: EXCEPTION-STATEMENT,  Prev: EXCEPTION-FILE,  Up: Intrinsic Functions

8.1.24 EXCEPTION-LOCATION
-------------------------

                  EXCEPTION-LOCATION Function Syntax
=======================================================================

 EXCEPTION-LOCATION
 ~~~~~~~~~~~~~~~~~~


=======================================================================
   This function returns exception information from the most-recently
failing statement.  The information is returned to a 1023 character
string in one of the following formats, depending on the nature of the
failure:

   • primary-entry-point-name; paragraph OF section; statement-number

   • primary-entry-point-name; section; statement-number

   • primary-entry-point-name; paragraph; statement-number

   • primary-entry-point-name; statement-number

   Since this function has no arguments, no parenthesis should be
specified.

   The program must be compiled with the ‘-debug’ switch, ‘-ftraceall’
switch or ‘-g’ switch for this function to return any meaningful
information.

   The documentation of the ‘CBL_ERROR_PROC’ built-in system subroutine
(*note CBL_ERROR_PROC::) built-in subroutine illustrates the use of this
function.


File: gnucobpr.info,  Node: EXCEPTION-STATEMENT,  Next: EXCEPTION-STATUS,  Prev: EXCEPTION-LOCATION,  Up: Intrinsic Functions

8.1.25 EXCEPTION-STATEMENT
--------------------------

                  EXCEPTION-STATEMENT Function Syntax
=======================================================================

 EXCEPTION-STATEMENT
 ~~~~~~~~~~~~~~~~~~~


=======================================================================
   This function returns the most-recent COBOL statement that generated
an exception condition.

   Since this function has no arguments, no parenthesis should be
specified.

   The program must be compiled with the ‘-debug’ switch, ‘-ftraceall’
switch or ‘-g’ switch for this function to return any meaningful
information.

   The documentation of the ‘CBL_ERROR_PROC’ built-in system subroutine
(*note CBL_ERROR_PROC::) built-in subroutine illustrates the use of this
function.


File: gnucobpr.info,  Node: EXCEPTION-STATUS,  Next: EXP,  Prev: EXCEPTION-STATEMENT,  Up: Intrinsic Functions

8.1.26 EXCEPTION-STATUS
-----------------------

                   EXCEPTION-STATUS Function Syntax
=======================================================================

 EXCEPTION-STATUS
 ~~~~~~~~~~~~~~~~


=======================================================================
   This function returns the error type (a text string -- see column 2
of the upcoming table for the possible values) from the most-recent
COBOL statement that generated an exception condition.

   Since this function has no arguments, no parenthesis should be
specified.

   The documentation of the ‘CBL_ERROR_PROC’ built-in system subroutine
(*note CBL_ERROR_PROC::) built-in subroutine illustrates the use of this
function.

   The following are the error type strings, and their corresponding
exception codes and descriptions.
Code  Error Type                Description
                                
--------------------------------------------------------------------------
‘0101’‘EC-ARGUMENT-FUNCTION’    Function argument error
                                
‘0202’‘EC-BOUND-ODO’            ‘OCCURS ... DEPENDING’ ON data item out
                                of bounds
                                
‘0204’‘EC-BOUND-PTR’            Data-pointer contains an address that
                                is out of bounds
                                
‘0205’‘EC-BOUND-REF-MOD’        Reference modifier out of bounds
                                
‘0207’‘EC-BOUND-SUBSCRIPT’      Subscript out of bounds
                                
‘0303’‘EC-DATA-INCOMPATIBLE’    Incompatible data exception
                                
‘0500’‘EC-I-O’                  input-output exception
                                
‘0501’‘EC-I-O-AT-END’           I-O status ‘1x’
                                
‘0502’‘EC-I-O-EOP’              An end of page condition occurred
                                
‘0504’‘EC-I-O-FILE-SHARING’     I-O status ‘6x’
                                
‘0505’‘EC-I-O-IMP’              I-O status ‘9x’
                                
‘0506’‘EC-I-O-INVALID-KEY’      I-O status ‘2x’
                                
‘0508’‘EC-I-O-LOGIC-ERROR’      I-O status ‘4x’
                                
‘0509’‘EC-I-O-PERMANENT-ERROR’  I-O status ‘3x’
                                
‘050A’‘EC-I-O-RECORD-OPERATION’ I-O status ‘5x’
                                
‘0601’‘EC-IMP-ACCEPT’           Implementation-defined accept condition
                                
‘0602’‘EC-IMP-DISPLAY’          Implementation-defined display
                                condition
                                
‘0A00’‘EC-OVERFLOW’             Overflow condition
                                
‘0A02’‘EC-OVERFLOW-STRING’      ‘STRING’ overflow condition
                                
‘0A03’‘EC-OVERFLOW-UNSTRING’    ‘UNSTRING’ overflow condition
                                
‘0B05’‘EC-PROGRAM-NOT-FOUND’    Called program not found
                                
‘0D03’‘EC-RANGE-INSPECT-SIZE’   Size of replace item in inspect differs
                                
‘1000’‘EC-SIZE’                 Size error exception
                                
‘1004’‘EC-SIZE-OVERFLOW’        Arithmetic overflow in calculation
                                
‘1005’‘EC-SIZE-TRUNCATION’      Significant digits truncated in store
                                
‘1007’‘EC-SIZE-ZERO-DIVIDE’     Division by zero
                                
‘1202’‘EC-STORAGE-NOT-ALLOC’    The data-pointer specified in a ‘FREE’
                                statement does not identify currently
                                allocated storage
                                
‘1203’‘EC-STORAGE-NOT-AVAIL’    The amount of storage requested by an
                                ‘ALLOCATE’ statement is not available


File: gnucobpr.info,  Node: EXP,  Next: EXP10,  Prev: EXCEPTION-STATUS,  Up: Intrinsic Functions

8.1.27 EXP
----------

                          EXP Function Syntax
=======================================================================

 EXP(number)
 ~~~


=======================================================================
   Computes and returns the value of the mathematical constant e raised
to the power specified by NUMBER (a numeric literal or data item).


File: gnucobpr.info,  Node: EXP10,  Next: FACTORIAL,  Prev: EXP,  Up: Intrinsic Functions

8.1.28 EXP10
------------

                         EXP10 Function Syntax
=======================================================================

 EXP10(number)
 ~~~~~


=======================================================================
   Computes and returns the value of 10 raised to the power specified by
NUMBER (a numeric literal or data item).


File: gnucobpr.info,  Node: FACTORIAL,  Next: FORMATTED-CURRENT-DATE,  Prev: EXP10,  Up: Intrinsic Functions

8.1.29 FACTORIAL
----------------

                       FACTORIAL Function Syntax
=======================================================================

 FACTORIAL(number)
 ~~~~~~~~~


=======================================================================
   This function computes and returns the factorial value of NUMBER (a
numeric literal or data item).


File: gnucobpr.info,  Node: FORMATTED-CURRENT-DATE,  Next: FORMATTED-DATE,  Prev: FACTORIAL,  Up: Intrinsic Functions

8.1.30 FORMATTED-CURRENT-DATE
-----------------------------

                FORMATTED-CURRENT-DATE Function Syntax
=======================================================================

 FORMATTED-CURRENT-DATE ( argument-1 )
 ~~~~~~~~~~~~~~~~~~~~~~


=======================================================================
   ‘FORMATTED-CURRENT-DATE’ returns the current date and time provided
by the system at run-time, formatted according to date-and-time-format
according to the argument type.

   FUNCTION FORMATTED-CURRENT-DATE gives you exactly what you asked it
to, including up to nanoseconds (8 decimal positions in the seconds)
[but the system may only provide miliseconds, especially on older
win32].

   The function argument must be a national or alphanumeric literal and
the content, a combined date and time format.

   The returned value is formatted to the same form as ARGUMENT-1.


File: gnucobpr.info,  Node: FORMATTED-DATE,  Next: FORMATTED-DATETIME,  Prev: FORMATTED-CURRENT-DATE,  Up: Intrinsic Functions

8.1.31 FORMATTED-DATE
---------------------

                    FORMATTED-DATE Function Syntax
=======================================================================

 FORMATTED-DATE ( argument-1, argument-2 )
 ~~~~~~~~~~~~~~


=======================================================================
   ‘FORMATTED-DATE’ uses a format to convert a date in integer date form
to a date in the requested format.  The returned value will be in date
format.

   ARGUMENT-1 shall be a national or alphanumeric literal.

   ARGUMENT-2 shall be a value in integer date form.

   Example Given the date format "YYYYMMDD" and the value "143951",
which represents the date 15 February 1995, the returned value would be
"19950215".



File: gnucobpr.info,  Node: FORMATTED-DATETIME,  Next: FORMATTED-TIME,  Prev: FORMATTED-DATE,  Up: Intrinsic Functions

8.1.32 FORMATTED-DATETIME
-------------------------

                  FORMATTED-DATETIME Function Syntax
=======================================================================

 FORMATTED-DATETIME ( argument-1, argument-2, argument-3, argument-4 )
 ~~~~~~~~~~~~~~~~~~


=======================================================================
   ‘FORMATTED-DATETIME’ uses a combined time and date form to convert
and combine a date in integer form and a numeric time expressed as
seconds past midnight in UTC. See Date and Time Formats for details.

   ARGUMENT-1 shall be a national or alphanumeric literal.

   ARGUMENT-2 shall be a value in integer date form.

   ARGUMENT-3 shall be a value in standard numeric time form.

   ARGUMENT-4 is an integer specifying the offset from UTC expressed in
minutes.  If specified but have a value equal or less than 1439.

   Note: The offset value 1439 represents 23 hours 59 minutes which is
one minutes less than a day.

   ARGUMENT-4 must not be specified if the time portion in ARGUMENT-1 is
neither a UTC nor an offset format.

   The returned value is a representation of the date contained in
ARGUMENT-2 combined with the time contained in ARGUMENT-3 according to
the format in ARGUMENT-1.

   If the format in ARGUMENT-1 indicates that the returned value is to
be expressed in UTC, the time portion of the returned value reflects the
adjustment of the value in ARGUMENT-3 by the offset in ARGUMENT-4.

   If the format in ARGUMENT-1 indicates that the time is to be returned
as an offset from UTC, the value in ARGUMENT-3 is reflected directly in
the time portion of the returned value and the offset in ARGUMENT-4 is
reflected directly in the offset portion of the returned value.

   Example If the first argument has the format "YYMMDDThhmmss.ss+hhmm",
the second argument the value "143951", the third argument the value
"18867.812479168304", and the fourth argument the value "+300", the
returned value would be "19950215T05142781+0500".



File: gnucobpr.info,  Node: FORMATTED-TIME,  Next: FRACTION-PART,  Prev: FORMATTED-DATETIME,  Up: Intrinsic Functions

8.1.33 FORMATTED-TIME
---------------------

                    FORMATTED-TIME Function Syntax
=======================================================================

 FORMATTED-TIME ( argument-1, argument-2, argument-3 )
 ~~~~~~~~~~~~~~


=======================================================================
   ‘FORMATTED-TIME’ converts a value representing seconds past midnight
formatted time of day with optional offset.

   ARGUMENT-1 shall be a national or alphanumeric literal.

   ARGUMENT-2 shall be a value in integer time form.

   ARGUMENT-3 is an integer specifying the offset from UTC expressed in
minutes.  If specified but have a value equal or less than 1439.

   Note: The offset value 1439 represents 23 hours 59 minutes which is
one minutes less than a day.

   ARGUMENT-3 must not be specified if the time portion in ARGUMENT-1 is
neither a UTC nor an offset format.

   Returned value :

   Is a representation of the standard numeric time contained in
ARGUMENT-2 according to the format in ARGUMENT-1.

   If the format in ARGUMENT-1 indicates that the returned value is to
be expressed in UTC, the time portion of the returned value reflects the
adjustment of the value in ARGUMENT-2 by the offset in ARGUMENT-3.

   If the format in ARGUMENT-1 indicates that the time is to be returned
as an offset from UTC, the value in ARGUMENT-2 is reflected directly in
the time portion of the returned value and the offset in ARGUMENT-3 is
reflected directly in the offset portion of the returned value.

   Example If the first argument has the format "hhmmss.ss+hhmm", the
second argument the value "18867.812479168304" which represents the
local time, and the third argument the value "-300", which represents
the five hours that Eastern Standard Time (EST) differs from UTC, the
returned value would be "05142781-0500".



File: gnucobpr.info,  Node: FRACTION-PART,  Next: HEX-OF,  Prev: FORMATTED-TIME,  Up: Intrinsic Functions

8.1.34 FRACTION-PART
--------------------

                     FRACTION-PART Function Syntax
=======================================================================

 FRACTION-PART(number)
 ~~~~~~~~~~~~~


=======================================================================
   This function returns that portion of NUMBER (a numeric data item or
a numeric literal) that occurs to the right of the decimal point.
‘FRACTION-PART(3.1415)’, for example, returns a value of 0.1415.  This
function is equivalent to the expression:

     NUMBER -- FUNCTION INTEGER-PART(NUMBER)

     Example:
     display "base - " FUNCTION FRACTION-PART(FLOATER).
     Gives
     base - 000.456789

  1. When moved to a variable, it MUST have a preceding 'V' in the
     PICTURE, i.e., PIC v(4).


File: gnucobpr.info,  Node: HEX-OF,  Next: HEX-TO-CHAR,  Prev: FRACTION-PART,  Up: Intrinsic Functions

8.1.35 HEX-OF
-------------

                        HEX-OF Function Syntax
=======================================================================

 HEX-OF {argument-1)
 ~~~~~~


=======================================================================
   ‘HEX-OF’ function returns an alphanumeric character string consisting
of a hexadecimal representation of the argument used on input.
  1. The type of the function is alphanumeric.
  2. ARGUMENT-1 must be a data item, literal, or an intrinsic function
     result of any data class.

Returned values:
  1. An alphanumeric character string consisting of a hexadecimal
     representation of ARGUMENT-1.
  2. The length of the character string returned, in bytes, is twice the
     length of ARGUMENT-1, in bytes.



File: gnucobpr.info,  Node: HEX-TO-CHAR,  Next: HIGHEST-ALGEBRAIC,  Prev: HEX-OF,  Up: Intrinsic Functions

8.1.36 HEX-TO-CHAR
------------------

                      HEX-TO-CHAR Function Syntax
=======================================================================

 HEX-TO-CHAR {argument-1)
 ~~~~~~~~~~~


=======================================================================
   ‘HEX-TO-CHAR’ function returns a character string that represents the
hexadecimal digit characters supplied on input.
  1. The type of the function is alphanumeric.
  2. ARGUMENT-1 must be an alphanumeric literal, alphanumeric data item,
     or alphanumeric group item.
  3. ARGUMENT-1 must consist only of the characters '0' through '9', 'A'
     through 'F', and 'a' through 'f'.
  4. The length of ARGUMENT-1 must be a multiple of 2 bytes.

Returned values:
  1. A character string of bytes representing the hexadecimal digit
     characters of ARGUMENT-1.
  2. The length of the result string is equal to the length of the input
     string divided by 2.



File: gnucobpr.info,  Node: HIGHEST-ALGEBRAIC,  Next: INTEGER,  Prev: HEX-TO-CHAR,  Up: Intrinsic Functions

8.1.37 HIGHEST-ALGEBRAIC
------------------------

                   HIGHEST-ALGEBRAIC Function Syntax
=======================================================================

 HIGHEST-ALGEBRAIC(numeric-identifier)
 ~~~~~~~~~~~~~~~~~


=======================================================================
   This function returns the highest (i.e.  largest or farthest away
from 0 in a positive direction if NUMERIC-IDENTIFIER is signed) value
that could possibly be stored in NUMERIC-IDENTIFIER.  Or in other words
the ‘HIGHEST-ALGEBRAIC’ function provide the ability to manipulate
numeric data items in a manner similar to the means that ‘HIGH-VALUES’
permit with alphanumeric data items, but without the risks of the data
incompatibilities associated with those figurative constants.


File: gnucobpr.info,  Node: INTEGER,  Next: INTEGER-OF-DATE,  Prev: HIGHEST-ALGEBRAIC,  Up: Intrinsic Functions

8.1.38 INTEGER
--------------

                        INTEGER Function Syntax
=======================================================================

 INTEGER(number)
 ~~~~~~~


=======================================================================
   The ‘INTEGER’ function returns the greatest integer value that is
less than or equal to NUMBER (a numeric literal or data item).


File: gnucobpr.info,  Node: INTEGER-OF-DATE,  Next: INTEGER-OF-DAY,  Prev: INTEGER,  Up: Intrinsic Functions

8.1.39 INTEGER-OF-DATE
----------------------

                    INTEGER-OF-DATE Function Syntax
=======================================================================

 INTEGER-OF-DATE(date)
 ~~~~~~~~~~~~~~~


=======================================================================
   This function converts DATE (a numeric integer data item or literal)
-- presumed to be a Gregorian calendar form standard date (YYYYMMDD) --
to internal date form (the number of days that have transpired since
1600/12/31).

   Once in that form, mathematical operations may be performed against
the internal date before it is transformed back into a date using the
‘DATE-OF-INTEGER’ (*note DATE-OF-INTEGER::) or ‘DAY-OF-INTEGER’ (*note
DAY-OF-INTEGER::) function.


File: gnucobpr.info,  Node: INTEGER-OF-DAY,  Next: INTEGER-OF-FORMATTED-DATE,  Prev: INTEGER-OF-DATE,  Up: Intrinsic Functions

8.1.40 INTEGER-OF-DAY
---------------------

                    INTEGER-OF-DAY Function Syntax
=======================================================================

 INTEGER-OF-DAY(date)
 ~~~~~~~~~~~~~~


=======================================================================
   This function converts DATE (a numeric integer data item or literal)
-- presumed to be a Julian calendar form standard date (YYYYDDD) -- to
internal date form (the number of days that have transpired since
1600/12/31).

   Once in that form, mathematical operations may be performed against
the internal date before it is transformed back into a date using the
‘DATE-OF-INTEGER’ (*note DATE-OF-INTEGER::) or ‘DAY-OF-INTEGER’ (*note
DAY-OF-INTEGER::) function.


File: gnucobpr.info,  Node: INTEGER-OF-FORMATTED-DATE,  Next: INTEGER-PART,  Prev: INTEGER-OF-DAY,  Up: Intrinsic Functions

8.1.41 INTEGER-OF-FORMATTED-DATE
--------------------------------

               INTEGER-OF-FORMATTED-DATE Function Syntax
=======================================================================

 INTEGER-OF-FORMATTED-DATE ( argument-1, argument-2 )
 ~~~~~~~~~~~~~~~~~~~~~~~~~


=======================================================================
   ‘INTEGER-OF-FORMATTED-DATE’ converts a date that is in specified
format to integer date form.

   ARGUMENT-1 shall be a national or alphanumeric literal.  The content
must be either a date format or a combined date and time format.

   ARGUMENT-2 shall be a data item of the same type as ARGUMENT-1.

   If ARGUMENT-1 is a date format the content of ARGUMENT-2 shall be a
valid date in that format.

   If ARGUMENT-1 is a combined date and time format, the content of
ARGUMENT-2 shall be a valid combined date and time in same format.


File: gnucobpr.info,  Node: INTEGER-PART,  Next: LENGTH,  Prev: INTEGER-OF-FORMATTED-DATE,  Up: Intrinsic Functions

8.1.42 INTEGER-PART
-------------------

                     INTEGER-PART Function Syntax
=======================================================================

 INTEGER-PART(number)
 ~~~~~~~~~~~~


=======================================================================
   Returns the integer portion of NUMBER (a numeric literal or data
item).


File: gnucobpr.info,  Node: LENGTH,  Next: LENGTH-AN,  Prev: INTEGER-PART,  Up: Intrinsic Functions

8.1.43 LENGTH
-------------

                        LENGTH Function Syntax
=======================================================================

 LENGTH(string)
 ~~~~~~


=======================================================================
   Returns the length -- in characters -- of STRING (a group item,
‘USAGE DISPLAY’ elementary item or alphanumeric literal).

   The value returned by this function is not the number of bytes of
storage occupied by string, but rather the number of actual characters
making up the string.  For example, if STRING is encoded using a
double-byte character set such as Unicode UTF-16 (where each character
is represented by 16 bits of storage, not the 8-bits inherent to
character sets like ASCII or EBCDIC), then calling this function with a
STRING argument whose ‘PICTURE is X(4)’ would return a value of 4 rather
than the value 8 (the actual number of bytes of storage occupied by that
item).

   Contrast this function with the ‘BYTE-LENGTH’ (*note BYTE-LENGTH::)
and ‘LENGTH-AN’ (*note LENGTH-AN::) functions.


File: gnucobpr.info,  Node: LENGTH-AN,  Next: LOCALE-COMPARE,  Prev: LENGTH,  Up: Intrinsic Functions

8.1.44 LENGTH-AN
----------------

                       LENGTH-AN Function Syntax
=======================================================================

 LENGTH-AN(string)
 ~~~~~~~~~


=======================================================================
   This function returns the length -- in bytes of storage -- of STRING
(a group item, ‘USAGE DISPLAY’ elementary item or alphanumeric literal).

   This intrinsic function is identical to the ‘BYTE-LENGTH’ (*note
BYTE-LENGTH::) function.

   Note that the value returned by this function is not the number of
characters making up the STRING, but rather the number of actual bytes
of storage required to store STRING.  For example, if STRING is encoded
using a double-byte character set such as Unicode UTF-16 (where each
character is represented by 16 bits of storage, not the 8-bits inherent
to character sets like ASCII or EBCDIC), then calling this function with
a STRING argument whose ‘PICTURE is N(4)’ would return a value of 8
rather than the value 4.

   Contrast this with the ‘LENGTH’ (*note LENGTH::) function.


File: gnucobpr.info,  Node: LOCALE-COMPARE,  Next: LOCALE-DATE,  Prev: LENGTH-AN,  Up: Intrinsic Functions

8.1.45 LOCALE-COMPARE
---------------------

                    LOCALE-COMPARE Function Syntax
=======================================================================

 LOCALE-COMPARE(argument-1, argument-2 [ , locale ])
 ~~~~~~~~~~~~~~


=======================================================================
   The ‘LOCALE-COMPARE’ function returns a character indicating the
result of comparing ARGUMENT-1 and ARGUMENT-2 using a
culturally-preferred ordering defined by a LOCALE.

   Either or both of the 1^{st} two arguments may be an alphanumeric
literal, a group item or an elementary item appropriate to storing
alphabetic or alphanumeric data.  If the lengths of the two arguments
are unequal, the shorter will be assumed to be padded to the right with
spaces.

   The two arguments will be compared, character by character, against
each other until their relationship to each other can be determined.
The comparison is made according to the cultural rules in effect for
LOCALE name or for the current locale if no LOCALE argument is
specified.  Once that relationship is determined, a one-character
alphanumeric value will be returned as follows:

   • ‘<’ -- If ARGUMENT-1 is determined to be less than ARGUMENT-2

   • ‘=’ -- If the two arguments are equal to each other

   • ‘>’ -- If ARGUMENT-1 is determined to be greater than ARGUMENT-2

   *Note LOCALE Names::, for a list of typically-available locale names.


File: gnucobpr.info,  Node: LOCALE-DATE,  Next: LOCALE-TIME,  Prev: LOCALE-COMPARE,  Up: Intrinsic Functions

8.1.46 LOCALE-DATE
------------------

                      LOCALE-DATE Function Syntax
=======================================================================

 LOCALE-DATE(date [, locale ])
 ~~~~~~~~~~~


=======================================================================
   Converts the eight-digit Gregorian DATE (a numeric integer data item
or literal) from yyyymmdd format to the format appropriate to the
current locale.  On a Windows system, this will be the "short date"
format as set using Control Panel.

   You may include an optional second argument to specify the LOCALE
name (group item or ‘PIC X’ identifier) you'd like to use for date
formatting.  If used, this second argument must be an identifier.
Locale names are specified using UNIX-standard names.


File: gnucobpr.info,  Node: LOCALE-TIME,  Next: LOCALE-TIME-FROM-SECONDS,  Prev: LOCALE-DATE,  Up: Intrinsic Functions

8.1.47 LOCALE-TIME
------------------

                      LOCALE-TIME Function Syntax
=======================================================================

 LOCALE-TIME(time [, locale ])
 ~~~~~~~~~~~


=======================================================================
   Converts the four- (hhmm) or six-digit (hhmmss) TIME (a numeric
integer data item or literal) to a format appropriate to the current
locale.  On a Windows system, this will be the "time" format as set
using Control Panel.

   You may include an optional LOCALE name (a group item or ‘PIC X’
identifier) you'd like to use for time formatting.  If used, this second
argument must be an identifier.  Locale names are specified using
UNIX-standard names.


File: gnucobpr.info,  Node: LOCALE-TIME-FROM-SECONDS,  Next: LOG,  Prev: LOCALE-TIME,  Up: Intrinsic Functions

8.1.48 LOCALE-TIME-FROM-SECONDS
-------------------------------

               LOCALE-TIME-FROM-SECONDS Function Syntax
=======================================================================

 LOCALE-TIME-FROM-SECONDS(seconds [, locale ])
 ~~~~~~~~~~~~~~~~~~~~~~~~


=======================================================================
   Converts the number of SECONDS since midnight (a numeric integer data
item or literal) to a format appropriate to the current locale.  On a
Windows system, this will be the "time" format as set using Control
Panel.

   You may include an optional LOCALE name (a group item or ‘PIC X’
identifier) you'd like to use for time formatting.  If used, this second
argument must be an identifier.  Locale names are specified using
UNIX-standard names.

   *Note LOCALE Names::, for a list of typically-available locale names.


File: gnucobpr.info,  Node: LOG,  Next: LOG10,  Prev: LOCALE-TIME-FROM-SECONDS,  Up: Intrinsic Functions

8.1.49 LOG
----------

                          LOG Function Syntax
=======================================================================

 LOG(number)
 ~~~


=======================================================================
   Computes and returns the natural logarithm (base e) of NUMBER (a
numeric literal or data item).


File: gnucobpr.info,  Node: LOG10,  Next: LOWER-CASE,  Prev: LOG,  Up: Intrinsic Functions

8.1.50 LOG10
------------

                         LOG10 Function Syntax
=======================================================================

 LOG10(number)
 ~~~~~


=======================================================================
   Computes and returns the base 10 logarithm of NUMBER (a numeric
literal or data item).


File: gnucobpr.info,  Node: LOWER-CASE,  Next: LOWEST-ALGEBRAIC,  Prev: LOG10,  Up: Intrinsic Functions

8.1.51 LOWER-CASE
-----------------

                      LOWER-CASE Function Syntax
=======================================================================

 LOWER-CASE(string)
 ~~~~~~~~~~


=======================================================================
   This function returns the value of STRING (a group item, ‘USAGE
DISPLAY’ elementary item or alphanumeric literal), converted entirely to
lower case.

   What constitutes a "letter" (or upper/lower case too, for that
manner) may be influenced through the use of a ‘CHARACTER
CLASSIFICATION’ (*note OBJECT-COMPUTER::).


File: gnucobpr.info,  Node: LOWEST-ALGEBRAIC,  Next: MAX,  Prev: LOWER-CASE,  Up: Intrinsic Functions

8.1.52 LOWEST-ALGEBRAIC
-----------------------

                   LOWEST-ALGEBRAIC Function Syntax
=======================================================================

 LOWEST-ALGEBRAIC(numeric-identifier)
 ~~~~~~~~~~~~~~~~


=======================================================================
   This function returns the lowest (i.e.  smallest or farthest away
from 0 in a negative direction if NUMERIC-IDENTIFIER is signed) value
that could possibly be stored in NUMERIC-IDENTIFIER.  Or in other words
this function ‘LOWEST-ALGEBRAIC’ provides the ability to manipulate
numeric data items in a manner similar to the means that ‘LOW-VALUES’
permit with alphanumeric data items, but without the risks of the data
incompatibilities associated with those figurative constants.


File: gnucobpr.info,  Node: MAX,  Next: MEAN,  Prev: LOWEST-ALGEBRAIC,  Up: Intrinsic Functions

8.1.53 MAX
----------

                          MAX Function Syntax
=======================================================================

 MAX(number-1 [, number-2 ]...)
 ~~~


=======================================================================
   This function returns the maximum value from the specified list of
numbers (each NUMBER-N may be a numeric data item or a numeric literal).


File: gnucobpr.info,  Node: MEAN,  Next: MEDIAN,  Prev: MAX,  Up: Intrinsic Functions

8.1.54 MEAN
-----------

                         MEAN Function Syntax
=======================================================================

 MEAN(number-1 [, number-2 ]...)
 ~~~~


=======================================================================
   This function returns the statistical mean value of the specified
list of numbers (each NUMBER-N may be a numeric data item or a numeric
literal).


File: gnucobpr.info,  Node: MEDIAN,  Next: MIDRANGE,  Prev: MEAN,  Up: Intrinsic Functions

8.1.55 MEDIAN
-------------

                        MEDIAN Function Syntax
=======================================================================

 MEDIAN(number-1 [, number-2 ]...)
 ~~~~~~


=======================================================================
   This function returns the statistical median value of the specified
list of numbers (each NUMBER-N may be a numeric data item or a numeric
literal).


File: gnucobpr.info,  Node: MIDRANGE,  Next: MIN,  Prev: MEDIAN,  Up: Intrinsic Functions

8.1.56 MIDRANGE
---------------

                       MIDRANGE Function Syntax
=======================================================================

 MIDRANGE(number-1 [, number-2 ]...)
 ~~~~~~~~


=======================================================================
   The ‘MIDRANGE’ (middle range) function returns a numeric value that
is the arithmetic mean (average) of the values of the minimum and
maximum numbers from the supplied list.  Each NUMBER-N may be a numeric
data items or a numeric literal.


File: gnucobpr.info,  Node: MIN,  Next: MOD,  Prev: MIDRANGE,  Up: Intrinsic Functions

8.1.57 MIN
----------

                          MIN Function Syntax
=======================================================================

 MIN(number-1 [, number-2 ]...)
 ~~~


=======================================================================
   This function returns the minimum value from the specified list of
numbers (each NUMBER-N may be a numeric data item or a numeric literal).


File: gnucobpr.info,  Node: MOD,  Next: MODULE-CALLER-ID,  Prev: MIN,  Up: Intrinsic Functions

8.1.58 MOD
----------

                          MOD Function Syntax
=======================================================================

 MOD(value, modulus)
 ~~~


=======================================================================
   This function returns the value of VALUE modulo MODULUS (essentially
the remainder from the division of VALUE by MODULUS).  Both arguments
may be numeric data items or numeric literals.  Either (or both) may
have a non-integer value.


File: gnucobpr.info,  Node: MODULE-CALLER-ID,  Next: MODULE-DATE,  Prev: MOD,  Up: Intrinsic Functions

8.1.59 MODULE-CALLER-ID
-----------------------

                   MODULE-CALLER-ID Function Syntax
=======================================================================

 MODULE-CALLER-ID
 ~~~~~~~~~~~~~~~~


=======================================================================
   This function returns the null string if it is executed within a main
program.  When executed with a subprogram, it returns the entry-point
name of the program that called the subprogram.

   The discussion of the ‘MODULE-TIME’ (*note MODULE-TIME::) function
includes a sample program that uses this function.

   Since this function has no arguments, no parenthesis should be
specified.


File: gnucobpr.info,  Node: MODULE-DATE,  Next: MODULE-FORMATTED-DATE,  Prev: MODULE-CALLER-ID,  Up: Intrinsic Functions

8.1.60 MODULE-DATE
------------------

                      MODULE-DATE Function Syntax
=======================================================================

 MODULE-DATE
 ~~~~~~~~~~~


=======================================================================
   This function Returns the date the GnuCOBOL program that is executing
the function was compiled, in the form yyyymmdd.

   The discussion of the ‘MODULE-TIME’ (*note MODULE-TIME::) function
includes a sample program that uses this function.

   Since this function has no arguments, no parenthesis should be
specified.


File: gnucobpr.info,  Node: MODULE-FORMATTED-DATE,  Next: MODULE-ID,  Prev: MODULE-DATE,  Up: Intrinsic Functions

8.1.61 MODULE-FORMATTED-DATE
----------------------------

                 MODULE-FORMATTED-DATE Function Syntax
=======================================================================

 MODULE-FORMATTED-DATE
 ~~~~~~~~~~~~~~~~~~~~~


=======================================================================
   This function returns the fully-formatted date and time when the
program executing the function was compiled.  The exact format of this
returned string value may vary depending on the operating system and
GnuCOBOL build type.

   The discussion of the ‘MODULE-TIME’ (*note MODULE-TIME::) function
includes a sample program that uses this function.

   Since this function has no arguments, no parenthesis should be
specified.


File: gnucobpr.info,  Node: MODULE-ID,  Next: MODULE-PATH,  Prev: MODULE-FORMATTED-DATE,  Up: Intrinsic Functions

8.1.62 MODULE-ID
----------------

                       MODULE-ID Function Syntax
=======================================================================

 MODULE-ID
 ~~~~~~~~~


=======================================================================
   This function returns the primary entry-point name (i.e.  the
‘PROGRAM-ID’ or ‘FUNCTION-ID’ of the program.  *Note IDENTIFICATION
DIVISION::, for information on those clauses.

   The discussion of the ‘MODULE-TIME’ (*note MODULE-TIME::) function
includes a sample program that uses this function.

   Since this function has no arguments, no parenthesis should be
specified.


File: gnucobpr.info,  Node: MODULE-PATH,  Next: MODULE-SOURCE,  Prev: MODULE-ID,  Up: Intrinsic Functions

8.1.63 MODULE-PATH
------------------

                      MODULE-PATH Function Syntax
=======================================================================

 MODULE-PATH
 ~~~~~~~~~~~


=======================================================================
   This function returns the full path to the executable version of this
GnuCOBOL program.  The filename component of this value will be exactly
as typed on the command line, down to the use of upper- and lower-case
letters and presence (or absence) of any extension.

   The discussion of the ‘MODULE-TIME’ (*note MODULE-TIME::) function
includes a sample program that uses this function.

   Since this function has no arguments, no parenthesis should be
specified.


File: gnucobpr.info,  Node: MODULE-SOURCE,  Next: MODULE-TIME,  Prev: MODULE-PATH,  Up: Intrinsic Functions

8.1.64 MODULE-SOURCE
--------------------

                     MODULE-SOURCE Function Syntax
=======================================================================

 MODULE-SOURCE
 ~~~~~~~~~~~~~


=======================================================================
   The filename of the source code of the program (as specified on the
‘cobc’ command when the program was compiled) is returned by this
function.

   The discussion of the ‘MODULE-TIME’ (*note MODULE-TIME::) function
includes a sample program that uses this function.

   Since this function has no arguments, no parenthesis should be
specified.


File: gnucobpr.info,  Node: MODULE-TIME,  Next: MONETARY-DECIMAL-POINT,  Prev: MODULE-SOURCE,  Up: Intrinsic Functions

8.1.65 MODULE-TIME
------------------

                      MODULE-TIME Function Syntax
=======================================================================

 MODULE-TIME
 ~~~~~~~~~~~


=======================================================================
   This function returns the time the GnuCOBOL program was compiled, in
the form hhmmss.

   Since this function has no arguments, no parenthesis should be
specified.

   The following sample program uses all the MODULE- Functions:

     IDENTIFICATION DIVISION.
     PROGRAM-ID. DEMOMODULE.
     ENVIRONMENT DIVISION.
     CONFIGURATION SECTION.
     REPOSITORY.
         FUNCTION ALL INTRINSIC.
     PROCEDURE DIVISION.
     000-Main.
         DISPLAY "MODULE-CALLER-ID      = [" MODULE-CALLER-ID ‘]’
         DISPLAY "MODULE-DATE           = [" MODULE-DATE ‘]’
         DISPLAY "MODULE-FORMATTED-DATE = [" MODULE-FORMATTED-DATE ‘]’
         DISPLAY "MODULE-ID             = [" MODULE-ID ‘]’
         DISPLAY "MODULE-PATH           = [" MODULE-PATH ‘]’
         DISPLAY "MODULE-SOURCE         = [" MODULE-SOURCE ‘]’
         DISPLAY "MODULE-TIME           = [" MODULE-TIME ‘]’
         STOP RUN
         .

   The program produces this output when executed:

     MODULE-CALLER-ID = []
     MODULE-DATE = [20180522]
     MODULE-FORMATTED-DATE = [May 22 2018 12:43:14]
     MODULE-ID = [DEMOMODULE]
     MODULE-PATH = [/home/vince/cobolsrc/ACAS/demomodule]
     MODULE-SOURCE = [demomodule.cbl]
     MODULE-TIME = [124314]


File: gnucobpr.info,  Node: MONETARY-DECIMAL-POINT,  Next: MONETARY-THOUSANDS-SEPARATOR,  Prev: MODULE-TIME,  Up: Intrinsic Functions

8.1.66 MONETARY-DECIMAL-POINT
-----------------------------

                MONETARY-DECIMAL-POINT Function Syntax
=======================================================================

 MONETARY-DECIMAL-POINT
 ~~~~~~~~~~~~~~~~~~~~~~


=======================================================================
   ‘MONETARY-DECIMAL-POINT’ returns the character used to separate the
integer portion from the fractional part of a monetary currency value
according to the rules currently in effect for the locale under which
your program is running.

   On UNIX (including OSX, Windows/Cygwin and Windows/MinGW) systems,
your locale is established via the ‘LANG’ run-time environment variable
(*note Run Time Environment Variables::) environment variable.  On
Windows, the Control Panel's Regional and Language Options define the
locale.

   Using the ‘DECIMAL-POINT IS COMMA’ (*note SPECIAL-NAMES::) clause in
your program will not affect the value returned by this function.

   Since this function has no arguments, no parenthesis should be
specified.


File: gnucobpr.info,  Node: MONETARY-THOUSANDS-SEPARATOR,  Next: NUMERIC-DECIMAL-POINT,  Prev: MONETARY-DECIMAL-POINT,  Up: Intrinsic Functions

8.1.67 MONETARY-THOUSANDS-SEPARATOR
-----------------------------------

             MONETARY-THOUSANDS-SEPARATOR Function Syntax
=======================================================================

 MONETARY-THOUSANDS-SEPARATOR
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~


=======================================================================
   This function returns the character used to separate the thousands
digit groupings of monetary currency values according to the rules
currently in effect for the locale under which your program is running.

   On UNIX (including OSX, Windows/Cygwin and Windows/MinGW) systems,
your locale is established via the ‘LANG’ run-time environment variable
(*note Run Time Environment Variables::) environment variable.  On
Windows, the Control Panel's Regional and Language Options define the
locale.

   Using the ‘DECIMAL-POINT IS COMMA’ (*note SPECIAL-NAMES::) clause in
your program will not affect the value returned by this function.

   Since this function has no arguments, no parenthesis should be
specified.


File: gnucobpr.info,  Node: NUMERIC-DECIMAL-POINT,  Next: NUMERIC-THOUSANDS-SEPARATOR,  Prev: MONETARY-THOUSANDS-SEPARATOR,  Up: Intrinsic Functions

8.1.68 NUMERIC-DECIMAL-POINT
----------------------------

                 NUMERIC-DECIMAL-POINT Function Syntax
=======================================================================

 NUMERIC-DECIMAL-POINT
 ~~~~~~~~~~~~~~~~~~~~~


=======================================================================
   This function returns the character used to separate the integer
portion of a non-integer numeric item from the fractional part according
to the rules currently in effect for the locale under which your program
is running.

   On UNIX (including OSX, Windows/Cygwin and Windows/MinGW) systems,
your locale is established via the ‘LANG’ run-time environment variable
(*note Run Time Environment Variables::) environment variable.  On
Windows, the Control Panel's Regional and Language Options define the
locale.

   Using the ‘DECIMAL-POINT IS COMMA’ (*note SPECIAL-NAMES::) clause in
your program will not affect the value returned by this function.

   Since this function has no arguments, no parenthesis should be
specified.


File: gnucobpr.info,  Node: NUMERIC-THOUSANDS-SEPARATOR,  Next: NUMVAL,  Prev: NUMERIC-DECIMAL-POINT,  Up: Intrinsic Functions

8.1.69 NUMERIC-THOUSANDS-SEPARATOR
----------------------------------

              NUMERIC-THOUSANDS-SEPARATOR Function Syntax
=======================================================================

 NUMERIC-THOUSANDS-SEPARATOR
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~


=======================================================================
   This function returns the character used to separate the thousands
digit groupings of numeric values according to the rules currently in
effect for the locale under which your program is running.

   On UNIX (including OSX, Windows/Cygwin and Windows/MinGW) systems,
your locale is established via the ‘LANG’ run-time environment variable
(*note Run Time Environment Variables::) environment variable.  On
Windows, the Control Panel's Regional and Language Options define the
locale.

   Using the ‘DECIMAL-POINT IS COMMA’ (*note SPECIAL-NAMES::) clause in
your program will not affect the value returned by this function.

   Since this function has no arguments, no parenthesis should be
specified.


File: gnucobpr.info,  Node: NUMVAL,  Next: NUMVAL-C,  Prev: NUMERIC-THOUSANDS-SEPARATOR,  Up: Intrinsic Functions

8.1.70 NUMVAL
-------------

                        NUMVAL Function Syntax
=======================================================================

 NUMVAL(string)
 ~~~~~~


=======================================================================
   The ‘NUMVAL’ function converts a STRING (a group item, ‘USAGE
DISPLAY’ elementary item or alphanumeric literal) to its corresponding
numeric value.

   The STRING must have any of the following formats, where '#'
represents a sequence of one or more decimal digits:

                   #   -#   +#   #-   #+   #CR   #DB

            #.#   -#.#   +#.#   #.#-   #.#+   #.#CR   #.#DB

   There must be at least one digit character in the string.

   Leading and/or trailing spaces are allowed, as are spaces before the
first digit.

   The character period in ARGUMENT-1 STRING, represents the decimal
separator.  The character comma in ARGUMENT-1 represents the grouping
separator.  When the ‘DECIMAL-POINT IS COMMA’ clause is specified, the
character comma shall be used in ARGUMENT-1 to represent the decimal
separator and the character period shall be used to represent the
grouping separator.

   Note: Locale-based functionality equivalent to ‘NUMVAL’ can be
obtained by using the ‘NUMVAL-C’ function with the ‘LOCALE’ keyword.  A
currency sign is optional in ‘NUMVAL-C’.  The locale category
‘LC_MONETARY’ will be used because there is no sign convention specified
in locale category ‘LC_NUMERIC’.

   Returned values:

   The returned value is the numeric value represented by STRING.

   If it contains a ‘CR’, ‘DB’, or the minus sign (‘-’), the returned
value is negative.



File: gnucobpr.info,  Node: NUMVAL-C,  Next: NUMVAL-C-2,  Prev: NUMVAL,  Up: Intrinsic Functions

8.1.71 NUMVAL-C
---------------

                       NUMVAL-C Function Syntax
=======================================================================

 NUMVAL-C (string [, symbol               ]
 ~~~~~~~~
                  [, LOCALE locale-name-1 ] [, ANYCASE ])


=======================================================================
   This function converts a STRING (a group item, ‘USAGE DISPLAY’
elementary item or alphanumeric literal) representing a currency value
to its corresponding numeric value.

   The currency string if any, and any grouping separators preceding the
decimal separator are ignored.  Optionally, the currency string, sign
convention, grouping separator and the decimal separator permitted in
the character string may be specified by locale category ‘LC-MONETARY’,
or the currency string may be specified by SYMBOL.

   The optional SYMBOL character represents the currency symbol (a
non-space single-character group item, ‘USAGE DISPLAY’ elementary item
or alphanumeric literal) that may be used as the currency character in
STRING.  Any spaces including leading or trailing are ignored.  If no
SYMBOL is specified, the value that would be returned by the
‘CURRENCY-SYMBOL’ intrinsic function (*note CURRENCY-SYMBOL::) will be
used.

   If this references the ‘LOCALE’ :

   Changing the currency symbol via the ‘SPECIAL-NAMES’ paragraph's
‘CURRENCY SYMBOL’ setting will not affect the value returned by this
function.

   While ‘NUMVAL-C’ will always use the currency symbol that is
specified via the ‘SPECIAL-NAMES’ paragraph's ‘CURRENCY SYMBOL’ (or the
system default which is currently always ‘$’).

   STRING may have any of the following formats, where '#' represents a
sequence of one or more decimal digits and '$' represents the SYMBOL
character:

                   #   -#   +#   #-   #+   #CR   #DB

            #.#   -#.#   +#.#   #.#-   #.#+   #.#CR   #.#DB

               $#   -$#   +$#   $#-   $#+   $#CR   $#DB

        $#.#   -$#.#   +$#.#   $#.#-   $#.#+   $#.#CR   $#.#DB

   There must be at least one digit character in the string.

   Leading and/or trailing spaces are allowed, as are spaces before
and/or after the currency symbol, sign, CR and DB characters.

   If the ‘ANYCASE’ keyword is used the matching rules for detecting a
currency string in ARGUMENT-1 are case-insensitive.  If the ‘ANYCASE’
keyword is not specified, the matching rules are case-sensitive.

   If neither symbol nor the ‘LOCALE’ keyword is specified, there shall
be only one currency string used, either the default currency sign or a
currency string specified in the ‘SPECIAL-NAMES’ paragraph.

   The returned value is the numeric value represented by string.

   When the ‘LOCALE’ keyword is specified, the returned value is
negative if string contains a negative sign.

   When the ‘LOCALE’ keyword is not specified, the returning value is
negative if string contains CR, DB, or a minus sign.


File: gnucobpr.info,  Node: NUMVAL-C-2,  Next: NUMVAL-F,  Prev: NUMVAL-C,  Up: Intrinsic Functions

8.1.72 NUMVAL-C-2
-----------------

                       NUMVAL-C Function Syntax
=======================================================================

 NUMVAL-C (argument-1 [, argument-2           ]
 ~~~~~~~~
                      [, LOCALE locale-name-1 ] [, ANYCASE ])


=======================================================================
   This function returns the numeric value represented by the character
string specified by ARGUMENT-1 and defined as alphanumeric.

   ARGUMENT-2, the currency string if any, and any grouping separators
preceding the decimal separator are ignored.  Optionally, the currency
string, sign convention, grouping separator and the decimal separator
permitted in the character string may be specified by locale category
‘LC-MONETARY’, or the currency string may be specified by ARGUMENT-2.

   The optional alphanumeric ARGUMENT-2 character represents the
currency symbol (a non-space and at least one single-character item,
that may be used as the currency character in ARGUMENT-1.  Any spaces
including leading or trailing are ignored.  If no ARGUMENT-2 is
specified, the value that would be returned by the ‘CURRENCY-SYMBOL’
intrinsic function (*note CURRENCY-SYMBOL::) will be used.  ARGUMENT-2
must not contain any of the digits - through 9, characters ‘*’, ‘+’,
‘-’, ‘,’ or ‘.’; or the two consecutive letters ‘CR’ or ‘DB’, whether
upper or lower case or a combination of both.

   ARGUMENT-2 specifies a currency string that may appear in ARGUMENT-1.

   If the ‘ANYCASE’ keyword is specified, the matching rules for
detecting a currency string in ARGUMENT-1 are case-insensitive.  If not
specified, the matching rules are case-sensitive.

   If neither ARGUMENT-2 nor the ‘LOCALE’ keyword is specified, there
shall be only one currency string used, either the default currency sign
or a currency string specified in the ‘SPECIAL-NAMES’ paragraph.

   While ‘NUMVAL-C’ will always use the currency symbol that is
specified via the ‘SPECIAL-NAMES’ paragraph's ‘CURRENCY SYMBOL’ (or the
system default which is currently always '$') ARGUMENT-1 shall have any
of the following formats, where '#' represents a sequence of one or more
decimal digits and '$' represents the SYMBOL character:

                   #   -#   +#   #-   #+   #CR   #DB

            #.#   -#.#   +#.#   #.#-   #.#+   #.#CR   #.#DB

               $#   -$#   +$#   $#-   $#+   $#CR   $#DB

        $#.#   -$#.#   +$#.#   $#.#-   $#.#+   $#.#CR   $#.#DB

   There must be at least one digit character in the string.

   Leading and/or trailing spaces are allowed, as are spaces before
and/or after the currency symbol, sign, CR and DB characters.

   The returned value is the numeric value represented by ARGUMENT-1.

   When the ‘LOCALE’ keyword is specified, the returned value is
negative if string contains a negative sign and when not specified, the
returning value is negative if string contains CR, DB, or a minus sign.


File: gnucobpr.info,  Node: NUMVAL-F,  Next: ORD,  Prev: NUMVAL-C-2,  Up: Intrinsic Functions

8.1.73 NUMVAL-F
---------------

                       NUMVAL-F Function Syntax
=======================================================================

 NUMVAL-F(char)
 ~~~~~~~~


=======================================================================
   This function converts a STRING (a group item, ‘USAGE DISPLAY’
elementary item or alphanumeric literal) representing a floating-point
value to its corresponding numeric value.

                    #   -#   +#   #E#   -#E#   +#E#

              #E+#   -#E+#   +#E+#   #E-#   -#E-#   +#E-#

              #.#   -#.#   +#.#   #.#E#   -#.#E#   +#.#E#

        #.#E+#   -#.#E+#   +#.#E+#   #.#E-#   -#.#E-#   +#.#E-#

   There must be at least one digit character both before and after the
‘E’ in the string.

   Leading and/or trailing spaces are allowed, as are spaces before
and/or after any sign characters.


File: gnucobpr.info,  Node: ORD,  Next: ORD-MAX,  Prev: NUMVAL-F,  Up: Intrinsic Functions

8.1.74 ORD
----------

                          ORD Function Syntax
=======================================================================

 ORD(char)
 ~~~


=======================================================================
   This function returns the ordinal position in the program character
set (usually ASCII) corresponding to the 1^{st} character of CHAR
argument (a group item, ‘USAGE DISPLAY’ elementary item or alphanumeric
literal).

   For example, assuming the program is using the standard ASCII
collating sequence, ‘ORD('!')’ returns 34 because ‘!’ is the 34th ASCII
character.  If you are using this function to convert an ASCII character
to its numeric value, you must subtract one from the result.

   The following code is an alternative approach when you just wish to
convert an ASCII character to its numeric equivalent:

     01  Char-Value.
         05 Numeric-Value        USAGE BINARY-CHAR.
     ...
         MOVE "character" TO Char-Value

   ‘Numeric-Value’ now has the numeric value of ‘character’.


File: gnucobpr.info,  Node: ORD-MAX,  Next: ORD-MIN,  Prev: ORD,  Up: Intrinsic Functions

8.1.75 ORD-MAX
--------------

                        ORD-MAX Function Syntax
=======================================================================

 ORD-MAX(char-1 [, char-2 ]...)
 ~~~~~~~


=======================================================================
   This function returns the ordinal position in the argument list
corresponding to the CHAR-N whose 1^{st} character has the highest
position in the program collating sequence (usually ASCII).

   For example, assuming the program is using the standard ASCII
collating sequence, ‘ORD-MAX('Z', 'z', '!')’ returns 2 because the 2nd
character in the argument list (the ASCII character ‘z’) occurs after
‘Z’ and ‘!’ in the program collating sequence.  Each CHAR-N argument may
be a group item, ‘USAGE DISPLAY’ elementary item or alphanumeric
literal.


File: gnucobpr.info,  Node: ORD-MIN,  Next: PI,  Prev: ORD-MAX,  Up: Intrinsic Functions

8.1.76 ORD-MIN
--------------

                        ORD-MIN Function Syntax
=======================================================================

 ORD-MIN(char-1 [, char-2 ]...)
 ~~~~~~~


=======================================================================
   This function returns the ordinal position in the argument list
corresponding to the CHAR-N whose 1^{st} character has the lowest
position in the program collating sequence (usually ASCII).

   For example, assuming the program is using the standard ASCII
collating sequence, ‘ORD-MIN('Z', 'z', '!')’ returns 3 because the 3rd
character in the argument list (the ASCII character ‘!’) occurs before
‘Z’ and ‘z’ in the program collating sequence.  Each CHAR-N argument may
be a group item, ‘USAGE DISPLAY’ elementary item or alphanumeric
literal.


File: gnucobpr.info,  Node: PI,  Next: PRESENT-VALUE,  Prev: ORD-MIN,  Up: Intrinsic Functions

8.1.77 PI
---------

                          PI Function Syntax
=======================================================================

 PI
 ~~


=======================================================================
   This function returns the mathematical constant PI. The maximum
precision with which this value may be returned is
3.1415926535897932384626433832795029.

   Since this function has no arguments, no parenthesis should be
specified.


File: gnucobpr.info,  Node: PRESENT-VALUE,  Next: RANDOM,  Prev: PI,  Up: Intrinsic Functions

8.1.78 PRESENT-VALUE
--------------------

                     PRESENT-VALUE Function Syntax
=======================================================================

 PRESENT-VALUE(rate, value-1 [, value-2 ])
 ~~~~~~~~~~~~~


=======================================================================
   The ‘PRESENT-VALUE’ function returns a value that approximates the
present value of a series of future period-end amounts specified by the
various VALUE-N arguments at a discount rate specified by the RATE
argument.

   All arguments are numeric data items and/or numeric literals.

  1. Example of function in use :

     
              >>SOURCE FREE
     IDENTIFICATION DIVISION.
     PROGRAM-ID. PPresValue.
     *> The sample: you pay for a machine 1500 USD
     *> You rent the machine at 350 USD per year per 5 years (= 1750).
     *> The program calculates (NET)PRESENT VALUE of 1750
     *> when the discount rate is 1%, 2% up to 10%.
     DATA DIVISION.
     WORKING-STORAGE SECTION.
     01  PaymentsNum      constant as   5.
     01  PaymentsAmount   constant as 350.
     01  Expenditure      PIC 999999V99 value 1500.
     01  TOTAL-CASH-FLOW  PIC 999999V99 value zero.
     01  DiscountRate     PIC S99V99 VALUE 0.00.
     77  DiscountRateP    PIC S99V99 VALUE 0.00.
     01  filler.
         05 PaymentAmount PIC S9999V99 OCCURS PaymentsNum TIMES VALUE PaymentsAmount.
     01  PresValue        PIC  9(6)V99  value zero.
     01  NET-PresValue    PIC S9(6)V99  value zero.
     
     PROCEDURE DIVISION.
     COMPUTE TOTAL-CASH-FLOW =
         FUNCTION SUM (PaymentAmount(1) PaymentAmount(2) PaymentAmount(3)
                       PaymentAmount(4) PaymentAmount(5))
     DISPLAY SPACE
     DISPLAY   'Expenditure: ' Expenditure ' Total Cashflow: ' TOTAL-CASH-FLOW
     DISPLAY SPACE
     
     PERFORM 10 TIMES
       COMPUTE DiscountRate  = DiscountRate + 0.01
       COMPUTE DiscountRateP = DiscountRate * 100
       COMPUTE PresValue ROUNDED =
           FUNCTION PRESENT-VALUE (DiscountRate PaymentAmount(1) PaymentAmount(2)
                               PaymentAmount(3) PaymentAmount(4) PaymentAmount(5))
       COMPUTE NET-PresValue = - Expenditure + PresValue
       DISPLAY 'DiscountRate: ' DiscountRateP '%   PresValue: ' PresValue
               ' NET-PresValue: ' NET-PresValue
     END-PERFORM
     ACCEPT omitted
     GOBACK.
     

  2. This is a case where passing parameters to the intrinsic function
     PRESENT-VALUE would need the ability to indicate "ALL" and then
     write the statement as:

  3. FUNCTION PRESENT-VALUE (DiscountRate PaymentAmount(ALL) )

  4. GnuCOBOL does not have this feature (ALL parameter) i.,e has NOT
     YET been implemented.


File: gnucobpr.info,  Node: RANDOM,  Next: RANGE,  Prev: PRESENT-VALUE,  Up: Intrinsic Functions

8.1.79 RANDOM
-------------

                        RANDOM Function Syntax
=======================================================================

 RANDOM[(seed)]
 ~~~~~~


=======================================================================
   This function returns a pseudo-random non-integer value in the range
0>= to <1 (for example, 0.123456789).

   The purpose of the optional SEED argument, is to initialize the chain
of pseudo-random numbers that will be returned by the function.  Not
only will calls to this function using the same SEED value return the
same pseudo-random number, but so will all subsequent executions of the
function without a SEED.  This is actually a good thing when you are
testing your program because you can rely on always receiving the same
sequence of "random" numbers if you always start using the same SEED.

   The SEED may be any form of literal or data item or arithmetic
expression.  If SEED is numeric, its numeric value will serve as the
seed value.  If SEED is alphanumeric, a value for it will be determined
as if it were used as an argument to ‘NUMVAL’ (*note NUMVAL::).

   Take, for example, the following sample program:
    IDENTIFICATION DIVISION.
    PROGRAM-ID. DEMORANDOM.
    DATA DIVISION.
    WORKING-STORAGE SECTION.
    01  Pseudo-Random-Number        USAGE COMP-1.
    PROCEDURE DIVISION.
    000-Main.
        MOVE FUNCTION RANDOM(1) TO Pseudo-Random-Number
        DISPLAY Pseudo-Random-Number
        PERFORM 4 TIMES
            MOVE FUNCTION RANDOM    TO Pseudo-Random-Number
            DISPLAY Pseudo-Random-Number
        END-PERFORM
        STOP RUN
        .

   Every time this program is executed, it will produce the same output,
because the same sequence of pseudo-random numbers will be generated:

0.5441364
0.047651578
0.77186662
0.056523036
0.63045478

   Once your program has been thoroughly tested, you'll want different
sequences to be generated each time the program runs.  One possible way
to accomplish this is to use a SEED that is likely to be different every
time the program is executed, as is likely to be the case if the first
‘MOVE’ statement in the previous example were replaced by this:

    MOVE RANDOM(FUNCTION CURRENT-DATE(1:16))
      TO Pseudo-Random-Number

   The first 16 characters returned by the ‘CURRENT-DATE’ (*note
CURRENT-DATE::) function will be a number in the format
‘YYYYMMDDHHMMSSNN’, where ‘YYYYMMDD’ is the current calendar date and
‘HHMMSSNN’ is the current time of day to the one one-hundredth of a
second.  Since two different executions of the program will never get
identical ‘CURRENT-DATE’ values (unless they are executed in extremely
close time frames to one another), using those first sixteen characters
as the ‘RANDOM’ seed will guarantee that receiving a duplicate sequence
of pseudo-random numbers in two different executions of the program will
be highly unlikely.

   If you do not use a seed then the RANDOM function will automatically
determine an internal different seed at each execution.

   Often you need to generate a random number between two numbers.
Following example shows how to do it.


        >>source free
 IDENTIFICATION DIVISION.
 PROGRAM-ID. RANDOM-RANGE.
*> Generate random number from 25 and 70
 DATA DIVISION.
 WORKING-STORAGE SECTION.
 01  RANDOM-NUMBER PIC 9999 value zero.
 PROCEDURE DIVISION.
 perform 10 times
     compute  RANDOM-NUMBER = 25 + (70 - 25) * (FUNCTION RANDOM)
     display  RANDOM-NUMBER
 end-perform
 display      space
*> or, to include the upper value 60 as possible choice
 perform 10 times
     compute  RANDOM-NUMBER = 25 + (70 - 25 + 1) * (FUNCTION RANDOM)
     display  RANDOM-NUMBER
 end-perform
 STOP RUN.



File: gnucobpr.info,  Node: RANGE,  Next: REM,  Prev: RANDOM,  Up: Intrinsic Functions

8.1.80 RANGE
------------

                         RANGE Function Syntax
=======================================================================

 RANGE(number-1 [, number-2 ]...)
 ~~~~~


=======================================================================
   The ‘RANGE’ function returns a value that is equal to the value of
the maximum NUMBER-N in the argument list minus the value of the minimum
NUMBER-N argument.

   All NUMBER-N arguments are numeric data items and/or numeric
literals.


File: gnucobpr.info,  Node: REM,  Next: REVERSE,  Prev: RANGE,  Up: Intrinsic Functions

8.1.81 REM
----------

                          REM Function Syntax
=======================================================================

 REM(number,divisor)
 ~~~


=======================================================================
   This function returns a numeric value that is the remainder of NUMBER
divided by DIVISOR.  Both arguments must be numeric data items or
numeric literals.


File: gnucobpr.info,  Node: REVERSE,  Next: SECONDS-FROM-FORMATTED-TIME,  Prev: REM,  Up: Intrinsic Functions

8.1.82 REVERSE
--------------

                        REVERSE Function Syntax
=======================================================================

 REVERSE(string)
 ~~~~~~~


=======================================================================
   This function returns the byte-by-byte reversed value of STRING (a
group item, ‘USAGE DISPLAY’ elementary item or alphanumeric literal).


File: gnucobpr.info,  Node: SECONDS-FROM-FORMATTED-TIME,  Next: SECONDS-PAST-MIDNIGHT,  Prev: REVERSE,  Up: Intrinsic Functions

8.1.83 SECONDS-FROM-FORMATTED-TIME
----------------------------------

              SECONDS-FROM-FORMATTED-TIME Function Syntax
=======================================================================

 SECONDS-FROM-FORMATTED-TIME(format,time)
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~


=======================================================================
   This function decodes the string TIME -- whose value represents a
formatted time -- and returns the total number of seconds that string
represents.

   The TIME string must contain hours, minutes and seconds.  The time
argument may be specified as a group item, ‘USAGE DISPLAY’ elementary
item or an alphanumeric literal.

   The FORMAT argument is a string (a group item, ‘USAGE DISPLAY’
elementary item or an alphanumeric literal) documenting the format of
TIME using ‘HH’, ‘MM’ and ‘SS’ to denote where the respective time
information can be found.  Any other characters found in FORMAT
represent character positions that will be ignored.  For example, a
format of ‘hhmmss’ indicates that TIME will be treated as a six-digit
string value where the first two characters are the number of hours, the
next two represent minutes and the last two represent seconds.  A FORMAT
of ‘hh:mm:ss’, however, describes TIME as an eight-character string
where characters 3 and 6 will be ignored.


File: gnucobpr.info,  Node: SECONDS-PAST-MIDNIGHT,  Next: SIGN,  Prev: SECONDS-FROM-FORMATTED-TIME,  Up: Intrinsic Functions

8.1.84 SECONDS-PAST-MIDNIGHT
----------------------------

                 SECONDS-PAST-MIDNIGHT Function Syntax
=======================================================================

 SECONDS-PAST-MIDNIGHT
 ~~~~~~~~~~~~~~~~~~~~~


=======================================================================
   This function returns the current time of day expressed as the total
number of elapsed seconds since midnight.

   Since this function has no arguments, no parenthesis should be
specified.


File: gnucobpr.info,  Node: SIGN,  Next: SIN,  Prev: SECONDS-PAST-MIDNIGHT,  Up: Intrinsic Functions

8.1.85 SIGN
-----------

                         SIGN Function Syntax
=======================================================================

 SIGN(number)
 ~~~~


=======================================================================
   The ‘SIGN’ function returns a -1 if the value of NUMBER (a numeric
literal or numeric data item) is negative, a zero if the value of NUMBER
is exactly zero and a 1 if the value of NUMBER if greater than 0.


File: gnucobpr.info,  Node: SIN,  Next: SQRT,  Prev: SIGN,  Up: Intrinsic Functions

8.1.86 SIN
----------

                          SIN Function Syntax
=======================================================================

 SIN(angle)
 ~~~


=======================================================================
   This function determines and returns the trigonometric sine of ANGLE
(a numeric literal or numeric data item).

   The ANGLE is assumed to be a value expressed in radians.  If you need
to determine the sine of an angle measured in degrees, you first need to
convert that angle to radians as follows:

     COMPUTE RADIANS = ( DEGREES * FUNCTION PI) / 180


File: gnucobpr.info,  Node: SQRT,  Next: STANDARD-DEVIATION,  Prev: SIN,  Up: Intrinsic Functions

8.1.87 SQRT
-----------

                         SQRT Function Syntax
=======================================================================

 SQRT (number)
 ~~~~


=======================================================================
   The ‘SQRT’ function returns a numeric value that approximates the
square root of NUMBER (a numeric data item or numeric literal with a
non-negative value).

   The following two statements produce identical results:

     01  Result           PIC 9(4).9(10).
     ...
         MOVE FUNCTION SQRT(15) TO Result
         COMPUTE Result = 15 ** 0.5


File: gnucobpr.info,  Node: STANDARD-DEVIATION,  Next: STORED-CHAR-LENGTH,  Prev: SQRT,  Up: Intrinsic Functions

8.1.88 STANDARD-DEVIATION
-------------------------

                  STANDARD-DEVIATION Function Syntax
=======================================================================

 STANDARD-DEVIATION(number-1 [, number-2 ]...)
 ~~~~~~~~~~~~~~~~~~


=======================================================================
   This function returns the statistical standard deviation of the list
of NUMBER-N arguments (numeric data items or numeric literals).


File: gnucobpr.info,  Node: STORED-CHAR-LENGTH,  Next: SUBSTITUTE,  Prev: STANDARD-DEVIATION,  Up: Intrinsic Functions

8.1.89 STORED-CHAR-LENGTH
-------------------------

                  STORED-CHAR-LENGTH Function Syntax
=======================================================================

 STORED-CHAR-LENGTH(string)
 ~~~~~~~~~~~~~~~~~~


=======================================================================
   Returns the length -- in bytes -- of the specified ‘string’ (a group
item, ‘USAGE DISPLAY’ elementary item or alphanumeric literal), minus
the total number of trailing spaces, if any.


File: gnucobpr.info,  Node: SUBSTITUTE,  Next: SUBSTITUTE-CASE,  Prev: STORED-CHAR-LENGTH,  Up: Intrinsic Functions

8.1.90 SUBSTITUTE
-----------------

                      SUBSTITUTE Function Syntax
=======================================================================

 SUBSTITUTE(string, from-1, to-1 [, from-n, to-n ]...)
 ~~~~~~~~~~


=======================================================================
   This function parses STRING, replacing all occurrences of FROM-N
strings with the corresponding TO-N strings.

   The FROM-N strings must match sequences in STRING exactly with regard
to value and case.

   A FROM-N string does not have to be the same length as its
corresponding TO-N string.

   All arguments are group items, ‘USAGE DISPLAY’ elementary items or
alphanumeric literals.

   A null TO-N string will be treated as a single space.

   When using Variables in place of STRING attention to NOT wanting
Leading or trailing spaces usage of function TRIM needs to be utilised
as failure to do so will result in variables treated with any unwanted
spaces leading and/or trailing, i.e.,

move     function SUBSTITUTE      (WS-Dest-File-Path,
                    function TRIM (WS-Inbound-Path),
                    function TRIM (WS-Desc-Path))
                               to WS-Dest-File-Path


File: gnucobpr.info,  Node: SUBSTITUTE-CASE,  Next: SUM,  Prev: SUBSTITUTE,  Up: Intrinsic Functions

8.1.91 SUBSTITUTE-CASE
----------------------

                    SUBSTITUTE-CASE Function Syntax
=======================================================================

 SUBSTITUTE-CASE(string, from-1, to-1 [, from-n, to-n ]...)
 ~~~~~~~~~~~~~~~


=======================================================================
   The ‘SUBSTITUTE-CASE’ function operates the same as the ‘SUBSTITUTE’
(*note SUBSTITUTE::) function, except that FROM-N string matching is
performed without regard to case.

   All arguments are group items, ‘USAGE DISPLAY’ elementary items or
alphanumeric literals.

   When using Variables in place of STRING attention to NOT wanting
Leading or trailing spaces usage of function TRIM needs to be utilised
as failure to do so will result in variables treated with any unwanted
spaces leading and/or trailing, i.e.,

move     function SUBSTITUTE-CASE (WS-Dest-File-Path,
                    function TRIM (WS-Inbound-Path),
                    function TRIM (WS-Desc-Path))
                               to WS-Dest-File-Path



File: gnucobpr.info,  Node: SUM,  Next: TAN,  Prev: SUBSTITUTE-CASE,  Up: Intrinsic Functions

8.1.92 SUM
----------

                          SUM Function Syntax
=======================================================================

 SUM(number-1 [, number-2 ]...)
 ~~~


=======================================================================
   The ‘SUM’ function returns a value that is the sum of NUMBER-N
arguments (these may be numeric data items or numeric literals).


File: gnucobpr.info,  Node: TAN,  Next: TEST-DATE-YYYYMMDD,  Prev: SUM,  Up: Intrinsic Functions

8.1.93 TAN
----------

                          TAN Function Syntax
=======================================================================

 TAN(angle)
 ~~~


=======================================================================
   This function determines and returns the trigonometric tangent of
ANGLE (a numeric literal or numeric data item).

   The ANGLE is assumed to be a value expressed in radians.  If you need
to determine the tangent of an angle measured in degrees, you first need
to convert that angle to radians as follows:

     COMPUTE RADIANS = ( DEGREES * FUNCTION PI) / 180


File: gnucobpr.info,  Node: TEST-DATE-YYYYMMDD,  Next: TEST-DAY-YYYYDDD,  Prev: TAN,  Up: Intrinsic Functions

8.1.94 TEST-DATE-YYYYMMDD
-------------------------

                  TEST-DATE-YYYYMMDD Function Syntax
=======================================================================

 TEST-DATE-YYYYMMDD (date)
 ~~~~~~~~~~~~~~~~~~


=======================================================================
   This function determines if the supplied DATE argument (a numeric
integer data item or literal) is a valid date.

   A valid date is one of the form yyyymmdd in the range 1601/01/01 to
9999/12/31, with no more than the expected maximum number of days in the
month, accounting for leap year.

   If the DATE is valid, a 0 value is returned.  If it isn't, a value of
1, 2 or 3 is returned signalling the problem lies with the year, month
or day, respectively.


File: gnucobpr.info,  Node: TEST-DAY-YYYYDDD,  Next: TEST-FORMATTED-DATETIME,  Prev: TEST-DATE-YYYYMMDD,  Up: Intrinsic Functions

8.1.95 TEST-DAY-YYYYDDD
-----------------------

                   TEST-DAY-YYYYDDD Function Syntax
=======================================================================

 TEST-DAY-YYYYDDD (date)
 ~~~~~~~~~~~~~~~~


=======================================================================
   This function determines if the supplied DATE (a numeric integer data
item or literal) is a valid date.

   A valid date is one of the form ‘yyyyddd’ in the range 1601001 to
9999365.  Leap year is accounted for in determining the maximum number
of days in a year.

   If the date is valid, a 0 value is returned.  If it isn't, a value of
1 or 2 is returned signalling the problem lies with the year or day,
respectively.


File: gnucobpr.info,  Node: TEST-FORMATTED-DATETIME,  Next: TEST-NUMVAL,  Prev: TEST-DAY-YYYYDDD,  Up: Intrinsic Functions

8.1.96 TEST-FORMATTED-DATETIME
------------------------------

                TEST-FORMATTED-DATETIME Function Syntax
=======================================================================

 TEST-FORMATTED-DATETIME ( argument-1, argument-2 )
 ~~~~~~~~~~~~~~~~~~~~~~~


=======================================================================
   ‘TEST-FORMATTED-DATETIME’ tests whether a date literal representing a
date, a time or a combined date and time is valid according to the
specified format.

   ARGUMENT-1 must a literal of type alphanumeric, UTF-8 or national,
that contains a date, time or combined data time format.  See Date and
Time formats for details.

   ARGUMENT-2 must be a data item of the same type as ARGUMENT-1.

   Returned value:

   If no format or range problems occur during evaluation of ARGUMENT-2
according to the format in ARGUMENT-1, the returned value is zero.
Otherwise the returned value is the ordinal character position at which
the first error in ARGUMENT-2 was detected.

   Example

   Using the following arguments, it will generates a return value of 5,
as the fifth character of argument-2 ("4") contains an incorrect value
for the first digit of the month representation.

   FUNCTION TEST-FORMATTED-DATETIME("YYYYMMDD", "20124523")



File: gnucobpr.info,  Node: TEST-NUMVAL,  Next: TEST-NUMVAL-C,  Prev: TEST-FORMATTED-DATETIME,  Up: Intrinsic Functions

8.1.97 TEST-NUMVAL
------------------

                      TEST-NUMVAL Function Syntax
=======================================================================

 TEST-NUMVAL (string)
 ~~~~~~~~~~~


=======================================================================
   The ‘TEST-NUMVAL’ function evaluates STRING (a group item, ‘USAGE
DISPLAY’ elementary item or alphanumeric literal) for being appropriate
for use as the STRING argument to a ‘NUMVAL’ (*note NUMVAL::) function,
returning to a integer a zero value if it is appropriate otherwise if
one or more characters are in error, the position of the first character
in error or the length of the field plus one for other cases such as all
spaces.

   Note that these errors include but are not limited to: argument
(STRING) is zero length, contains only spaces or contains valid
characters but is incomplete, such as the string ‘+.’.


File: gnucobpr.info,  Node: TEST-NUMVAL-C,  Next: TEST-NUMVAL-F,  Prev: TEST-NUMVAL,  Up: Intrinsic Functions

8.1.98 TEST-NUMVAL-C
--------------------

                     TEST-NUMVAL-C Function Syntax
=======================================================================

 TEST-NUMVAL-C (string[,symbol])
 ~~~~~~~~~~~~~


=======================================================================
   This function evaluates STRING (a group item, ‘USAGE DISPLAY’
elementary item or alphanumeric literal) for being appropriate for use
as the STRING argument to a ‘NUMVAL-C’ (*note NUMVAL-C::) function,
returning to a integer a zero value if it is appropriate otherwise if
one or more characters are in error, the position of the first character
in error or the length of the field plus one for other cases such as all
spaces.

   Note that these errors include but are not limited to: argument
(STRING) is zero length, contains only spaces or contains valid
characters but is incomplete, such as the string ‘+.’.

   The optional SYMBOL argument serves the same function -- and has the
same default and possible values -- as the corresponding argument of the
‘NUMVAL-C’ function.


File: gnucobpr.info,  Node: TEST-NUMVAL-F,  Next: TRIM,  Prev: TEST-NUMVAL-C,  Up: Intrinsic Functions

8.1.99 TEST-NUMVAL-F
--------------------

                     TEST-NUMVAL-F Function Syntax
=======================================================================

 TEST-NUMVAL-F (string)
 ~~~~~~~~~~~~~


=======================================================================
   This function evaluates STRING (a group item, ‘USAGE DISPLAY’
elementary item or alphanumeric literal) for being appropriate for use
as the STRING argument to a ‘NUMVAL-F’ (*note NUMVAL-F::) function,
returning to a integer a zero value if it is appropriate otherwise if
one or more characters are in error, the position of the first character
in error or the length of the field plus one for other cases such as all
spaces.

   Note that these errors include but are not limited to: argument
(string) is zero length, contains only spaces or contains valid
characters but is incomplete, such as the string ‘+.’.


File: gnucobpr.info,  Node: TRIM,  Next: UPPER-CASE,  Prev: TEST-NUMVAL-F,  Up: Intrinsic Functions

8.1.100 TRIM
------------

                         TRIM Function Syntax
=======================================================================

 TRIM(string [, LEADING|TRAILING ])
 ~~~~           ~~~~~~~ ~~~~~~~~


=======================================================================
   This function removes ‘LEADING’ or ‘TRAILING’ spaces from STRING (a
group item, ‘USAGE DISPLAY’ elementary item or alphanumeric literal).

   The second argument is specified as a keyword, not a quoted string or
identifier.  If no second argument is specified, both leading and
trailing spaces will be removed.  The case (upper, lower or mixed) of
this argument is irrelevant.


File: gnucobpr.info,  Node: UPPER-CASE,  Next: VARIANCE,  Prev: TRIM,  Up: Intrinsic Functions

8.1.101 UPPER-CASE
------------------

                      UPPER-CASE Function Syntax
=======================================================================

 UPPER-CASE(string)
 ~~~~~~~~~~


=======================================================================
   This function returns the value of STRING (a group item, ‘USAGE
DISPLAY’ elementary item or alphanumeric literal), converted entirely to
upper case.

   What constitutes a "letter" (or upper/lower case too, for that
manner) may be influenced through the use of a ‘CHARACTER
CLASSIFICATION’ (*note OBJECT-COMPUTER::).


File: gnucobpr.info,  Node: VARIANCE,  Next: WHEN-COMPILED,  Prev: UPPER-CASE,  Up: Intrinsic Functions

8.1.102 VARIANCE
----------------

                       VARIANCE Function Syntax
=======================================================================

 VARIANCE(number-1 [, number-2 ]...)
 ~~~~~~~~


=======================================================================
   This function returns the statistical variance of the specified list
of NUMBER-N arguments (these may be numeric data items or numeric
literals).


File: gnucobpr.info,  Node: WHEN-COMPILED,  Next: YEAR-TO-YYYY,  Prev: VARIANCE,  Up: Intrinsic Functions

8.1.103 WHEN-COMPILED
---------------------

                     WHEN-COMPILED Function Syntax
=======================================================================

 WHEN-COMPILED
 ~~~~~~~~~~~~~


=======================================================================
   The ‘WHEN-COMPILED’ intrinsic function, not to be confused with the
‘WHEN-COMPILED’ (*note Special Registers::) special register, returns
the date and time the program was compiled, in ASCII.

   Since this function has no arguments, no parenthesis should be
specified.

   Unlike the ‘WHEN-COMPILED’ special register, which has an ASCII value
of the compilation date/time in the format ‘mm/dd/yyhh.mm.ss’, the
‘WHEN-COMPILED’ intrinsic function returns the compilation date/time as
an ASCII string in the format ‘yyyymmddhhmmssnnooooo’, where ‘yyyymmdd’
is the date, ‘hhmmss’ is the time, ‘nn’ is the hundredths of a second
component of the compilation time, if available (or ‘00’ if it isn't)
and ‘ooooo’ is the time zone offset from GMT.

   If the ‘-fintrinsics=WHEN-COMPILED’ switch or ‘-fintrinsics=ALL’
switch is specified to the compiler or the ‘REPOSITORY’ (*note
REPOSITORY::) paragraph specifies either ‘FUNCTION WHEN-COMPILED
INTRINSIC’ or ‘FUNCTION ALL INTRINSIC’, then references to
‘WHEN-COMPILED’ (without a leading ‘FUNCTION’ keyword will always
reference this intrinsic function and there will be no way to access the
‘WHEN-COMPILED’ special register.


File: gnucobpr.info,  Node: YEAR-TO-YYYY,  Next: BOOLEAN-OF-INTEGER,  Prev: WHEN-COMPILED,  Up: Intrinsic Functions

8.1.104 YEAR-TO-YYYY
--------------------

                     YEAR-TO-YYYY Function Syntax
=======================================================================

 YEAR-TO-YYYY(yy [, yy-cutoff [, yy-execution-time ]])
 ~~~~~~~~~~~~


=======================================================================
   ‘YEAR-TO-YYYY’ converts YY -- a two-digit year -- to a four-digit
format (‘yyyy’).

   The optional YY-CUTOFF argument is the year cutoff used to delineate
centuries; if YY meets or exceeds this cutoff value, the result will be
19yy; if YY is less than the cutoff, the result will be 20yy.  The
default cutoff value if no second argument is given will be 50.

   The optional YY-EXECUTION-TIME argument (a numeric integer data item
or literal) The default execution time value if no third argument is
given will be now equivalent to specifying (FUNCTION NUMVAL (FUNCTION
CURRENT-DATE (1:4))).

   All arguments must be numeric data items or numeric literals.


File: gnucobpr.info,  Node: BOOLEAN-OF-INTEGER,  Next: CHAR-NATIONAL,  Prev: YEAR-TO-YYYY,  Up: Intrinsic Functions

8.1.105 BOOLEAN-OF-INTEGER
--------------------------

                  BOOLEAN-OF-INTEGER Function Syntax
=======================================================================

 BOOLEAN-OF-INTEGER(argument-1 argument-2)
 ~~~~~~~~~~~~~~~~~~

   This option is not yet implemented.

   The included file NEWS will indicate when it is.

=======================================================================
   ‘BOOLEAN-OF-INTEGER’ returns a boolean item of usage bit representing
the binary value of ARGUMENT-1.  ARGUMENT-2 specifies the length of the
boolean data item that is returned.

   ARGUMENT-1 must be a positive integer.

   ARGUMENT-2 must be a positive non-zero integer

   Returned value is a boolean item of usage bit that has the same bit
configuration as the binary representation of the value of ARGUMENT-1,
where the rightmost boolean position is the low-order binary digit.  The
boolean value is zero-filled or truncated on the left, if necessary, in
order to return a boolean item whose length is specified by ARGUMENT-2
in therms of boolean positions.


File: gnucobpr.info,  Node: CHAR-NATIONAL,  Next: DISPLAY-OF,  Prev: BOOLEAN-OF-INTEGER,  Up: Intrinsic Functions

8.1.106 CHAR-NATIONAL
---------------------

                     CHAR-NATIONAL Function Syntax
=======================================================================

 CHAR-NATIONAL(argument-1)
 ~~~~~~~~~~~~~

   This option is not yet implemented.

   The included file NEWS will indicate when it is.

=======================================================================
   ‘CHAR-NATIONAL’ returns a one character value that is a character in
the national program collating sequence having the ordinal position
equal to the value of the argument.

   ARGUMENT-1 must be a integer and greater than zero and less than or
equal to the number of positions in the national program collating
sequence.


File: gnucobpr.info,  Node: DISPLAY-OF,  Next: EXCEPTION-FILE-N,  Prev: CHAR-NATIONAL,  Up: Intrinsic Functions

8.1.107 DISPLAY-OF
------------------

                      DISPLAY-OF Function Syntax
=======================================================================

 DISPLAY-OF(argument-1 [ argument-2] )
 ~~~~~~~~~~

   This option is not yet implemented.

   The included file NEWS will indicate when it is.

=======================================================================
   ‘DISPLAY-OF’ returns a character string containing the alphabetic
coded character set representation of the national characters in the
argument.

   ARGUMENT-1 must be of class national.

   ARGUMENT-2 must be a of class alphabetic or alphanumeric and is one
character position in length.  It specifies an alphanumeric substitution
character for use in conversion of national characters for which there
is no corresponding alphanumeric character.

   A character string is returned with each national character of
ARGUMENT-1 converted to its corresponding alphanumeric character
representation, if any.

   If ARGUMENT-2 is specified, the alphanumeric substitution character
is returned for each national character in ARGUMENT-1 that has no
corresponding alphanumeric character representation.

   If ARGUMENT-2 is un-specified, and ARGUMENT-1 contains a national
character for which there is no corresponding alphanumeric character
representation, an substitution character is used as the corresponding
alphanumeric character and the EC-DATA-CONVERSION exception condition is
set.

   The length of the returned value is the number of character positions
of usage display required to hold the converted argument and depends on
the number of characters contained in ARGUMENT-1.


File: gnucobpr.info,  Node: EXCEPTION-FILE-N,  Next: EXCEPTION-LOCATION-N,  Prev: DISPLAY-OF,  Up: Intrinsic Functions

8.1.108 EXCEPTION-FILE-N
------------------------

                   EXCEPTION-FILE-N Function Syntax
=======================================================================

 EXCEPTION-FILE-N
 ~~~~~~~~~~~~~~~~

   This option is not yet implemented.

   The included file NEWS will indicate when it is.

=======================================================================
   ‘EXCEPTION-FILE-N’ returns a national character string that is the
I/O status value and file-name of the file connector, if any, associated
with the last exception status.

   The value returned has a length that is based on its contents and the
concents are as follows:

   If the last exception status is not an ‘EC-I-O’ exception condition,
the returned value is two national zeros.

   The returned value is two national spaces when the last exception
status indicates an ‘EC-I-O’ exception condition that originates from
one of the following statements:

   • a ‘RAISE’ statement.

   • an ‘EXIT’ or a ‘GOBACK’ statement with a ‘RAISING’ phrase that
     specifies an ‘EC-I-O’ exception-name.

Otherwise the returned value is a character string that is as long as is
needed to contain the I-O status value and the filename.  The first two
characters are the I-O status value in national characters.  The
succeeding characters contain the file-name exactly as specified in the
‘SELECT’ clause converted at runtime to the runtime national character
set.

   The documentation of the ‘CBL_ERROR_PROC’ built-in system subroutine
(*note CBL_ERROR_PROC::) built-in subroutine illustrates the use of this
function.


File: gnucobpr.info,  Node: EXCEPTION-LOCATION-N,  Next: INTEGER-OF-BOOLEAN,  Prev: EXCEPTION-FILE-N,  Up: Intrinsic Functions

8.1.109 EXCEPTION-LOCATION-N
----------------------------

                 EXCEPTION-LOCATION-N Function Syntax
=======================================================================

 EXCEPTION-LOCATION-N
 ~~~~~~~~~~~~~~~~~~~~

   This option is not yet implemented.

   The included file NEWS will indicate when it is.

=======================================================================
   ‘EXCEPTION-LOCATION-N’ returns an national character string
containing exception information from the most-recently failing
statement.  The information is returned to a 1023 character string in
one of the following formats, depending on the nature of the failure:

   • primary-entry-point-name; paragraph OF section; statement-number

   • primary-entry-point-name; section; statement-number

   • primary-entry-point-name; paragraph; statement-number

   • primary-entry-point-name; statement-number

   Since this function has no arguments, no parenthesis should be
specified.

   The program must be compiled with the ‘-debug’ switch, ‘-ftraceall’
switch or ‘-g’ switch for this function to return any meaningful
information.

   The documentation of the ‘CBL_ERROR_PROC’ built-in system subroutine
(*note CBL_ERROR_PROC::) built-in subroutine illustrates the use of this
function.


File: gnucobpr.info,  Node: INTEGER-OF-BOOLEAN,  Next: NATIONAL-OF,  Prev: EXCEPTION-LOCATION-N,  Up: Intrinsic Functions

8.1.110 INTEGER-OF-BOOLEAN
--------------------------

                  INTEGER-OF-BOOLEAN Function Syntax
=======================================================================

 INTEGER-OF-BOOLEAN(argument-1)
 ~~~~~~~~~~~~~~~~~~

   This option is not yet implemented.

   The included file NEWS will indicate when it is.

=======================================================================
   ‘INTEGER-OF-BOOLEAN’ returns the numeric value of the boolean string
in ARGUMENT-1 which is class boolean.

   Returned value as ARGUMENT-1 is assigned to a temporary boolean data
item of usage bit described with the same number of boolean positions.

   The unsigned binary value represented by the same bit configuration
as the bit configuration of that temporary boolean data item is
determined.

   Note: Binary representation is a mathematical concept.  It is not
required that this representation be the same as a COBOL representation.


File: gnucobpr.info,  Node: NATIONAL-OF,  Next: STANDARD-COMPARE,  Prev: INTEGER-OF-BOOLEAN,  Up: Intrinsic Functions

8.1.111 NATIONAL-OF
-------------------

                      NATIONAL-OF Function Syntax
=======================================================================

NATIONAL-OF(argument-1 [argument-2] )
~~~~~~~~~~~

   This option is not yet implemented.

   The included file NEWS will indicate when it is.

=======================================================================
   ‘NATIONAL-OF’ returns a character string containing the national
character representation of the characters in the argument which must be
of class boolean.

   A character string is returned with each alphanumeric character in
ARGUMENT-1 converted to its corresponding national coded character set
representation.

   If ARGUMENT-2 is specified, each character in ARGUMENT-1 that has no
corresponding national representation is converted to the substitution
character specified by ARGUMENT-2.

   If ARGUMENT-2 is unspecified and ARGUMENT-1 contains an alphanumeric
character for which there is no corresponding national character
representation, a substitution character is used as the corresponding
national character and the ‘EC-DATA-CONVERSION’ exception condition is
set to exist.

   The length of the returned value is the number of character positions
of usage national required to hold the converted argument and depends on
the number of characters contained in ARGUMENT-1.


File: gnucobpr.info,  Node: STANDARD-COMPARE,  Prev: NATIONAL-OF,  Up: Intrinsic Functions

8.1.112 STANDARD-COMPARE
------------------------

                   STANDARD-COMPARE Function Syntax
=======================================================================

STANDARD-COMPARE(argument-1 argument-2 [ordering-name-1] [argument-4] )
~~~~~~~~~~~~~~~~

   This option is not yet implemented.

   The included file NEWS will indicate when it is.

=======================================================================
   ‘STANDARD-COMPARE’ returns a character indicating the result of
comparing ARGUMENT-1 as a alphanumeric and ARGUMENT-2 using a cultural
ordering table.

  1. ARGUMENT-1 shall be of class alphabetic, alphanumeric, or national.

  2. ARGUMENT-2 shall be of class alphabetic, alphanumeric, or national.

  3. ARGUMENT-1 and ARGUMENT-2 may be of different classes.

  4. Neither ARGUMENT-1 nor ARGUMENT-2 shall be a zero-length literal.

  5. ORDERING-NAME-1, if specified, shall be associated with a cultural
     ordering table in the ‘ORDER TABLE’ clause of the ‘SPECIAL-NAMES’
     paragraph.  ORDERING-NAME-1 identifies the ordering table to be
     used for the comparison.  If ORDERING-NAME-1 is not specified, the
     default ordering table 'ISO14651_2010_TABLE1' described in Appendix
     A of ISO/IEC 14651:2011 shall be used.

  6. ARGUMENT-4, if specified, shall be a positive nonzero integer.

Returned values:

  1. If ARGUMENT-4 is unspecified, the highest level defined in the
     ordering table is used for the comparison.

  2. If the cultural ordering table is not available on the processor,
     or the specified ordering level is not available, or the level
     number specified by ARGUMENT-4 is not defined in the ordering
     table, the ‘EC-ORDER-NOT-SUPPORTED’ exception condition is set.

  3. If the arguments are of different classes, and one is national, the
     other argument is converted to class national for purposes of
     comparison.

  4. For purposes of comparison, trailing spaces are truncated from the
     operands except that an operand consisting of all spaces is
     truncated to a single space.

  5. ARGUMENT-1 and ARGUMENT-2 are compared in accordance with the
     ordering table and ordering level being used.

     Note: This comparison is culturally sensitive and the default
     ordering table is acceptable for most cultures.  It is not
     necessarily a character-by-character comparison and not necessarily
     a case-sensitive comparison.  In order to use this function, users
     should understand the types of comparisons specified by ISO/IEC
     14651:2D11 and the ordering tables in use for their installation.

  6. The returned value is:

     ‘=’
          the arguments compare equal,

     ‘-=.:’
          ARGUMENT-1 is less than ARGUMENT-2,

     ‘:>’
          ARGUMENT-1 is greater than ARGUMENT-2.

  7. The length of the returned value is 1.



File: gnucobpr.info,  Node: Built-In System Subroutines,  Prev: Intrinsic Functions,  Up: Functions

8.2 Built-In System Subroutines
===============================

There are a number of built-in system subroutines included with
GnuCOBOL.

   Generally, these routines are intended to match those available in
Micro Focus COBOL, ACUCOBOL and directly for GnuCOBOL.

   It is recommended to change the CBL_OC routines to CBL_GC for forward
compatibility as at some point they will be removed as they are a
hangover from Open Cobol.

   Prefix explanation:

‘C$’
     -> ‘ACU’

‘CBL_’
     -> ‘MF’

‘CBL_GC_’
     (For backwards compatibility some routines are also available as
     ‘CBL_OC_’ as well): but these wonderful extensions are only
     available with GnuCOBOL.

   These routines, all executed via their upper-case names via the
‘CALL’ statement (*note CALL::), are capable of performing the following
functions:

   • Changing the current directory

   • Copying files

   • Creating a directory

   • Creating, Opening, Closing, Reading and Writing byte-stream files

   • Deleting directories (folders)

   • Deleting files

   • Determining how many arguments were passed to a subroutine

   • Getting file information (size and last-modification date/time)

   • Getting the length (in bytes) of an argument passed to a subroutine

   • Justifying a field left-, right- or center-aligned

   • Moving files (a destructive "copy")

   • Putting the program "to sleep", specifying the sleep time in
     seconds

   • Putting the program "to sleep", specifying the sleep time in
     nanoseconds; Caveat: although you'll express the time in
     nanoseconds, Windows systems will only be able to sleep at a
     millisecond granularity

   • Retrieving information about the currently-executing program

   • Submitting a command to the shell environment appropriate for the
     version of GnuCOBOL you are using for execution

   Early versions of Micro Focus COBOL allowed programmers to access
various runtime library routines by using a single two-digit hexadecimal
number as the entry-point name.  These were known as call-by-number
routines.  Over time, Micro Focus COBOL evolved, replacing most of the
call-by-number routines with ones accessible using a more conventional
call-by-name technique.

   Most of the call-by-number routines have evolved into even more
powerful call-by-name routines, many of which are supported by GnuCOBOL.

   Some of the original call-by-number routines never evolved
call-by-name equivalents; GnuCOBOL supports some of these routines.  See
all currently used in Appendix's C and D. (Items marked as **).

   The following sections describe the various built-in subroutines.
All subroutine arguments are mandatory except where explicitly noted to
the contrary.  Any subroutine returning a value to the ‘RETURN-CODE’
special register (*note Special Registers::) could utilize the
‘RETURNING’ clause on the ‘CALL’ statement to return the result back to
the full-word binary data item of your choice.
* Menu:

* C$CALLEDBY.
* C$CHDIR.
* C$COPY.
* C$DELETE.
* C$FILEINFO.
* C$GETPID.
* C$JUSTIFY.
* C$MAKEDIR.
* C$NARG.
* C$PARAMSIZE.
* C$PRINTABLE.
* C$SLEEP.
* C$TOLOWER.
* C$TOUPPER.
* CBL_ALARM_SOUND.**
* CBL_AND.
* CBL_BELL_SOUND.**
* CBL_CHANGE_DIR.
* CBL_CHECK_FILE_EXIST.
* CBL_CLOSE_FILE.
* CBL_COPY_FILE.
* CBL_CREATE_DIR.
* CBL_CREATE_FILE.
* CBL_DELETE_DIR.
* CBL_DELETE_FILE.
* CBL_EQ.
* CBL_ERROR_PROC.
* CBL_EXIT_PROC.
* CBL_FLUSH_FILE.
* CBL_GC_FORK.
* CBL_GC_GETOPT.
* CBL_GC_HOSTED.
* CBL_GC_NANOSLEEP.
* CBL_GC_PRINTABLE.
* CBL_GC_SCR_DUMP.
* CBL_GC_SCR_RESTORE.
* CBL_GC_SET_SCR_SIZE.
* CBL_GC_WAITPID.
* CBL_GET_CSR_POS.
* CBL_GET_CURRENT_DIR.
* CBL_GET_SCR_SIZE.
* CBL_IMP.
* CBL_NIMP.
* CBL_NOR.
* CBL_NOT.
* CBL_OC_GETOPT.
* CBL_OC_HOSTED.
* CBL_OC_NANOSLEEP.
* CBL_OPEN_FILE.
* CBL_OR.
* CBL_READ_FILE.
* CBL_READ_KBD_CHAR.
* CBL_RENAME_FILE.
* CBL_RUNTIME_ERROR.**
* CBL_SET_CSR_POS.
* CBL_TOLOWER.
* CBL_TOUPPER.
* CBL_WRITE_FILE.
* CBL_XOR.
* EXTFH.
* SYSTEM.
* X"91".
* X"E4".
* X"E5".
* X"F4".
* X"F5".


File: gnucobpr.info,  Node: C$CALLEDBY,  Next: C$CHDIR,  Up: Built-In System Subroutines

8.2.1 C$CALLEDBY
----------------

                 C$CALLEDBY Built-In Subroutine Syntax
=======================================================================

 CALL "C$CALLEDBY" USING prog-name-area
 ~~~~              ~~~~~


=======================================================================
   This routine returns the name of the program that called the
currently-executing program.  The program name will be returned,
left-justified and space filled, in PROG-NAME-AREA argument, which
should be a ‘PIC X’ elementary item or a group item.  If PROG-NAME-AREA
is too small to receive the entire program name, the program name value
will be truncated (on the right) to fit.

   The ‘RETURN-CODE’ special register (*note Special Registers::) will
be set to one of the following values:
-1   An error occurred.  The PROG-NAME-AREA contents will be unchanged.
0    The program calling ‘C$CALLEDBY’ was not called by any other
     program (in other words, it is a main program).  The
     PROG-NAME-AREA contents will be set entirely to spaces.
1    The program calling ‘C$CALLEDBY’ was indeed called by another
     program, and that program's name has been saved in PROG-NAME-AREA.


File: gnucobpr.info,  Node: C$CHDIR,  Next: C$COPY,  Prev: C$CALLEDBY,  Up: Built-In System Subroutines

8.2.2 C$CHDIR
-------------

                  C$CHDIR Built-In Subroutine Syntax
=======================================================================

 CALL "C$CHDIR" USING directory-path, result
 ~~~~           ~~~~~


=======================================================================
   This routine makes DIRECTORY-PATH (an alphanumeric literal or
identifier) the current directory.

   The return code of the operation is returned both in the RESULT
argument (any non-edited numeric identifier) as well as in the
‘RETURN-CODE’ special register (*note Special Registers::).  The return
code of the operation will be either 0=Success or 128=failure.

   The directory change remains in effect until the program terminates
(in which the original current directory at the time the program was
started will be automatically restored) or until another ‘C$CHDIR’ or a
‘CBL_CHANGE_DIR’ built-in system subroutine (*note CBL_CHANGE_DIR::) is
executed.


File: gnucobpr.info,  Node: C$COPY,  Next: C$DELETE,  Prev: C$CHDIR,  Up: Built-In System Subroutines

8.2.3 C$COPY
------------

                   C$COPY Built-In Subroutine Syntax
=======================================================================

 CALL "C$COPY" USING src-file-path, dest-file-path, 0
 ~~~~          ~~~~~


=======================================================================
   Use this subroutine to copy file SRC-FILE-PATH to DEST-FILE-PATH as
if it were done via the ‘cp’ (Unix/OSX) or ‘COPY’ (Windows) command.

   Both file path arguments may be alphanumeric literals or identifiers.

   The third argument is required, but is unused.

   If the attempt to copy the file fails (for example, it or the
destination directory doesn't exist), the ‘RETURN-CODE’ special register
(*note Special Registers::) will be set to 128; on successful completion
it will be set to 0.


File: gnucobpr.info,  Node: C$DELETE,  Next: C$FILEINFO,  Prev: C$COPY,  Up: Built-In System Subroutines

8.2.4 C$DELETE
--------------

                  C$DELETE Built-In Subroutine Syntax
=======================================================================

 CALL "C$DELETE" USING file-path, 0
 ~~~~            ~~~~~


=======================================================================
   This routine deletes the file specified by the FILE-PATH argument (an
alphanumeric literal or identifier) just as if that were done using the
‘rm’ (Unix/OSX) or ‘ERASE’ (Windows) command.

   The second argument is required, but is unused.

   If the attempt to delete the file fails (for example, it doesn't
exist), the ‘RETURN-CODE’ special register (*note Special Registers::)
will be set to 128; on successful completion it will be set to 0.


File: gnucobpr.info,  Node: C$FILEINFO,  Next: C$GETPID,  Prev: C$DELETE,  Up: Built-In System Subroutines

8.2.5 C$FILEINFO
----------------

                 C$FILEINFO Built-In Subroutine Syntax
=======================================================================

 CALL "C$FILEINFO" USING file-path, file-info
 ~~~~              ~~~~~


=======================================================================
   With this routine you may retrieve the size of the file specified as
the FILE-PATH argument (an alphanumeric literal or identifier) and the
date/time that file was last modified.  File size information may not be
available in the particular GnuCOBOL build / Operating System
combination you are using and may therefore always be returned as zero.
The information is returned to the FILE-INFO argument, which is defined
as the following 16-byte area:

     01  File-Info.
         05 File-Size-In-Bytes  PIC 9(18) COMP.
         05 Mod-YYYYMMDD        PIC 9(8)  COMP. *> Modification Date
         05 Mod-HHMMSS00        PIC 9(8)  COMP. *> Modification Time

   The last two decimal digits in the modification time will always be
00.

   If the subroutine is successful, a value of 0 will be returned in the
‘RETURN-CODE’ special register (*note Special Registers::).  Failure to
retrieve the needed statistics on the file will cause a ‘RETURN-CODE’
special register value of 35 to be passed back.  Supplying less than two
arguments will generate a 128 ‘RETURN-CODE’ special register value.


File: gnucobpr.info,  Node: C$GETPID,  Next: C$JUSTIFY,  Prev: C$FILEINFO,  Up: Built-In System Subroutines

8.2.6 C$GETPID
--------------

                  C$GETPID Built-In Subroutine Syntax
=======================================================================

 CALL "C$GETPID"
 ~~~~


=======================================================================
   Use this subroutine to return the PID (process ID) of the executing
GnuCOBOL program.  The PID value is returned into the ‘RETURN-CODE’
special register (*note Special Registers::).

   There are no arguments to this routine.


File: gnucobpr.info,  Node: C$JUSTIFY,  Next: C$MAKEDIR,  Prev: C$GETPID,  Up: Built-In System Subroutines

8.2.7 C$JUSTIFY
---------------

                 C$JUSTIFY Built-In Subroutine Syntax
=======================================================================

 CALL "C$JUSTIFY" USING data-item, "justification-type"
 ~~~~             ~~~~~


=======================================================================
   Use ‘C$JUSTIFY’ to left, right or center-justify an alphabetic,
alphanumeric or numeric edited data-item.  The optional
JUSTIFICATION-TYPE argument indicates the type of the justification to
be performed.  Its value is interpreted as follows:
‘C’
     the value will be centered

‘R’
     the value will be right-justified, space-filled to the left

‘L’
     the value will be left-justified, space-filled to the right

If it begins with anything else, or is absent, it will be treated as if
it is present and begins with a capital ‘R’


File: gnucobpr.info,  Node: C$MAKEDIR,  Next: C$NARG,  Prev: C$JUSTIFY,  Up: Built-In System Subroutines

8.2.8 C$MAKEDIR
---------------

                 C$MAKEDIR Built-In Subroutine Syntax
=======================================================================

 CALL "C$MAKEDIR" USING dir-path
 ~~~~             ~~~~~


=======================================================================
   With this routine you may create a new directory -- the name of which
is supplied as the DIR-PATH argument (an alphanumeric literal or
identifier).

   Only the lowest-level directory (last) in the specified path can be
created -- all others must already exist.  This subroutine will not
behave as a ‘mkdir -p’ (Unix) or ‘mkdir /p’ (Windows).

   The ‘RETURN-CODE’ special register (*note Special Registers::) will
be set to the return code of the operation; the value will be either
0=Success or 128=failure.


File: gnucobpr.info,  Node: C$NARG,  Next: C$PARAMSIZE,  Prev: C$MAKEDIR,  Up: Built-In System Subroutines

8.2.9 C$NARG
------------

                   C$NARG Built-In Subroutine Syntax
=======================================================================

 CALL "C$NARG" USING arg-count-result
 ~~~~          ~~~~~


=======================================================================
   This subroutine returns the number of arguments passed to the program
that calls it back to in the numeric field ARG-COUNT-RESULT.  When
called from within a user-defined function, a value of one (1) is
returned if any arguments were passed to the function or a zero (0)
otherwise.

   When called from a main program, the returned value will always be 0.


File: gnucobpr.info,  Node: C$PARAMSIZE,  Next: C$PRINTABLE,  Prev: C$NARG,  Up: Built-In System Subroutines

8.2.10 C$PARAMSIZE
------------------

                C$PARAMSIZE Built-In Subroutine Syntax
=======================================================================

 CALL "C$PARAMSIZE" USING argument-number
 ~~~~               ~~~~~


=======================================================================
   This subroutine returns the size (in bytes) of the subroutine
argument supplied using the ARGUMENT-NUMBER parameter (a numeric literal
or data item).

   The size is returned in the ‘RETURN-CODE’ special register (*note
Special Registers::).

   If the specified argument does not exist, or an invalid argument
number is specified, a value of 0 is returned.


File: gnucobpr.info,  Node: C$PRINTABLE,  Next: C$SLEEP,  Prev: C$PARAMSIZE,  Up: Built-In System Subroutines

8.2.11 C$PRINTABLE
------------------

                C$PRINTABLE Built-In Subroutine Syntax
=======================================================================

 CALL "C$PRINTABLE" USING data-item [ , char ]
 ~~~~               ~~~~~


=======================================================================
   The ‘C$PRINTABLE’ subroutine converts the contents of the data-item
specified as the first argument to printable characters.  Those
characters that are deemed printable (as defined by the character set
used by DATA-ITEM) will remain unchanged, while those that are NOT
printable will be converted to the character specified as the second
argument.

   If no CHAR argument is provided, a period (‘.’) will be used.

   Note: CBL_GC_PRINTABLE replaces this although it is currently still
supported for legacy reasons.


File: gnucobpr.info,  Node: C$SLEEP,  Next: C$TOLOWER,  Prev: C$PRINTABLE,  Up: Built-In System Subroutines

8.2.12 C$SLEEP
--------------

                  C$SLEEP Built-In Subroutine Syntax
=======================================================================

 CALL "C$SLEEP" USING seconds-to-sleep
 ~~~~           ~~~~~


=======================================================================
   ‘C$SLEEP’ puts the program to sleep for the specified number of
seconds and/or fractions of a second.  The SECONDS-TO-SLEEP argument may
be a numeric literal or data item.

   Sleep times less than 1 will be interpreted as 0, subject to the
speed of the CPU and the O/S (Operating System) used, as well as the
timing of the generated C code, which will immediately returns control
to the calling program without any sleep delay.

   When using a variable argument defined as 9(n)v9(m) where n is
maximum seconds in 7 days, i.e., (60 x 60 x 24 x 7) = 604,800 (seconds)
and m is at a point too fast for the CPU and O/S. In practice m should
be 2 for a hundredth of a second but actual testing against the target
CPU would be needed.

   The maximum time can be adjusted by the define MAX_SLEEP_TIME during
compilation of the compiler [and no I do not know where it is in the
codebase] e.g.:

/* maximum sleep time in seconds, currently 7 days */
#define MAX_SLEEP_TIME 3600*24*7

Extract from a working program :-

This routine completes a process on newly arrived files at 30 minutes past each hour
When complete sleeps for 60 minutes - time past nn:30:..

*>  In WS ---
*> Computed last finished, based on Sleep secs
*>    changes depend on UPDATE run & finished time.
*>
 01  WS-Cycle-Process-Data.
     03  WS-Sleep-Minutes    pic 9(5)        value 60.   *>Default 60 = 1 hour
     03  WS-Sleep-Seconds    pic 9(5)        value zeros.
     03  WS-Cycle-Start      pic 99          value 30.  *> time to run past the hour
     03  WS-Cycle-Secs       pic s9(6)       value zeros.
     03  WS-Tmp-Secs1        pic s9(6)       value zero.
     03  WS-Rerun-Cycles-No  pic s999        value -1.
     03  WS-Tmp-Sleep        pic 9(6)        value zero.
*>
 01  Current-Date-And-Time.
     03  CDT-DateTime.                        *> 16
         05  CDT-Year        pic 9(4).
         05  CDT-Month       pic 9(2). *> 01-12
         05  CDT-Day         pic 9(2). *> 01-31
         05  CDT-Hour        pic 9(2). *> 00-23
         05  CDT-Minutes     pic 9(2). *> 00-59
         05  CDT-Seconds     pic 9(2). *> 00-59
         05  CDT-Huns-Of-Secs pic 9(2). *> 00-99
     03  filler redefines CDT-DateTime.
         05  CDT-DDT         pic 9(8).
         05  filler          pic x(8).
     03  filler.
         05 CDT-GMT-Diff-HH  pic S9(2)  sign leading separate.
         05 CDT-GMT-Diff-MMM pic 9(2). *> 00 or 30

In PD ---

*>
*> Now if set to sleep do so,
*>  for normal processing multi (24) times per day
*>
*> First use minutes & at end convert to secs
*>
              move     FUNCTION Current-Date to Current-Date-And-Time
              compute  WS-Tmp-Secs1 = WS-Cycle-Secs - ((CDT-Minutes * 60) + CDT-Seconds)
              if       WS-Tmp-Secs1 is negative
                   or  WS-Tmp-Secs1 = zero
                       add       WS-Sleep-Seconds to WS-Tmp-Secs1
              end-if
              move     WS-Tmp-Secs1 to WS-Tmp-Sleep
*>
              move     spaces to Log-Msg
              string   "Time Now "
                       CDT-Hour
                       ":"
                       CDT-Minutes
                       ":"
                       CDT-Seconds
                       space
                       "Sleep time "
                       WS-Tmp-Sleep
                                     into Log-Msg
              display  FUNCTION TRIM (Log-Msg) at 1601 with erase eol
  *> Code skipped
*>
*> Allow ESCape to terminate after NEXT update cycle but time will be out 1 sec
*>
              accept   Accept-Reply at line WS-Lines col 42 TIME-OUT 1
              if       Cob-Crt-Status = Cob-Scr-Esc
                       go to AA040-EOJ
              end-if
              call     "C$SLEEP" using WS-Tmp-Sleep
              go to    AA032-Test-Update
     end-if



File: gnucobpr.info,  Node: C$TOLOWER,  Next: C$TOUPPER,  Prev: C$SLEEP,  Up: Built-In System Subroutines

8.2.13 C$TOLOWER
----------------

                 C$TOLOWER Built-In Subroutine Syntax
=======================================================================

 CALL "C$TOLOWER" USING data-item, BY VALUE convert-length
 ~~~~             ~~~~~               ~~~~~


=======================================================================
   This routine will converts the CONVERT-LENGTH (a numeric literal or
data item) leading characters of DATA-ITEM (an alphanumeric identifier)
to lower-case.

   The CONVERT-LENGTH argument must be specified ‘BY VALUE’ (*note
CALL::).  Any characters in DATA-ITEM after the CONVERT-LENGTH point
will remain unchanged.

   If CONVERT-LENGTH is negative or zero, no conversion will be
performed.


File: gnucobpr.info,  Node: C$TOUPPER,  Next: CBL_ALARM_SOUND,  Prev: C$TOLOWER,  Up: Built-In System Subroutines

8.2.14 C$TOUPPER
----------------

                 C$TOUPPER Built-In Subroutine Syntax
=======================================================================

 CALL "C$TOUPPER" USING data-item, BY VALUE convert-length
 ~~~~             ~~~~~               ~~~~~


=======================================================================
   This routine will converts the CONVERT-LENGTH (a numeric literal or
data item) leading characters of DATA-ITEM (an alphanumeric identifier)
to upper-case.

   The CONVERT-LENGTH argument must be specified ‘BY VALUE’ (*note
CALL::).  Any characters in DATA-ITEM after the CONVERT-LENGTH point
will remain unchanged.

   If CONVERT-LENGTH is negative or zero, no conversion will be
performed.


File: gnucobpr.info,  Node: CBL_ALARM_SOUND,  Next: CBL_AND,  Prev: C$TOUPPER,  Up: Built-In System Subroutines

8.2.15 CBL_ALARM_SOUND
----------------------

              CBL_ALARM_SOUND Built-In Subroutine Syntax
=======================================================================

CALL "CBL_ALARM_SOUND" USING  ???
~~~~                   ~~~~~

??? More information needed from compiler developers. ???


=======================================================================
   This routine will create a noise (a beep) using the internal speaker
if present.  [ Place Holder ].



File: gnucobpr.info,  Node: CBL_AND,  Next: CBL_BELL_SOUND,  Prev: CBL_ALARM_SOUND,  Up: Built-In System Subroutines

8.2.16 CBL_AND
--------------

                  CBL_AND Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_AND" USING item-1, item-2, BY VALUE byte-length
 ~~~~           ~~~~~                    ~~~~~


=======================================================================
 Old    Old    New     This subroutine performs a bit-by-bit logical
Arg 1  Arg 2  Arg 2    ‘AND’ operation between the left-most
 Bit    Bit    Bit     8*BYTE-LENGTH corresponding bits of ITEM-1 and
=====  =====  =====    ITEM-2, storing the resulting bit string into
  0      0      0      ITEM-2.  The truth table shown to the left
  0      1      0      documents the ‘AND’ process.
  1      0      0      
  1      1      1      The ITEM-1 argument may be an alphanumeric
                       literal or a data item and ITEM-2 must be a data
                       item.  The length of both ITEM-1 and ITEM-2 must
                       be at least 8*BYTE-LENGTH.

   The BYTE-LENGTH argument may be a numeric literal or data item, and
must be specified using ‘BY VALUE’ (*note CALL::).

   Any bits in ITEM-2 after the 8*BYTE-LENGTH point will be unaffected.

   A result of zero will be passed back in the ‘RETURN-CODE’ special
register (*note Special Registers::).



File: gnucobpr.info,  Node: CBL_BELL_SOUND,  Next: CBL_CHANGE_DIR,  Prev: CBL_AND,  Up: Built-In System Subroutines

8.2.17 CBL_BELL_SOUND
---------------------

               CBL_BELL_SOUND Built-In Subroutine Syntax
=======================================================================

CALL "CBL_BELL_SOUND" USING  ???
~~~~                  ~~~~~

??? More information needed from compiler developers. ???


=======================================================================
   This routine will create a noise (a beep) using the internal speaker
if present.  [ Place Holder ].  Works the same as function
CBL_ALARM_SOUND, so there.



File: gnucobpr.info,  Node: CBL_CHANGE_DIR,  Next: CBL_CHECK_FILE_EXIST,  Prev: CBL_BELL_SOUND,  Up: Built-In System Subroutines

8.2.18 CBL_CHANGE_DIR
---------------------

               CBL_CHANGE_DIR Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_CHANGE_DIR" USING directory-path
 ~~~~                  ~~~~~


=======================================================================
   This routine makes DIRECTORY-PATH (an alphanumeric literal or
identifier) the current directory.

   The return code of the operation, which will be either 0=Success or
128=failure, is returned in the ‘RETURN-CODE’ special register (*note
Special Registers::).

   The directory change remains in effect until the program terminates
(in which the original current directory at the time the program was
started will be automatically restored) or until another
‘CBL_CHANGE_DIR’ or a ‘C$CHDIR’ built-in system subroutine (*note
C$CHDIR::) is executed.


File: gnucobpr.info,  Node: CBL_CHECK_FILE_EXIST,  Next: CBL_CLOSE_FILE,  Prev: CBL_CHANGE_DIR,  Up: Built-In System Subroutines

8.2.19 CBL_CHECK_FILE_EXIST
---------------------------

            CBL_CHECK_FILE_EXIST Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_CHECK_FILE_EXIST" USING file-path, file-info
 ~~~~                        ~~~~~


=======================================================================
   With this routine you may retrieve the size of the file specified as
the FILE-PATH argument (an alphanumeric literal or identifier) and the
date/time that file was last modified.  File size information may not be
available in the particular GnuCOBOL build / Operating System
combination you are using and may therefore always be returned as zero.

   The information is returned to the FILE-INFO argument, which is
defined as the following 16-byte area:

     01  file-info.
         05 File-Size-In-Bytes  PIC 9(18)  COMP.
         05 Mod-DD              PIC 9(2)   COMP.  *> Modification Date
         05 Mod-MO              PIC 9(2)   COMP.
         05 Mod-YYYY            PIC 9(4)   COMP.
         05 Mod-HH              PIC 9(2)   COMP.  *> Modification Time
         05 Mod-MM              PIC 9(2)   COMP.
         05 Mod-SS              PIC 9(2)   COMP.
         05 FILLER              PIC 9(2)   COMP.  *> Always 00

   If the subroutine is successful, a value of 0 will be returned in the
‘RETURN-CODE’ special register (*note Special Registers::).  Failure to
retrieve the needed statistics on the file will cause a ‘RETURN-CODE’
special register value of 35 to be passed back.  Supplying less than two
arguments will generate a 128 ‘RETURN-CODE’ special register value.


File: gnucobpr.info,  Node: CBL_CLOSE_FILE,  Next: CBL_COPY_FILE,  Prev: CBL_CHECK_FILE_EXIST,  Up: Built-In System Subroutines

8.2.20 CBL_CLOSE_FILE
---------------------

               CBL_CLOSE_FILE Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_CLOSE_FILE" USING file-handle
 ~~~~                  ~~~~~


=======================================================================
   The ‘CBL_CLOSE_FILE’ subroutine closes a byte stream file previously
opened by either the ‘CBL_OPEN_FILE’ built-in system subroutine (*note
CBL_OPEN_FILE::) or ‘CBL_CREATE_FILE’ built-in system subroutine (*note
CBL_CREATE_FILE::) subroutines.

   If the file defined by the FILE-HANDLE argument (a ‘PIC X(4) USAGE
COMP-X’ data item) was opened for output, an implicit ‘CBL_FLUSH_FILE’
built-in system subroutine (*note CBL_FLUSH_FILE::) will be performed
before the file is closed.

   If the subroutine is successful, a value of 0 will be returned in the
‘RETURN-CODE’ special register (*note Special Registers::).  Failure
will cause a ‘RETURN-CODE’ special register value of -1 to be passed
back.

   An example of the use of OPEN, CLOSE, READ etc., can be found in
Contribs program printcbl.cbl which is basically also in cobxref.cbl as
program 3.


File: gnucobpr.info,  Node: CBL_COPY_FILE,  Next: CBL_CREATE_DIR,  Prev: CBL_CLOSE_FILE,  Up: Built-In System Subroutines

8.2.21 CBL_COPY_FILE
--------------------

               CBL_COPY_FILE Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_COPY_FILE" USING src-file-path, dest-file-path
 ~~~~                 ~~~~~


=======================================================================
   Use this subroutine to copy file SRC-FILE-PATH to DEST-FILE-PATH as
if it were done via the ‘cp’ (Unix/OSX) or ‘COPY’ (Windows) command.

   Both arguments may be alphanumeric literals or identifiers.

   If the attempt to copy the file fails (for example, it or the
destination directory doesn't exist), the ‘RETURN-CODE’ special register
(*note Special Registers::) will be set to 128; on successful completion
it will be set to 0.


File: gnucobpr.info,  Node: CBL_CREATE_DIR,  Next: CBL_CREATE_FILE,  Prev: CBL_COPY_FILE,  Up: Built-In System Subroutines

8.2.22 CBL_CREATE_DIR
---------------------

               CBL_CREATE_DIR Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_CREATE_DIR" USING dir-path
 ~~~~                  ~~~~~


=======================================================================
   With this routine you may create a new directory -- the name of which
is supplied as the DIR-PATH argument (an alphanumeric literal or
identifier).

   Only the lowest-level directory (last) in the specified path can be
created -- all others must already exist.  This subroutine will not
behave as a ‘mkdir -p’ (Unix) or ‘mkdir /p’ (Windows).

   The ‘RETURN-CODE’ special register (*note Special Registers::) will
be set to the return code of the operation; the value will be either
0=Success or 128=failure.


File: gnucobpr.info,  Node: CBL_CREATE_FILE,  Next: CBL_DELETE_DIR,  Prev: CBL_CREATE_DIR,  Up: Built-In System Subroutines

8.2.23 CBL_CREATE_FILE
----------------------

              CBL_CREATE_FILE Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_CREATE_FILE" USING file-path, 2, 0, 0, file-handle
 ~~~~                   ~~~~~


=======================================================================
   The ‘CBL_CREATE_FILE’ subroutine creates the new file specified using
the file-path argument and opens it for output as a byte-stream file
usable by ‘CBL_WRITE_FILE’ built-in system subroutine (*note
CBL_WRITE_FILE::).

   Arguments 2, 3 and 4 should be coded as the constant values shown.
‘CBL_CREATE_FILE’ is actually a special-case of the ‘CBL_OPEN_FILE’
built-in system subroutine (*note CBL_OPEN_FILE::) routine -- see that
routine for a description of the meanings of arguments 2, 3 and 4.

   A FILE-HANDLE (‘PIC X(4) USAGE COMP-X)’ will be returned, for use on
any subsequent ‘CBL_WRITE_FILE’ built-in system subroutine (*note
CBL_WRITE_FILE::) or ‘CBL_CLOSE_FILE’ built-in system subroutine (*note
CBL_CLOSE_FILE::) calls.

   The success or failure of the subroutine will be reported back in the
‘RETURN-CODE’ special register (*note Special Registers::), with a value
of -1 indicating an invalid argument and a value of 0 indicating
success.


File: gnucobpr.info,  Node: CBL_DELETE_DIR,  Next: CBL_DELETE_FILE,  Prev: CBL_CREATE_FILE,  Up: Built-In System Subroutines

8.2.24 CBL_DELETE_DIR
---------------------

               CBL_DELETE_DIR Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_DELETE_DIR" USING dir-path
 ~~~~                  ~~~~~


=======================================================================
   This subroutine deletes an empty directory.

   The only argument -- DIR-PATH (an alphanumeric literal or identifier)
-- is the name of the directory to be deleted.

   Only the lowest-level directory (last) in the specified path will be
deleted, and that directory must be empty to be deleted.

   The ‘RETURN-CODE’ special register (*note Special Registers::) will
be set to the return code of the operation; the value will be either
0=Success or 128=failure.


File: gnucobpr.info,  Node: CBL_DELETE_FILE,  Next: CBL_EQ,  Prev: CBL_DELETE_DIR,  Up: Built-In System Subroutines

8.2.25 CBL_DELETE_FILE
----------------------

              CBL_DELETE_FILE Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_DELETE_FILE" USING file-path
 ~~~~                   ~~~~~


=======================================================================
   This routine deletes the file specified by the FILE-PATH argument (an
alphanumeric literal or identifier) just as if that were done using the
‘rm’ (Unix/OSX) or ‘ERASE’ (Windows) command.

   If the attempt to delete the file fails (for example, it doesn't
exist), the ‘RETURN-CODE’ special register (*note Special Registers::)
will be set to 128; on successful completion it will be set to 0.


File: gnucobpr.info,  Node: CBL_EQ,  Next: CBL_ERROR_PROC,  Prev: CBL_DELETE_FILE,  Up: Built-In System Subroutines

8.2.26 CBL_EQ
-------------

                   CBL_EQ Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_EQ" USING item-1, item-2, BY VALUE byte-length
 ~~~~          ~~~~~                    ~~~~~


=======================================================================
 Old    Old    New     This subroutine performs a bit-by-bit comparison
Arg 1  Arg 2  Arg 2    between the left-most 8*BYTE-LENGTH
 Bit    Bit    Bit     corresponding bits of ITEM-1 and ITEM-2, storing
=====  =====  =====    the resulting bit string into ITEM-2.  The truth
  0      0      1      table shown to the left documents the EQ
  0      1      0      process.
  1      0      0      
  1      1      1      The ITEM-1 argument may be an alphanumeric
                       literal or a data item and ITEM-2 must be a data
                       item.  The length of both ITEM-1 and ITEM-2 must
                       be at least 8*BYTE-LENGTH.

   The BYTE-LENGTH argument may be a numeric literal or data item, and
must be specified using ‘BY VALUE’ (*note CALL::).

   Any bits in ITEM-2 after the 8*BYTE-LENGTH point will be unaffected.

   A result of zero will be passed back in the ‘RETURN-CODE’ special
register (*note Special Registers::).


File: gnucobpr.info,  Node: CBL_ERROR_PROC,  Next: CBL_EXIT_PROC,  Prev: CBL_EQ,  Up: Built-In System Subroutines

8.2.27 CBL_ERROR_PROC
---------------------

               CBL_ERROR_PROC Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_ERROR_PROC" USING function, program-pointer
 ~~~~                  ~~~~~


=======================================================================
   This routine registers a general error-handling routine.

   The FUNCTION argument must be a numeric literal or a 32-bit binary
data item (‘USAGE BINARY-LONG’, for example) with a value of 0 or 1.  A
value of 0 means that you will be registering ("installing") an error
procedure while a value of 1 indicates you're de-registering
("uninstalling") a previously-installed error procedure.

   The PROGRAM-POINTER must be a data item with a ‘USAGE’ (*note
USAGE::) of ‘PROGRAM-POINTER’ containing the address of your error
procedure.  This item should be given a value using the ‘SET
Program-Pointer’ statement (*note SET Program-Pointer::).  If the error
procedure is written in GnuCOBOL, it must be a subroutine, not a
user-defined function.

   A success (0) or failure (non-0) result will be passed back in the
‘RETURN-CODE’ special register (*note Special Registers::).

   A custom error procedure will trigger when a runtime error condition
is encountered.  An error procedure may be registered by a main program
or a subprogram, but regardless of from where it was registered, it
applies to the overall program compilation group and will trigger when a
runtime error occurs anywhere in the executable program.  If the error
procedure was defined by a subprogram, that program must be loaded at
the time the error procedure is executed.

   An error procedure may be used to take whatever actions might be
warranted to display additional information or to gracefully close down
work in progress, but it cannot prevent the termination of program
execution; should the error procedure not issue its own ‘STOP RUN’,
control will return back to the standard error routine when the error
procedure exits.

   The code within the handler will be executed and -- once the handler
issues a ‘return’, if it was written in C, or an ‘EXIT PROGRAM’
statement (*note EXIT::) or ‘GOBACK’ statement, if it was written in
GnuCOBOL, the system-standard error handling routine will be executed.

   Only one user-defined error procedure may be in effect at any time.

   The following is a sample GnuCOBOL program that registers an error
procedure.  The output of that program is shown as well.  As as you can
see, the error handler's messages appear followed by the standard
GnuCOBOL message.

     1.     IDENTIFICATION DIVISION.
     2.     PROGRAM-ID. DemoERRPROC.
     3.     ENVIRONMENT DIVISION.
     4.     DATA DIVISION.
     5.     WORKING-STORAGE SECTION.
     6.     01  Err-Proc-Address            USAGE PROGRAM-POINTER.
     7.     PROCEDURE DIVISION.
     8.     S1.
     9.         DISPLAY 'Program is starting'
     10.        SET Err-Proc-Address TO ENTRY 'ErrProc'
     11.        CALL 'CBL_ERROR_PROC' USING 0, Err-Proc-Address
     12.        CALL 'Tilt' *> THIS DOESN'T EXIST!!!!
     13.        DISPLAY 'Program is stopping'
     14.        STOP RUN
     15.        .
     16.    END PROGRAM DemoERRPROC.
     17.
     18.    IDENTIFICATION DIVISION.
     19.    PROGRAM-ID. ErrProc.
     20.    PROCEDURE DIVISION.
     21.    000-Main.
     22.        DISPLAY 'Error: ' FUNCTION EXCEPTION-LOCATION
     23.        DISPLAY '       ' FUNCTION EXCEPTION-STATEMENT
     24.        DISPLAY '       ' FUNCTION EXCEPTION-FILE
     25.        DISPLAY '       ' FUNCTION EXCEPTION-STATUS
     26.        DISPLAY '*** Returning to Standard Error Routine ***'
     27.        EXIT PROGRAM
     28.        .
     29.    END PROGRAM ErrProc.

   When executed, this sample program generates the following console
output.

     E:\Programs\Demos>demoerrproc
     Program is starting
     Error: DemoERRPROC; S1; 12
            CALL
            00
            EC-PROGRAM-NOT-FOUND
     *** Returning to Standard Error Routine ***
     DEMOERRPROC.cbl: 27: libcob: Cannot find module 'Tilt'

     E:\Programs\Demos>



File: gnucobpr.info,  Node: CBL_EXIT_PROC,  Next: CBL_FLUSH_FILE,  Prev: CBL_ERROR_PROC,  Up: Built-In System Subroutines

8.2.28 CBL_EXIT_PROC
--------------------

               CBL_EXIT_PROC Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_EXIT_PROC" USING function, program-pointer
 ~~~~                 ~~~~~


=======================================================================
   This routine registers a general exit-handling routine.

   The FUNCTION argument must be a numeric literal or a 32-bit binary
data item (‘USAGE BINARY-LONG’, for example) with a value of 0 or 1.  A
value of 0 means that you will be registering ("installing") an exit
procedure while a value of 1 indicates you're deregistering
("uninstalling") a previously-installed exit procedure.

   The PROGRAM-POINTER must be a data item with a ‘USAGE’ (*note
USAGE::) of ‘PROGRAM-POINTER’ containing the address of your exit
procedure.

   A success (0) or failure (non-0) result will be passed back in the
‘RETURN-CODE’ special register (*note Special Registers::).

   An exit procedure, once registered, will trigger whenever a ‘STOP
RUN’ statement (*note STOP::) or a ‘GOBACK’ statement (*note GOBACK::)
is executed anywhere in the program.  The exit procedure may execute
whatever code is desired to undertake an orderly shut down of the
program.  Once the exit procedure terminates by executing an ‘EXIT
PROGRAM’ statement (*note EXIT::) or a ‘GOBACK’ statement, the
system-standard program termination routine will be executed.

   Only one user-defined exit procedure may be in effect at any time.

   The following is a sample GnuCOBOL program that registers an exit
procedure.  The output of that program is shown as well.

     IDENTIFICATION DIVISION.
     PROGRAM-ID. demoexitproc.
     DATA DIVISION.
     WORKING-STORAGE SECTION.
     01  Exit-Proc-Address           USAGE PROGRAM-POINTER.
     PROCEDURE DIVISION.
     000-Register-Exit-Proc.
         SET Exit-Proc-Address TO ENTRY "ExitProc"
         CALL "CBL_EXIT_PROC" USING 0, Exit-Proc-Address
         IF RETURN-CODE NOT = 0
             DISPLAY 'Error: Could not register Exit Procedure'
         END-IF
         .
     099-Now-Test-Exit-Proc.
         DISPLAY
             'Executing a STOP RUN...'
         END-DISPLAY
         GOBACK.
     END PROGRAM demoexitproc.

     IDENTIFICATION DIVISION.
     PROGRAM-ID. ExitProc.
     DATA DIVISION.
     WORKING-STORAGE SECTION.
     01  Display-Date                PIC XXXX/XX/XX.
     01  Display-Time                PIC XX/XX/XX.
     01  Now                         PIC X(8).
     01  Today                       PIC X(8).
     PROCEDURE DIVISION.
     000-Main.
         DISPLAY '*** STOP RUN has been executed ***'
         ACCEPT Today FROM DATE YYYYMMDD
         ACCEPT Now   FROM TIME
         MOVE Today TO Display-Date
         MOVE Now   TO Display-Time
         INSPECT Display-Time REPLACING ALL '/' BY ':'
         DISPLAY '***    ' Display-Date '  ' Display-Time '    ***'
         GOBACK.
     END PROGRAM ExitProc.



File: gnucobpr.info,  Node: CBL_FLUSH_FILE,  Next: CBL_GC_FORK,  Prev: CBL_EXIT_PROC,  Up: Built-In System Subroutines

8.2.29 CBL_FLUSH_FILE
---------------------

               CBL_FLUSH_FILE Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_FLUSH_FILE" USING file-handle
 ~~~~                  ~~~~~


=======================================================================
   In Micro Focus COBOL, calling this subroutine flushes any as-yet
unwritten buffers for the (output) file whose file-handle is specified
as the argument to disk.

   This routine is non-functional in GnuCOBOL. It exists only to provide
compatibility for applications that may have been developed for Micro
Focus COBOL.


File: gnucobpr.info,  Node: CBL_GC_FORK,  Next: CBL_GC_GETOPT,  Prev: CBL_FLUSH_FILE,  Up: Built-In System Subroutines

8.2.30 CBL_GC_FORK
------------------

                 CBL_GC_FORK Built-In Subroute Syntax
=======================================================================

 CALL "CBL_GC_FORK" USING Child-PID
 ~~~~               ~~~~~


=======================================================================
   CBL_GC_FORK allows you to fork the current COBOL process to a new
one.

   The current content of the process's storage (including
LOCAL-STORAGE) will be identical, any file handles get invalid in the
new process, positions and file and record locks are only available to
the original process.

   This system routine is not available on Windows (exception: GCC on
Cygwin).

   Parameters: none

   Returns: ‘pid’ (the child process gets '0' returned, the calling
process gets the ‘pid’ of the created child).

   Negative values are returned for system dependant error codes and -1
if the function is not available on the current system.

   ‘CBL_GC_FORK’ allows you to fork the current COBOL process to a new
one.  The current content of the process' storage (including
‘LOCAL-STORAGE’) will be identical, any file handles get invalid in the
new process, positions and file / record locks are only available to the
original process.  This system routine is not available on Windows
(exception: ‘gcc’ on Cygwin).  Parameters: none Returns: ‘pid’ (the
child process gets 0 returned, the calling process gets the ‘pid’ of the
created children).  Negative values are returned for system dependant
error codes and -1 if the function is not available on the current
system.

      IDENTIFICATION DIVISION.
      PROGRAM-ID. prog.
      DATA DIVISION.
      WORKING-STORAGE SECTION.
      01  CHILD-PID      PIC S9(9) BINARY.
      01  WAIT-STS       PIC S9(9) BINARY.
      PROCEDURE DIVISION.
          CALL     "CBL_GC_FORK" RETURNING CHILD-PID END-CALL
          EVALUATE TRUE
                   WHEN CHILD-PID = ZERO
                        PERFORM CHILD-CODE
                   WHEN CHILD-PID > ZERO
                        PERFORM PARENT-CODE
                   WHEN CHILD-PID = -1
                        DISPLAY 'CBL_GC_FORK is not available on the current'
                        ' system!'
                        PERFORM CHILD-CODE
                        MOVE 0 TO CHILD-PID
                        PERFORM PARENT-CODE
                   WHEN OTHER
                        MULTIPLY -1 BY CHILD-PID END-MULTIPLY
                        DISPLAY 'CBL_GC_FORK returned system error: ' CHILD-PID
          END-EVALUATE
          STOP     RUN.
      CHILD-CODE.
          CALL     "C$SLEEP" USING 1 END-CALL
          DISPLAY  "Hello, I am the child"
          MOVE     2 TO RETURN-CODE.
      PARENT-CODE.
          DISPLAY  "Hello, I am the parent"
          CALL     "CBL_GC_WAITPID" USING CHILD-PID RETURNING WAIT-STS
          MOVE     0 TO RETURN-CODE
          EVALUATE TRUE
                   WHEN WAIT-STS >= 0
                        DISPLAY 'Child ended with status: ' WAIT-STS
                   WHEN WAIT-STS = -1
                        DISPLAY 'CBL_GC_WAITPID is not available on the '
                        'current system!'
                   WHEN WAIT-STS < -1
                        MULTIPLY -1 BY WAIT-STS END-MULTIPLY
                        DISPLAY 'CBL_GC_WAITPID returned system error: ' WAIT-STS
          END-EVALUATE.



File: gnucobpr.info,  Node: CBL_GC_GETOPT,  Next: CBL_GC_HOSTED,  Prev: CBL_GC_FORK,  Up: Built-In System Subroutines

8.2.31 CBL_GC_GETOPT
--------------------

               CBL_GC_GETOPT Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_GC_GETOPT" USING BY REFERENCE SHORTOPTIONS LONGOPTIONS LONGIND
 ~~~~                 ~~~~~
                            BY VALUE LONG-ONLY
                            BY REFERENCE RETURN-CHAR OPT-VAL


=======================================================================
   ‘CBL_GC_GETOPT’ adapts the well-known option parser, ‘getopt’, to
GnuCOBOL.

   The usage of this system routine is described by the following
example.

      IDENTIFICATION DIVISION.
      PROGRAM-ID. PROG.
      DATA DIVISION.
      WORKING-STORAGE SECTION.
      78  SHORTOPTIONS VALUE "jkl".
      01  LONGOPTIONS.
          05 OPTIONRECORD OCCURS 2 TIMES.
             10  OPTIONNAME   PIC X(25).
             10  HAS-VALUE    PIC 9.
             10  VALPOINT     POINTER VALUE NULL.
             10  RETURN-VALUE PIC X(4).
      01  LONGIND             PIC 99.
      01  LONG-ONLY           PIC 9 VALUE 1.
      01  RETURN-CHAR         PIC X(4).
      01  OPT-VAL             PIC X(10).
      01  COUNTER             PIC 9 VALUE 0.

   We first need to define the necessary fields for ‘getopt’'s
‘shortoptions’, ‘longoptions’, longoption index (‘longind’),
long-only-option (‘long-only’) and also the fields for return values
‘return-char’ and ‘opt-val’ (arbitrary size with trimming, see return
codes).

   The ‘shortoptions’ are written down as an alphanumeric field (i.e., a
string with arbitrary size) as follows:

     "ab:c::d"

   This means we want ‘getopt’ to look for short options named ‘a’, ‘b’,
‘c’ or ‘d’, require an option value for ‘b’, and accept an optional one
for ‘c’.

   The ‘longoptions’ are defined as a table of records with ‘oname’,
‘has-value’, ‘valpoint’ and ‘val’.(1)

   ‘oname’ defines the name of a longoption.  ‘has-value’ defines if an
option value is demanded (‘has-val = 1’), optional (‘has-val = 2’) or
not required (‘has-val = 0’).

   ‘valpoint’ is a pointer used to specify an address to save ‘getopt's’
return value to.  The pointer is optional.  If it is ‘NULL’, ‘getopt’
returns a value as usual.  If you use the pointer it has to point to a
‘PIC X(4)’ field.  The field val is a ‘PIC X(4)’ character which is
returned if the longoption was recognized.

   The longoption structure is immutable!  You can only vary the number
of records.

   Now we have the tools to run ‘CBL_GC_GETOPT’ within the procedure
division.

     PROCEDURE DIVISION.
          MOVE     "version" to OPTIONNAME (1).
          MOVE     0 TO HAS-VALUE (1).
          MOVE     ‘V’ TO RETURN-VALUE (1).
          MOVE     "verbose" TO OPTIONNAME (2).
          MOVE     0 TO HAS-VALUE (2).
          MOVE     ‘V’ TO RETURN-VALUE (2).
          PERFORM  WITH TEST AFTER UNTIL RETURN-CODE = -1
                   CALL 'CBL_GC_GETOPT' USING
                       BY REFERENCE SHORTOPTIONS LONGOPTIONS LONGIND
                       BY VALUE LONG-ONLY
                       BY REFERENCE RETURN-CHAR OPT-VAL
                   END-CALL
                   DISPLAY RETURN-CHAR END-DISPLAY
                   DISPLAY OPT-VAL END-DISPLAY
          END-PERFORM
          STOP RUN.

   The example shows how we initialize all parameters and call the
routine until ‘CBL_GC_GETOPT’ runs out of options and returns -1.

‘return-char’ might contain the following regular character if an option
was recognized:

‘?’
     undefined or ambiguous option

‘1’
     non-option (only if first byte of so is ‘-’)

‘0’
     ‘valpoint != NULL’ and we are writing the return value to the
     specified address

‘-1’
     no more options (or reach the first non-option if first byte of
     ‘shortoptions’ is ‘+’)

The return-codes of ‘CBL_GC_GETOPT’ are:

‘1’
     a non-option (only if first byte of so is ‘-’)

‘0’
     ‘valpoint != NULL’ and we are writing the return value to the
     specified address

‘-1’
     no more options (or reach the first non-option if first byte of
     ‘shortoptions’ is ‘+’)

‘2’
     truncated option value in ‘opt-val’ (because ‘opt-val’ was too
     small)

‘3’
     a regular answer from ‘getopt’

   ---------- Footnotes ----------

   (1) Say what?  the discussion and code seem to have diverged.


File: gnucobpr.info,  Node: CBL_GC_HOSTED,  Next: CBL_GC_NANOSLEEP,  Prev: CBL_GC_GETOPT,  Up: Built-In System Subroutines

8.2.32 CBL_GC_HOSTED
--------------------

               CBL_GC_HOSTED Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_GC_HOSTED" USING ARG-1  ARG-2
 ~~~~                 ~~~~~

 Note replaces CBL_OC_HOSTED which is kept as a legacy item.


=======================================================================

   ‘CBL_GC_HOSTED’ provides access to the following C hosted variables:
‘argc’
     ‘binary-long by value’

‘argv’
     ‘pointer to char **’

‘stdin, stdout, stderr’
     ‘pointer’

‘errno’
     giving address of ‘errno’ in pointer to ‘binary-long’, use ‘based’
     for more

   Direct access and conditional access to the following variables:

‘tzname’
     ‘pointer to pointer to array of two char pointer’s

‘timezone’
     C ‘long’, will be seconds west of UTC

‘daylight’
     C ‘int’, will be 1 during daylight savings

   The system will need ‘HAVE TIMEZONE’ defined for these to return
anything meaningful.  Attempts made when they are not available will
return 1 from ‘CBL GC HOSTED’.

   It returns 0 when match, 1 on failure, case matters as does length,
"arg" won't match.

   The usage of this system routine is described by the following
example.

     IDENTIFICATION DIVISION.
      PROGRAM-ID. HOSTED.
      DATA DIVISION.
      WORKING-STORAGE SECTION.
      01  Argc        BINARY-LONG.
      01  Argv        POINTER.
      01  Stdin       POINTER.
      01  Stdout      POINTER.
      01  Stderr      POINTER.
      01  Errno       POINTER.
      01  Err         BINARY-LONG BASED.
      01  Domain      FLOAT-LONG VALUE 3.0.
      01  Tzname      POINTER.
      01  Tznames     POINTER BASED.
          05  Tzs     POINTER OCCURS 2.
      01  Timezone    BINARY-LONG.
      01  Daylight    BINARY-SHORT.
     *>
      PROCEDURE DIVISION.
          call     "CBL_GC_HOSTED" using stdin "stdin"
          display  "stdin : " stdin
          call     "feof" using by value stdin
          display  "feof stdin : " return-code
          call     "CBL_GC_HOSTED" using stdout "stdout"
          display  "stdout : " stdout
          call     "fprintf" using by value stdout by content "Hello" & x"0a"
          call     "CBL_GC_HOSTED" using stderr "stderr"
          display  "stderr : " stderr
          call     "fprintf" using by value stderr by content "on err" & x"0a"
          call     "CBL_GC_HOSTED" using argc "argc"
          display  "argc : " argc
          call     "CBL_GC_HOSTED" using argv "argv"
          display  "argv : " argv
          call     "args" using by value argc argv
          call     "CBL_GC_HOSTED" using errno "errno"
          display  "&errno : " errno
          set      address of err to errno
          display  "errno : " err
          call     "acos" using by value domain
          display  "errno after acos(3.0): " err ", EDOM is 33"
          call     "CBL_GC_HOSTED" using argc "arg"
          display  "'arg' lookup : " return-code
          call     "CBL_GC_HOSTED" using null "argc"
          display  "null with argc : " return-code
          display  "argc is still : " argc
     *> the following only returns zero if the system has HAVE_TIMEZONE set
          call     "CBL_GC_HOSTED" using daylight "daylight "
          display  "'timezone' lookup : " return-code
          if       return-code not = 0
                   display "system doesn't has timezone"
          else
                   display "timezone is : " timezone
                   call "CBL_GC_HOSTED" using daylight "daylight "
                   display "'daylight' lookup : " return-code
                   display "daylight is : " daylight
                   set environment "TZ" to "PST8PDT"
                   call static "tzset" returning omitted on exception
                             continue end-call
                   call "CBL_GC_HOSTED" using tzname "tzname"
                   display "'tzname' lookup : " return-code
     *> tzs(1) will point to z"PST" and tzs(2) to z"PDT"
                   if   return-code equal 0 and tzname not equal null then
                        set address of tznames to tzname
                        if   tzs(1) not equal null then
                             display "tzs #1 : " tzs(1)
                        end-if
                        if   tzs(2) not equal null then
                             display "tzs #2 : " tzs(2)
                        end-if
                   end-if
          end-if
          goback.
      end program hosted.

   Note that the legacy name of this routine that starts with ‘CBL_OC’
is deprecated, as is ‘NANOSLEEP’ but will still work.  It is recommended
that all library routines names starting with ‘CBL_OC’ are replaced with
‘CBL_GC’ to minimise issues.


File: gnucobpr.info,  Node: CBL_GC_NANOSLEEP,  Next: CBL_GC_PRINTABLE,  Prev: CBL_GC_HOSTED,  Up: Built-In System Subroutines

8.2.33 CBL_GC_NANOSLEEP
-----------------------

              CBL_GC_NANOSLEEP Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_GC_NANOSLEEP" USING nanoseconds-to-sleep
 ~~~~                    ~~~~~

 Note replaces CBL_OC_NANOSLEEP which is kept as a legacy item.


=======================================================================
   This subroutine puts the program to sleep for the specified number of
nanoseconds.

   The effective granularity of NANOSECONDS-TO-SLEEP values will depend
upon the granularity of the system clock your computer is using and the
timing granularity of the operating system that computer is running.

   For example, you will not expect to see any difference between values
of 1, 100, 500 or 1000, but you should see a difference between values
such as 250000000 and 500000000.

   The NANOSECONDS-TO-SLEEP argument is a numeric literal or data item.

   There are one billion nanoseconds in a second, so if you wanted to
put the program to sleep for 1/4 second you'd use a NANOSECONDS-TO-SLEEP
value of 250000000.

   Note that the legacy name of this routine starts with "CBL_OC" is
deprecated, as is ‘HOSTED’, but will still work.  It is recommended that
all library routines names starting with "CBL_OC" are replaced with
"CBL_GC" to minimise issues.


File: gnucobpr.info,  Node: CBL_GC_PRINTABLE,  Next: CBL_GC_SCR_DUMP,  Prev: CBL_GC_NANOSLEEP,  Up: Built-In System Subroutines

8.2.34 CBL_GC_PRINTABLE
-----------------------

              CBL_GC_PRINTABLE Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_GC_PRINTABLE" USING data-item [ , char ]
 ~~~~                    ~~~~~

Note replaces C$PRINTABLE which is kept as a legacy item.


=======================================================================
   The ‘CBL_GC_PRINTABLE’ subroutine converts the contents of the
data-item specified as the first argument to printable characters.

   Those characters that are deemed printable (as defined by the
character set used by DATA-ITEM) will remain unchanged, while those that
are not printable will be converted to the character specified as the
second argument.

   If no CHAR argument is provided, a period (‘.’) will be used.



File: gnucobpr.info,  Node: CBL_GC_SCR_DUMP,  Next: CBL_GC_SCR_RESTORE,  Prev: CBL_GC_PRINTABLE,  Up: Built-In System Subroutines

8.2.35 CBL_GC_SCR_DUMP
----------------------

              CBL_GC_SCR_DUMP Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_GC_SCR_DUMP" USING file-name, return-code
 ~~~~                   ~~~~~


=======================================================================
   Use this subroutine to writes the current contents of the screen to
the file named by file-name.  This function prepares the file that will
be used with the CBL_GC_SCR_RESTORE function.

   The following is a sample GnuCOBOL program that shows how to use the
DUMP and RESTORE routines.

             >>SOURCE FORMAT IS FREE
     REPLACE ==:BCOL:== BY ==with BACKGROUND-COLOR==
             ==:FCOL:== BY ==FOREGROUND-COLOR==.
     IDENTIFICATION DIVISION.
     program-id. SCRDUMPRESTORE.
     DATA DIVISION.
     WORKING-STORAGE SECTION.
     01 Black constant as 00.
     01 Green constant as 02.
     01 wBco        pic 9(02) value Green.
     01 wFco        pic 9(02) value Black.
     01 wLin        pic 99 value 05.
     01 wCol        pic 99 value 10.
     01 wScreenName PIC X(256) value space.
     01 wScrOk      BINARY-LONG value zero.
     01 wScrOk9     pic 99.
     01 .
        03 Bmess pic x(30) occurs 20 value space.

     PROCEDURE DIVISION.
        *> D I S P L A Y 1st S C R E E N
        move Green to wBco move Black to wFco
        move '111111111111111111111111111111' to Bmess(1)
        move '>>>>>>>>>> MESSAGE 1 <<<<<<<<<' to Bmess(2)
        move '111111111111111111111111111111' to Bmess(3)
        move '111111111111111111111111111111' to Bmess(4)
        move '111111111111111111111111111111' to Bmess(5)
        move '111111111111111111111111111111' to Bmess(6)
        move '------------------------------' to Bmess(7)
        perform DisplayMessage thru DisplayMessageEx
        display 'PRESS ENTER TO DUMP 1st SCREEN ' at line 01 col 01 :BCOL: 07 :FCOL: black
        accept omitted
        *> save 1st screen
        move 'DUMPSCREEN.TMP' & x'00' to wScreenName
        call 'CBL_GC_SCR_DUMP' using by reference wScreenName returning wScrOk end-call
        display '1st SCREEN DUMPED - RETURN CODE IS: ' at line 01 col 01 :BCOL: 07 :FCOL: black
        move wScrOk to wScrOk9
        display wScrOk9 at line 01 col 41 :BCOL: 07 :FCOL: black
        accept omitted
        display 'PRESS ENTER TO DISPLAY 2nd SCREEN          ' at line 01 col 01 :BCOL: 07 :FCOL: black
        accept omitted
        *> D I S P L A Y 2nd S C R E E N
        DISPLAY ' ' AT 0101 WITH ERASE EOS
        move 12 to wLin move 20 to wCol
        move 04 to wBco move Black to wFco
        move '+----------------------------+' to Bmess(1)
        move '|2222222222222222222222222222|' to Bmess(2)
        move '|2222222222222222222222222222|' to Bmess(3)
        move '| MESSAGE 2 |' to Bmess(4)
        move '|2222222222222222222222222222|' to Bmess(5)
        move '|2222222222222222222222222222|' to Bmess(6)
        move '+----------------------------+' to Bmess(7)
        perform DisplayMessage thru DisplayMessageEx
        display 'PRESS ENTER TO RESTORE 1st SCREEN          ' at line 01 col 01 :BCOL: 07 :FCOL: black
        accept omitted
        *> restore 1st screen
        call 'CBL_GC_SCR_RESTORE' using by reference wScreenName returning wScrOk end-call
        CALL 'CBL_DELETE_FILE' USING wScreenName
        display '1st SCREEN RESTORED - RETURN CODE IS: ' at line 01 col 01 :BCOL: 07 :FCOL: black
        move wScrOk to wScrOk9
        display wScrOk9 at line 01 col 41 :BCOL: 07 :FCOL: black
        accept omitted
        STOP RUN.

     DisplayMessage.
        display Bmess(1) at line wLin + 1 col wCol :BCOL: wBco :FCOL: wFco
        display Bmess(2) at line wLin + 2 col wCol :BCOL: wBco :FCOL: wFco
        display Bmess(3) at line wLin + 3 col wCol :BCOL: wBco :FCOL: wFco
        display Bmess(4) at line wLin + 4 col wCol :BCOL: wBco :FCOL: wFco
        display Bmess(5) at line wLin + 5 col wCol :BCOL: wBco :FCOL: wFco
        display Bmess(6) at line wLin + 6 col wCol :BCOL: wBco :FCOL: wFco
        display Bmess(7) at line wLin + 7 col wCol :BCOL: wBco :FCOL: wFco
        continue.
     DisplayMessageEx. exit.



File: gnucobpr.info,  Node: CBL_GC_SCR_RESTORE,  Next: CBL_GC_SET_SCR_SIZE,  Prev: CBL_GC_SCR_DUMP,  Up: Built-In System Subroutines

8.2.36 CBL_GC_SCR_RESTORE
-------------------------

             CBL_GC_SCR_RESTORE Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_GC_SCR_RESTORE" USING file-name, return-code
 ~~~~                      ~~~~~


=======================================================================

   Use this subroutine to restore the screen to the way it looked in the
dump file which must have been created using the CBL_GC_SCR_DUMP
function.



File: gnucobpr.info,  Node: CBL_GC_SET_SCR_SIZE,  Next: CBL_GC_WAITPID,  Prev: CBL_GC_SCR_RESTORE,  Up: Built-In System Subroutines

8.2.37 CBL_GC_SET_SCR_SIZE
--------------------------

            CBL_GC_SET_SCR_SIZE Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_GC_SET_SCR_SIZE" USING no-of-lines, no-of-cols
 ~~~~                       ~~~~~


=======================================================================
   Use this subroutine to set the current console screen size.

   When the system is running in a windowed environment, this will be
the sizing of the console window in which the program is executing.
When the system is not running a windowing environment, the physical
console screen attributes will be set.  In environments such as a
Windows console window, where the logical size of the window may far
exceed that of the physical console window, the size set will be that
for the physical console window.

   The size data must be in binary form or any other numeric forms to be
accepted.

   The following are possibly typical NO-OF-LINES and NO-OF-COLUMNS
definitions:

     01  NO-OF-LINES             USAGE BINARY-CHAR UNSIGNED.
     01  NO-OF-COLUMNS           USAGE BINARY-CHAR UNSIGNED.

   This system call will only work if the terminal program used is
compatible for such operations and not all are.


File: gnucobpr.info,  Node: CBL_GC_WAITPID,  Next: CBL_GET_CSR_POS,  Prev: CBL_GC_SET_SCR_SIZE,  Up: Built-In System Subroutines

8.2.38 CBL_GC_WAITPID
---------------------

               CBL_GC_WAITPID Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_GC_WAITPID" USING ARG-1
 ~~~~                  ~~~~~
                       RETURNING RET-STATUS
                       ~~~~~~~~~


=======================================================================

   ‘CBL_GC_WAITPID’ allows you to wait until another system process
ended.

   Additionally you can check the process's return code.

   Parameters: none

   Returns: function-status / child-status

   Negative values are returned for system dependant error codes and -1
if the function is not available on the current system.

     CALL     "CBL_GC_WAITPID" USING CHILD-PID RETURNING WAIT-STS
     MOVE     0 TO RETURN-CODE
     DISPLAY  'CBL_GC_WAITPID ended with status: ' WAIT-STS


File: gnucobpr.info,  Node: CBL_GET_CSR_POS,  Next: CBL_GET_CURRENT_DIR,  Prev: CBL_GC_WAITPID,  Up: Built-In System Subroutines

8.2.39 CBL_GET_CSR_POS
----------------------

              CBL_GET_CSR_POS Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_GET_CSR_POS" USING cursor-locn-buffer
 ~~~~                   ~~~~~


=======================================================================
   This subroutine will retrieve the current cursor location on the
screen, returning a 2-byte value into the supplied CURSOR-LOCN-BUFFER.
The first byte of CURSOR-LOCN-BUFFER will receive the current line (row)
location while the second receives the current column location.

   The returned location data will be in binary form, and will be based
upon starting values of 0, meaning that if the cursor is located at line
15, column 12 at the time this routine is called, a value of (14,11)
will be returned.

   The following is a typical CURSOR-LOCN-BUFFER definition:

     01  CURSOR-LOCN-BUFFER.
         05 CURSOR-LINE          USAGE BINARY-CHAR UNSIGNED.
         05 CURSOR-COLUMN        USAGE BINARY-CHAR UNSIGNED.

   Values of 1 (Line) and 1 (column) will be returned if GnuCOBOL was
not generated to include screen I/O.


File: gnucobpr.info,  Node: CBL_GET_CURRENT_DIR,  Next: CBL_GET_SCR_SIZE,  Prev: CBL_GET_CSR_POS,  Up: Built-In System Subroutines

8.2.40 CBL_GET_CURRENT_DIR
--------------------------

            CBL_GET_CURRENT_DIR Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_GET_CURRENT_DIR" USING BY VALUE 0,
 ~~~~                       ~~~~~    ~~~~~
                                  BY VALUE length,
                                     ~~~~~
                                  BY REFERENCE buffer
                                     ~~~~~~~~~


=======================================================================
   This retrieves the fully-qualified pathname of the current directory,
saving up to LENGTH characters of that name into BUFFER.

   The first argument is unused, but must be specified.  It must be
specified ‘BY VALUE’ (*note CALL::).

   The LENGTH argument must be specified ‘BY VALUE’.  The BUFFER
argument must be specified ‘BY REFERENCE’.

   The value specified for the LENGTH argument (a numeric literal or
data item) should not exceed the actual length of BUFFER argument.

   If the value specified for the LENGTH argument is LESS THAN the
actual length of BUFFER argument, the current directory path will be
left-justified and space filled within the first LENGTH bytes of BUFFER
-- any bytes in BUFFER after that point will be unchanged.

   If the routine is successful, a value of 0 will be returned to the
‘RETURN-CODE’ special register (*note Special Registers::).  If the
routine failed because of a problem with an argument (such as a negative
or 0 length), a value of 128 will result.  Finally, if the 1^{st}
argument value is anything but zero, the routine will fail with a 129
value.


File: gnucobpr.info,  Node: CBL_GET_SCR_SIZE,  Next: CBL_IMP,  Prev: CBL_GET_CURRENT_DIR,  Up: Built-In System Subroutines

8.2.41 CBL_GET_SCR_SIZE
-----------------------

              CBL_GET_SCR_SIZE Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_GET_SCR_SIZE" USING no-of-lines, no-of-cols
 ~~~~                    ~~~~~


=======================================================================
   Use this subroutine to retrieve the current console screen size.

   When the system is running in a windowed environment, this will be
the sizing of the console window in which the program is executing.
When the system is not running a windowing environment, the physical
console screen attributes will be returned.  In environments such as a
Windows console window, where the logical size of the window may far
exceed that of the physical console window, the size returned will be
that of the physical console window.  Two one-byte values will be
returned -- the first will be the current number of lines (rows) while
the second will be the number of columns.

   The returned size data will be in binary form.

   The following are typical NO-OF-LINES and NO-OF-COLUMNS definitions:

     01  NO-OF-LINES             USAGE BINARY-CHAR UNSIGNED.
     01  NO-OF-COLUMNS           USAGE BINARY-CHAR UNSIGNED.

   GnuCOBOL run-time screen management must have been initialized prior
to CALLing this routine in order to receive meaningful values.  This
means that a ‘DISPLAY data-item’ statement (*note DISPLAY data-item::)
or a ‘ACCEPT data-item’ statement (*note ACCEPT data-item::) must have
been executed prior to executing the ‘CALL’ statement.

   Zero values will be returned if the screen has not been initialized
and values of 24 (lines) and 80 (columns) will be returned if GnuCOBOL
was not generated to include screen I/O.

   Maximum values for BINARY-CHAR is 255 and any excess to this will be
wrong so if lines or columns exceed 255, results will not be valid.


File: gnucobpr.info,  Node: CBL_IMP,  Next: CBL_NIMP,  Prev: CBL_GET_SCR_SIZE,  Up: Built-In System Subroutines

8.2.42 CBL_IMP
--------------

                  CBL_IMP Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_IMP" USING item-1, item-2, BY VALUE byte-length
 ~~~~           ~~~~~                    ~~~~~


=======================================================================
 Old    Old    New     This subroutine performs a bit-by-bit logical
Arg 1  Arg 2  Arg 2    implies process between the left-most
 Bit    Bit    Bit     8*BYTE-LENGTH corresponding bits of ITEM-1 and
=====  =====  =====    ITEM-2, storing the resulting bit string into
  0      0      1      ITEM-2.  The truth table shown to the left
  0      1      1      documents the ‘IMP’ process.
  1      0      0      
  1      1      1      The ITEM-1 argument may be an alphanumeric
                       literal or a data item and ITEM-2 must be a data
                       item.  The length of both ITEM-1 and ITEM-2 must
                       be at least 8*BYTE-LENGTH.

   The BYTE-LENGTH argument may be a numeric literal or data item, and
must be specified using ‘BY VALUE’ (*note CALL::).

   Any bits in ITEM-2 after the 8*BYTE-LENGTH point will be unaffected.

   A result of zero will be passed back in the ‘RETURN-CODE’ special
register (*note Special Registers::).


File: gnucobpr.info,  Node: CBL_NIMP,  Next: CBL_NOR,  Prev: CBL_IMP,  Up: Built-In System Subroutines

8.2.43 CBL_NIMP
---------------

                  CBL_NIMP Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_NIMP" USING item-1, item-2, BY VALUE byte-length
 ~~~~            ~~~~~                    ~~~~~


=======================================================================
 Old    Old    New     This subroutine performs the negation of a
Arg 1  Arg 2  Arg 2    bit-by-bit logical implies process between the
 Bit    Bit    Bit     left-most 8*BYTE-LENGTH corresponding bits of
=====  =====  =====    ITEM-1 and ITEM-2, storing the resulting bit
  0      0      0      string into ITEM-2.  The truth table shown to
  0      1      0      the left documents the ‘NIMP’ process.
  1      0      1      
  1      1      0      The ITEM-1 argument may be an alphanumeric
                       literal or a data item and ITEM-2 must be a data
                       item.  The length of both ITEM-1 and ITEM-2 must
                       be at least 8*BYTE-LENGTH.

   The BYTE-LENGTH argument may be a numeric literal or data item, and
must be specified using ‘BY VALUE’ (*note CALL::).

   Any bits in ITEM-2 after the 8*BYTE-LENGTH point will be unaffected.

   A result of zero will be passed back in the ‘RETURN-CODE’ special
register (*note Special Registers::).


File: gnucobpr.info,  Node: CBL_NOR,  Next: CBL_NOT,  Prev: CBL_NIMP,  Up: Built-In System Subroutines

8.2.44 CBL_NOR
--------------

                  CBL_NOR Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_NOR" USING item-1, item-2, BY VALUE byte-length
 ~~~~           ~~~~~                    ~~~~~


=======================================================================
 Old    Old    New     This subroutine performs the negation of a
Arg 1  Arg 2  Arg 2    bit-by-bit logical or' process between the
 Bit    Bit    Bit     left-most 8*BYTE-LENGTH corresponding bits of
=====  =====  =====    ITEM-1 and ITEM-2, storing the resulting bit
  0      0      1      string into ITEM-2.  The truth table shown to
  0      1      0      the left documents the ‘NOR’ process.
  1      0      0      
  1      1      0      The ITEM-1 argument may be an alphanumeric
                       literal or a data item and ITEM-2 must be a data
                       item.  The length of both ITEM-1 and ITEM-2 must
                       be at least 8*BYTE-LENGTH.

   The BYTE-LENGTH argument may be a numeric literal or data item, and
must be specified using ‘BY VALUE’ (*note CALL::).

   Any bits in ITEM-2 after the 8*BYTE-LENGTH point will be unaffected.

   A result of zero will be passed back in the ‘RETURN-CODE’ special
register (*note Special Registers::).


File: gnucobpr.info,  Node: CBL_NOT,  Next: CBL_OC_GETOPT,  Prev: CBL_NOR,  Up: Built-In System Subroutines

8.2.45 CBL_NOT
--------------

                  CBL_NOT Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_NOT" USING item-1, BY VALUE byte-length
 ~~~~           ~~~~~            ~~~~~


=======================================================================
   This subroutine "flips" the left-most 8*BYTE-LENGTH bits of ITEM-1,
changing 0 bits to 1, and 1 bits to 0.  The changes are made directly in
ITEM-1.

   The ITEM-1 argument must be a data item.  The length of ITEM-1 must
be at least 8*BYTE-LENGTH.

   The BYTE-LENGTH argument may be a numeric literal or data item, and
must be passed using ‘BY VALUE’ (*note CALL::).

   Any bits in ITEM-1 after the 8*BYTE-LENGTH point will be unaffected.

   A result of zero will be passed back in the ‘RETURN-CODE’ special
register (*note Special Registers::).


File: gnucobpr.info,  Node: CBL_OC_GETOPT,  Next: CBL_OC_HOSTED,  Prev: CBL_NOT,  Up: Built-In System Subroutines

8.2.46 CBL_OC_GETOPT
--------------------

               CBL_GC_GETOPT Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_GC_GETOPT" USING BY REFERENCE SHORTOPTIONS LONGOPTIONS LONGIND
 ~~~~                 ~~~~~
                            BY VALUE LONG-ONLY
                            BY REFERENCE RETURN-CHAR OPT-VAL


=======================================================================
   Use function CBL_GC_GETOPT instead as redundant and will be removed.



File: gnucobpr.info,  Node: CBL_OC_HOSTED,  Next: CBL_OC_NANOSLEEP,  Prev: CBL_OC_GETOPT,  Up: Built-In System Subroutines

8.2.47 CBL_OC_HOSTED
--------------------

               CBL_GC_HOSTED Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_GC_HOSTED" USING ARG-1  ARG-2
 ~~~~                 ~~~~~

 Note replaces CBL_OC_HOSTED which is kept as a legacy item.


=======================================================================
   Use function CBL_GC_HOSTED instead as redundant and will be removed.



File: gnucobpr.info,  Node: CBL_OC_NANOSLEEP,  Next: CBL_OPEN_FILE,  Prev: CBL_OC_HOSTED,  Up: Built-In System Subroutines

8.2.48 CBL_OC_NANOSLEEP
-----------------------

              CBL_GC_NANOSLEEP Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_GC_NANOSLEEP" USING nanoseconds-to-sleep
 ~~~~                    ~~~~~

 Note replaces CBL_OC_NANOSLEEP which is kept as a legacy item.


=======================================================================
   Use function CBL_GC_NANOSLEEP instead as redundant and will be
removed.



File: gnucobpr.info,  Node: CBL_OPEN_FILE,  Next: CBL_OR,  Prev: CBL_OC_NANOSLEEP,  Up: Built-In System Subroutines

8.2.49 CBL_OPEN_FILE
--------------------

               CBL_OPEN_FILE Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_OPEN_FILE" USING file-path, access-mode, 0, 0, handle
 ~~~~                 ~~~~~


=======================================================================
   This routine opens an existing file for use as a byte-stream file
usable by CBL_WRITE_FILE or CBL_READ_FILE.

   The FILE-PATH argument is an alphanumeric literal or data-item.

   The ACCESS-MODE argument is a numeric literal or data item with a
‘PIC X USAGE COMP-X’ (or ‘USAGE BINARY-CHAR’) definition; it specifies
how you wish to use the file, as follows:

‘1’
     input (read-only)

‘2’
     output (write-only)

‘3’
     input and/or output

   The third and fourth arguments would specify a locking mode and
device specification, respectively, but they're not implemented in
GnuCOBOL (currently, at least) -- just specify each as 0.

   The final argument (HANDLE) is a ‘PIC X(4) USAGE COMP-X’ item that
will receive the handle to the file.  That handle is used on all other
byte-stream functions to reference this specific file.

   A ‘RETURN-CODE’ special register (*note Special Registers::) value of
-1 indicates an invalid argument, while a value of 0 indicates success.
A value of 35 means the file does not exist.

   An example of the use of OPEN, CLOSE, READ etc., can be found in
Contribs program printcbl.cbl which is basically also in cobxref.cbl as
program 3.



File: gnucobpr.info,  Node: CBL_OR,  Next: CBL_READ_FILE,  Prev: CBL_OPEN_FILE,  Up: Built-In System Subroutines

8.2.50 CBL_OR
-------------

                   CBL_OR Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_OR" USING item-1, item-2, BY VALUE byte-length
 ~~~~          ~~~~~                    ~~~~~


=======================================================================
 Old    Old    New     This subroutine performs a bit-by-bit logical or
Arg 1  Arg 2  Arg 2    process between the left-most 8*BYTE-LENGTH
 Bit    Bit    Bit     corresponding bits of ITEM-1 and ITEM-2, storing
=====  =====  =====    the resulting bit string into ITEM-2.  The truth
  0      0      0      table shown to the left documents the ‘OR’
  0      1      1      process.
  1      0      1      
  1      1      1      The ITEM-1 argument may be an alphanumeric
                       literal or a data item and ITEM-2 must be a data
                       item.  The length of both ITEM-1 and ITEM-2 must
                       be at least 8*BYTE-LENGTH.

   The BYTE-LENGTH argument may be a numeric literal or data item, and
must be specified using ‘BY VALUE’ (*note CALL::).

   Any bits in ITEM-2 after the 8*BYTE-LENGTH point will be unaffected.

   A result of zero will be passed back in the ‘RETURN-CODE’ special
register (*note Special Registers::).


File: gnucobpr.info,  Node: CBL_READ_FILE,  Next: CBL_READ_KBD_CHAR,  Prev: CBL_OR,  Up: Built-In System Subroutines

8.2.51 CBL_READ_FILE
--------------------

               CBL_READ_FILE Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_READ_FILE" USING handle, offset, nbytes, flag, buffer
 ~~~~                 ~~~~~


=======================================================================
   This routine reads NBYTES of data starting at byte number OFFSET from
the byte-stream file defined by HANDLE into BUFFER.

   The HANDLE argument (‘PIC X(4) USAGE COMP-X’) must have been
populated by a prior call to ‘CBL_OPEN_FILE’ built-in system subroutine
(*note CBL_OPEN_FILE::).

   The OFFSET argument (‘PIC X(8) USAGE COMP-X’) defines the location in
the file of the first byte to be read.  The first byte of a file is byte
offset 0 and MUST be preset to zero for first use.

   The NBYTES argument (‘PIC X(4) USAGE COMP-X’) specifies how many
bytes (maximum) will be read.  If the FLAG argument is specified as 128,
the size of the file (in bytes) will be returned into the file offset
argument (argument 2) upon completion.  Not all operating
system/GnuCOBOL environments may be able to retrieve file sizes in such
cases, a value of zero will be returned.  The only other valid value for
flags is 0.  This argument may be specified either as a numeric literal
or as a ‘PIC X USAGE COMP-X’ data item.

   Upon completion, the ‘RETURN-CODE’ special register (*note Special
Registers::) will be set to 0 if the read was successful or to 10 if an
"end-of-file" condition occurred.  If a value of -1 is returned, a
problem was identified with the subroutine arguments.


File: gnucobpr.info,  Node: CBL_READ_KBD_CHAR,  Next: CBL_RENAME_FILE,  Prev: CBL_READ_FILE,  Up: Built-In System Subroutines

8.2.52 CBL_READ_KBD_CHAR
------------------------

             CBL_READ_KBD_CHAR Build-In Subroutine Syntax
=======================================================================

 CALL "CBL_READ_KBD_CHAR" USING char RETURNING status-code.
 ~~~~                     ~~~~~      ~~~~~~~~~


=======================================================================
   Waits until a character is typed from the terminal and then read it
with no echo.

   Parameters: char ‘PIC X’.  Receives the character that was typed, in
ASCII.

   status-code ‘PIC XX COMP-5’.

   If ‘RETURNING’ is not used the ‘RETURN-CODE’ special register
receives the status-code where zero is success and non-zero it is not.

   [Above information taken from MF WB manual].


File: gnucobpr.info,  Node: CBL_RENAME_FILE,  Next: CBL_RUNTIME_ERROR,  Prev: CBL_READ_KBD_CHAR,  Up: Built-In System Subroutines

8.2.53 CBL_RENAME_FILE
----------------------

              CBL_RENAME_FILE Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_RENAME_FILE" USING old-file-path, new-file-path
 ~~~~                   ~~~~~


=======================================================================
   You may use this subroutine to rename a file.

   The file specified by OLD-FILE-PATH will be "renamed" to the name
specified as NEW-FILE-PATH.  Each argument may be an alphanumeric
literal or data item.

   Despite what the name of this routine might make you believe, this
routine is more than just a simple "rename" -- it will actually move the
file supplied as the 1^{st} argument to the file specified as the 2nd
argument.  Think of it as a two-step sequence, first copying the
OLD-FILE-PATH file to the NEW-FILE-PATH file and then a second step
where the OLD-FILE-PATH is deleted.

   If the attempt to move the file fails (for example, it doesn't
exist), the ‘RETURN-CODE’ special register (*note Special Registers::)
will be set to 128; on successful completion it will be set to 0.



File: gnucobpr.info,  Node: CBL_RUNTIME_ERROR,  Next: CBL_SET_CSR_POS,  Prev: CBL_RENAME_FILE,  Up: Built-In System Subroutines

8.2.54 CBL_RUNTIME_ERROR
------------------------

             CBL_RUNTIME_ERROR Built-In Subroutine Syntax
=======================================================================

CALL "CBL_RUNTIME_ERROR" USING  ???
~~~~                     ~~~~~

??? More information needed from compiler developers. ???


=======================================================================
   Text to be added...



File: gnucobpr.info,  Node: CBL_SET_CSR_POS,  Next: CBL_TOLOWER,  Prev: CBL_RUNTIME_ERROR,  Up: Built-In System Subroutines

8.2.55 CBL_SET_CSR_POS
----------------------

              CBL_SET_CSR_POS Build-In Subroutine Syntax
=======================================================================

 CALL "CBL_SET_CSR_POS" USING cursor-locn-buffer
 ~~~~                   ~~~~~


=======================================================================
   Set current cursor position on terminal.

   This subroutine will set the cursor location on the screen, using a
2-byte value into the supplied CURSOR-LOCN-BUFFER.  The first byte of
CURSOR-LOCN-BUFFER is for the line (row) location while the second sets
the column location.

   The two byte data block must be in binary form, and will be based
upon starting values of 0, meaning that if the routine is called with a
value of (14,11) cursor will be located at line 15, column 12.

   The following is a typical CURSOR-LOCN-BUFFER definition:

     01  CURSOR-LOCN-BUFFER.
         05 CURSOR-LINE          USAGE BINARY-CHAR UNSIGNED.
         05 CURSOR-COLUMN        USAGE BINARY-CHAR UNSIGNED.



File: gnucobpr.info,  Node: CBL_TOLOWER,  Next: CBL_TOUPPER,  Prev: CBL_SET_CSR_POS,  Up: Built-In System Subroutines

8.2.56 CBL_TOLOWER
------------------

                CBL_TOLOWER Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_TOLOWER" USING data-item, BY VALUE convert-length
 ~~~~               ~~~~~               ~~~~~


=======================================================================
   This routine will convert the first CONVERT-LENGTH (a numeric literal
or data item) characters of DATA-ITEM (an alpha-numeric identifier) to
lower-case.

   The CONVERT-LENGTH argument must be specified ‘BY VALUE’ (*note
CALL::).  It specifies how many (leading) characters in data-item will
be converted -- any characters after that will remain unchanged.

   If CONVERT-LENGTH is negative or zero, no conversion will be
performed.


File: gnucobpr.info,  Node: CBL_TOUPPER,  Next: CBL_WRITE_FILE,  Prev: CBL_TOLOWER,  Up: Built-In System Subroutines

8.2.57 CBL_TOUPPER
------------------

                CBL_TOUPPER Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_TOUPPER" USING data-item, BY VALUE convert-length
 ~~~~               ~~~~~               ~~~~~


=======================================================================
   This routine will convert the first CONVERT-LENGTH (a numeric literal
or data item) characters of DATA-ITEM (an alpha-numeric identifier) to
upper-case.

   The CONVERT-LENGTH argument must be specified ‘BY VALUE’ (*note
CALL::).  It specifies how many (leading) characters in data-item will
be converted -- any characters after that will remain unchanged.

   If CONVERT-LENGTH is negative or zero, no conversion will be
performed.


File: gnucobpr.info,  Node: CBL_WRITE_FILE,  Next: CBL_XOR,  Prev: CBL_TOUPPER,  Up: Built-In System Subroutines

8.2.58 CBL_WRITE_FILE
---------------------

               CBL_WRITE_FILE Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_WRITE_FILE" USING handle, offset, nbytes, 0, buffer
 ~~~~                  ~~~~~


=======================================================================
   This routine writes NBYTES of data from BUFFER to the byte-stream
file defined by HANDLE starting at byte number OFFSET within the file.

   The HANDLE argument (‘PIC X(4) USAGE COMP-X’) must have been
populated by a prior call to CBL_OPEN_FILE. The offset argument (‘PIC
X(4) USAGE COMP-X’) defines the location in the file of the first byte
to be written to.  The first byte of a file is byte offset 0.

   The NBYTES argument (‘PIC X(4) USAGE COMP-X’) specifies how many
bytes (maximum) will be written.

   Currently, the only allowable value for the flags argument is 0.
This argument may be specified either as a numeric literal or as a ‘PIC
X(1) USAGE COMP-X’ data item.

   Upon completion, the ‘RETURN-CODE’ special register (*note Special
Registers::) will be set to 0 if the write was successful or to 30 if an
I/O error condition occurred.  If a value of -1 is returned, a problem
was identified with the subroutine arguments.


File: gnucobpr.info,  Node: CBL_XOR,  Next: EXTFH,  Prev: CBL_WRITE_FILE,  Up: Built-In System Subroutines

8.2.59 CBL_XOR
--------------

                  CBL_XOR Built-In Subroutine Syntax
=======================================================================

 CALL "CBL_XOR" USING item-1, item-2, BY VALUE byte-length
 ~~~~           ~~~~~                    ~~~~~


=======================================================================
 Old    Old    New     This subroutine performs a bit-by-bit logical
Arg 1  Arg 2  Arg 2    exclusive or process between the left-most
 Bit    Bit    Bit     8*BYTE-LENGTH corresponding bits of ITEM-1 and
=====  =====  =====    ITEM-2, storing the resulting bit string into
  0      0      0      ITEM-2.  The truth table shown to the left
  0      1      1      documents the ‘XOR’ process.
  1      0      1      
  1      1      0      The ITEM-1 argument may be an alphanumeric
                       literal or a data item and ITEM-2 must be a data
                       item.  The length of both ITEM-1 and ITEM-2 must
                       be at least 8*BYTE-LENGTH.

   The BYTE-LENGTH argument may be a numeric literal or data item, and
must be specified using ‘BY VALUE’ (*note CALL::).

   Any bits in ITEM-2 after the 8*BYTE-LENGTH point will be unaffected.

   A result of zero will be passed back in the ‘RETURN-CODE’ special
register (*note Special Registers::).



File: gnucobpr.info,  Node: EXTFH,  Next: SYSTEM,  Prev: CBL_XOR,  Up: Built-In System Subroutines

8.2.60 EXTFH
------------

                   EXTFH Built-In Subroutine Syntax
=======================================================================

CALL "EXTFH" USING  opcode fcd
~~~~         ~~~~~


=======================================================================
   The use of the EXTFH function is summarized very briefly.  The detail
of its use is too complex to be described in this document and is
described in a dedicated document.


opcode
Use a 2-character operation code to specify an exact operation
(OPEN, READ, WRITE, CLOSE etc ...).

fcd
Use this area for:
Input fields: to be set before calling.
Output fields: values of fields set by EXTFH after the call.
xfhfcd3.cpy is in the "copy" folder of the GnuCOBOL installation.

Example:

 IDENTIFICATION DIVISION.
 PROGRAM-ID. PGMEXTFH.
 DATA DIVISION.
 LINKAGE SECTION.
 01  OPCODE PIC XX.
 01  FCD.
     COPY "xfhfcd3.cpy".
 PROCEDURE DIVISION USING OPCODE FCD.
*> move ... to OPCODE  <*
*> move ... to FCD parameters  <*
      CALL     "EXTFH" USING OPCODE FCD.
      GOBACK.

   The includes support for a callable EXTFH interface also provided by
several compilers including Micro Focus.  This allows users to insert an
external file handler while retaining all of the normal COBOL I/O
functions with a possible callback to libcob.  To have the compiled
program call 'yourfh()' for file I/O use: 'cobc -fcallfh=yourfh' In turn
'yourfh()' may call 'EXTFH()' to use I/O functions from GnuCOBOL. The
external file handler can also be directly invoked from COBOL, too,
using 'CALL "EXTFH"'. ** Note: Not all flags contained in the FCD3 are
handled currently.  **

   See the file NEWS for more details as implementation varies between
compiler versions.



File: gnucobpr.info,  Node: SYSTEM,  Next: X"91",  Prev: EXTFH,  Up: Built-In System Subroutines

8.2.61 SYSTEM
-------------

                   SYSTEM Built-In Subroutine Syntax
=======================================================================

 CALL "SYSTEM" USING command
 ~~~~          ~~~~~


=======================================================================
   This subroutine submits COMMAND (an alphanumeric literal or data
item) to a command shell for execution as if it were typed into a
console/terminal window.

   A shell will be opened subordinate to the GnuCOBOL program issuing
the call to ‘SYSTEM’.

   Output from the command (if any) will appear in the command window in
which the GnuCOBOL program was executed.

   On a Unix system, the shell environment will be established using the
default shell program.  This is also true when using a GnuCOBOL build
created with and for OSX or the Cygwin Unix emulator.

   With native Windows Windows/MinGW builds, the shell environment will
be the Windows console window command processor (usually ‘cmd.exe’)
appropriate for the version of Windows you're using.

   To trap output from the executed command and process it within the
GnuCOBOL program, use a redirection (‘>’) to send the command output to
a temporary file which you read from within the program once control
returns.

   The exit status of the executed command will be available in the
‘RETURN-CODE’ special-register.



File: gnucobpr.info,  Node: X"91",  Next: X"E4",  Prev: SYSTEM,  Up: Built-In System Subroutines

8.2.62 X"91"
------------

                   X"91" Built-In Subroutine Syntax
=======================================================================

 CALL X"91" USING return-code, function-code, binary-variable-arg
 ~~~~       ~~~~~


=======================================================================
   The original Micro Focus version of this routine is capable of
providing a wide variety of functions.  GnuCOBOL supports just three of
them but more on the way subject to version of compiler (see file NEWS):
   • Turning runtime switches (‘SWITCH-1’, ... , ‘SWITCH-8’) on.

   • Turning runtime switches (‘SWITCH-1’, ... , ‘SWITCH-8’) off.

   • Retrieving the number of arguments passed to a subroutine.

   The RETURN-CODE argument must be a one-byte binary numeric data item
(‘USAGE BINARY-CHAR’ is recommended).  It will receive a value of 0 if
the operation was successful, 1 otherwise.

   The FUNCTION-CODE argument must be either a numeric literal or a
one-byte binary numeric data item (‘USAGE BINARY-CHAR’ is recommended).

   The third argument -- VARIABLE-ARG -- is defined differently
depending upon the FUNCTION-CODE value, as follows:

11
     Sets and/or clears all eight of the COBOL switches (‘SWITCH-1’
     through ‘SWITCH-8’).  *Note SPECIAL-NAMES::, for an explanation of
     those switches.  Also referred to as programmable 0 - 7.

     The VARIABLE-ARG argument should be an ‘OCCURS 8 TIMES’ table of
     ‘USAGE BINARY-CHAR’.

     Each occurrence that is set to a value of zero prior to the ‘CALL
     X"91"’ will cause the corresponding switch to be cleared.  Each
     occurrence set to 1 prior to the ‘CALL X"91"’ will cause the
     corresponding switch to be set.

     Values other than 0 or 1 will be ignored.

12
     Reads all eight of the COBOL switches (‘SWITCH-1’ through
     ‘SWITCH-8’) and debug switches as prorammable 0 - 7.

     The VARIABLE-ARG argument should be an ‘OCCURS 8 TIMES’ table of
     ‘USAGE BINARY-CHAR’.

     Each of the 1^{st} eight occurrences of the array will be set to
     either 0 or 1 -- 1 if the corresponding switch is set, 0 otherwise.

13 + 14
     Allow access to runtime switches 1 - 26 as A-Z. In case of A.N.T:
     set related runtime setting.  Option 13 read them and option 14
     sets them.

15
     Prepare for program lookup.  Checks to see if a program exists.
     You pass the program name and its length in parameter.  When
     routine exits, result is zero if found and non-zero if not.
     Parameter is a group item consisting of two data items: a PIC X
     COMP-X specifyinh length in bytes of data item containing the file
     name and PIC X data item of varaiable length containing the file
     name.

16
     Retrieves the number of arguments passed to the program executing
     the ‘CALL X"91"’, saving that number into the VARIABLE-ARG
     argument.  That should be a binary numeric data item (‘USAGE
     BINARY-CHAR’ is recommended).

35
     Prepare for DOS EXEC call.

46-49
     Prepare for file specific settings LS_NULLS/LS_TABS.

69
     Prepare for directory search.



File: gnucobpr.info,  Node: X"E4",  Next: X"E5",  Prev: X"91",  Up: Built-In System Subroutines

8.2.63 X"E4"
------------

                   X"E4" Built-In Subroutine Syntax
=======================================================================

 CALL X"E4"
 ~~~~


=======================================================================
   Use ‘X"E4"’ to clear the screen.  There are no arguments and no
returned value.


File: gnucobpr.info,  Node: X"E5",  Next: X"F4",  Prev: X"E4",  Up: Built-In System Subroutines

8.2.64 X"E5"
------------

                   X"E5" Built-In Subroutine Syntax
=======================================================================

 CALL X"E5"
 ~~~~


=======================================================================
   The ‘X"E5"’ routine will sound the PC "bell".  There are no arguments
and no returned value.


File: gnucobpr.info,  Node: X"F4",  Next: X"F5",  Prev: X"E5",  Up: Built-In System Subroutines

8.2.65 X"F4"
------------

                   X"F4" Built-In Subroutine Syntax
=======================================================================

 CALL X"F4" USING byte, table
 ~~~~       ~~~~~


=======================================================================
   This routine packs the low-order (rightmost) bit from each of the
eight 1-byte items in TABLE into the corresponding bit positions of the
single-byte data item BYTE.

   The BYTE data item need be only a single byte in size.  If it is
longer, the excess will be unaffected by this subroutine.

   The TABLE data item must be at least 8 bytes long.  If it is longer,
the excess will be ignored by this subroutine.

   Typically, table is defined similarly to the following:

     01  Table-Arg.
         05 Each-Byte OCCURS 8 TIMES USAGE BINARY-CHAR.


File: gnucobpr.info,  Node: X"F5",  Prev: X"F4",  Up: Built-In System Subroutines

8.2.66 X"F5"
------------

                   X"F5" Built-In Subroutine Syntax
=======================================================================

 CALL X"F5" USING byte, table
 ~~~~       ~~~~~


=======================================================================
   This routine unpacks each bit of the single-byte data item BYTE into
the low-order (rightmost) bit of each of the corresponding eight 1-byte
items in TABLE.  The other seven bit positions of each of the first
eight entries in TABLE will be set to zero.

   The BYTE data item need be only a single byte in size.  If it is
longer, the excess will be unaffected by this subroutine.

   The TABLE data item must be at least 8 bytes long.  If it is longer,
the excess will be ignored by this subroutine.

   Typically, table is defined similarly to the following:

     01  Table-Arg.
         05 Each-Byte OCCURS 8 TIMES USAGE BINARY-CHAR.



File: gnucobpr.info,  Node: Report Writer Usage,  Next: Interfacing With The OS,  Prev: Functions,  Up: Top

9 Report Writer Usage
*********************

* Menu:

* RWCS Lexicon.
* The Anatomy of a Report.
* The Anatomy of a Report Page.
* How RWCS Builds Report Pages.
* Control Hierarchy.
* An Example.
* Data.
* Program.
* Generated Report Pages.
* Control Hierarchy (Revisited).
* Turning PHYSICAL Page Formatting Into LOGICAL Formatting.


File: gnucobpr.info,  Node: RWCS Lexicon,  Next: The Anatomy of a Report,  Up: Report Writer Usage

9.1 RWCS Lexicon
================

There are a number of terms that describe various aspects of the
operation of the Report Writer Control System (RWCS). Understanding the
meanings of these terms is vital to developing an understanding of the
subject.
Control Break
     An event that is triggered when a control field on an
     RWCS-generated report changes value.  It is these events that
     trigger the generation of control heading and control footing
     groups.

Control Field
     A field of data being presented within a detail group; as the
     various detail groups that comprise the report are presented, they
     are presumed to appear in sorted sequence of the control fields
     contained within them.  As an example, a department-by-department
     sales report for a chain of stores would probably be sorted by
     store number and - within like store numbers - be further sorted by
     department number.  The store number will undoubtedly serve as a
     control field for the report, allowing control heading groups to be
     presented before each sequence of detail groups for the same store
     and control footing groups to be presented after each such
     sequence.

Control Footing
     A report group that appears immediately after one or more detail
     groups of an RWCS-generated report.  Such are produced
     automatically as a result of a control break.  This type of group
     typically serves as a summary of the detail group(s) that precede
     it, as might be the case on a sales report for a chain of stores,
     where the detail groups documenting sales for each department (one
     department per detail group) from the same store might be followed
     by a control footing that provides a summation of the
     department-by-department sales for that store.

Control Heading
     A report group that appears immediately before one or more detail
     groups of an RWCS-generated report.  Such are produced
     automatically as a result of a control break.  This type of group
     typically serves as an introduction to the detail group(s) that
     follow, as might be the case on a sales report for a chain of
     stores, where the detail groups documenting sales for each
     department (one department per detail group) from the same store
     might be preceded by a control heading that states the full name
     and location of the store.

Detail Group
     A report group that contains the detailed data being presented for
     the report.

Page Footing
     A report group that appears at the bottom of every page of an
     RWCS-generated report.  Information typically found within such a
     report group might be:
        • The date the report was generated
        • The current page number of the report
Page Heading
     A report group that appears at the top of every page of an
     RWCS-generated report.  Information typically found within such a
     report group might be:
        • A title for the report
        • The date the report was generated
        • The current page number of the report
        • Column headings describing the fields within the detail
          group(s)
Report Footing
     A report group that occurs only once in an RWCS-generated report --
     as the very last presented report group of the report.  These
     typically serve as a visual indication that the report is finished.

Report Group
     One or more consecutive lines on a report that serve a common
     informational purpose or function.  For example, lines of text that
     are displayed at the top or bottom of every printed page of a
     report.

Report Heading
     A report group that occurs only once in an RWCS-generated report --
     as the very first presented report group of the report.  These
     typically serve as an introduction to the report.


File: gnucobpr.info,  Node: The Anatomy of a Report,  Next: The Anatomy of a Report Page,  Prev: RWCS Lexicon,  Up: Report Writer Usage

9.2 The Anatomy of a Report
===========================

Every report has the same basic structure, as shown here, even though
not all reports will have all of the groups shown.  In fact, it is a
very unusual report indeed that actually has every one of these groups:
   • REPORT HEADING
   • PAGE HEADING [1]
   • CONTROL HEADING(S) [2]
   • DETAIL GROUP(S) [2]
   • CONTROL FOOTING(S) [2]
   • FINAL CONTROL FOOTING
   • PAGE FOOTING [1]
   • REPORT FOOTING
[1]  Presented throughout the report, as needed
[2]  Repeated, as needed

   These groups will be presented (printed) across however many
formatted pages are necessary to hold them.  No single report group will
be allowed to cross page boundaries.

   The management of paging, enforcement of the groups cannot span pages
rule and almost every aspect of report generation are handled entirely
by the Report Writer Control System.


File: gnucobpr.info,  Node: The Anatomy of a Report Page,  Next: How RWCS Builds Report Pages,  Prev: The Anatomy of a Report,  Up: Report Writer Usage

9.3 The Anatomy of a Report Page
================================

Each page of a report is divided into as many as five (5) areas, as
shown in the following diagram.

  _______________________________
 |                               |
 | Top-of-page Unusable Area     |--# Lines: LINES AT TOP (LINAGE)
 |_______________________________|
 |                               |--Line #: HEADING (RD)
 | Heading Area                  |
 |_______________________________|--Line #: FIRST DETAIL (RD) - 1
 |                               |--Line #: FIRST DETAIL (RD)
 |                               |
 | Body Area                     |--Line #: LAST CONTROL HEADING (RD)
 |                               |--Line #: LAST DETAIL (RD)
 |_______________________________|--Line #: FOOTING (RD)
 |                               |--Line #: FOOTING (RD) + 1
 | Footing Area                  |
 |_______________________________|
 |                               |
 | Bottom-of-page Unusable Area  |--# Lines: LINES AT BOTTOM (LINAGE)
 |_______________________________|

   When describing a report via the ‘RD’ (*note REPORT SECTION::)
clause, the total number of usable lines are specified as the ‘PAGE
LIMIT’ value; this value is the sum of the number of lines contained in
the Heading, Body and Footing Areas.

   The unusable areas of a page (if any) will appear above and below
that usable area.  You don't specify the unusable area in the ‘RD’, but
rather using a ‘LINAGE’ (*note File/Sort-Description::) clause in the
‘FD’ of the file the report is "attached" to.

   The various report groups will be presentable in the various areas of
a page, as follows:
‘REPORT HEADING’
     Heading Area -- An exception to this is the situation where the
     report heading report group contains the ‘NEXT GROUP NEXT PAGE’
     (*note NEXT GROUP::) option; in those cases, the report heading
     will be presented on a page by itself (anywhere on that page) at
     the beginning of the report.

‘PAGE HEADING’
     Heading Area

‘CONTROL HEADING’
     Body Area, but no line of a control heading is allowed past the
     line number specified by ‘LAST CONTROL HEADING’

‘DETAIL’
     Body Area, but no line of a detail report group is allowed past the
     line number specified by ‘LAST DETAIL’

‘CONTROL FOOTING’
     Body Area, but no line of a control footing report group is allowed
     past the line number specified by ‘FOOTING’

‘PAGE FOOTING’
     Footing Area

‘REPORT FOOTING’
     Footing Area -- An exception to this is the situation where the
     report footing report group contains the ‘NEXT PAGE’ option in its
     ‘LINE’ (*note LINE::) clause; in those cases, the report footing
     will be presented on a page by itself at the end of the report.


File: gnucobpr.info,  Node: How RWCS Builds Report Pages,  Next: Control Hierarchy,  Prev: The Anatomy of a Report Page,  Up: Report Writer Usage

9.4 How RWCS Builds Report Pages
================================

A report created via a ‘WRITE’ statement (*note WRITE::) will contain
carriage-control information.  Most notably, ASCII form-feed characters
(X'0C') will be written to the report file to support the statement's
‘ADVANCING PAGE’ option.  Whether the data for a report line created via
‘ADVANCING PAGE’ occurs before or after the form-feed character depends
upon whether the programmer coded ‘WRITE RECORD-NAME BEFORE ADVANCING
PAGE’ or ‘WRITE RECORD-NAME AFTER ADVANCING PAGE’, respectively.

   The GnuCOBOL implementation of RWCS does not issue any
carriage-control information to the report files it produces -- instead,
it relies upon the information coded in the ‘RD’ for the report
(specifically the ‘PAGE LIMITS’ and related options) and its
internally-generated and managed ‘LINE-COUNTER’ special register (*note
Special Registers::) for the report to know when to issue any blank
lines to the file to fill-out the end of a printed page.

   Because this is the way the GnuCOBOL RWCS works, in order to design
an RWCS-generated report you'll need to know answers to the following
questions:
  1. What printer(s) will the report be printed on?

  2. What paper orientation will you use, -- Landscape (long edge of the
     paper at the top and bottom of page), or Portrait (long edge of the
     paper at the left and right of page)?

  3. What tool will be used to print the report (direct printing to the
     device, notepad.exe, MS-Word, ...)?

  4. What font and font size will be used for the report when it is
     printed?  RWCS-generated reports will assume that a fixed-width
     font such as "Courier", "Lucida Console", "Consolas" and the like
     will be used to print, as variable-pitch fonts would make the
     proper alignment of columns of data on reports virtually
     impossible.

  5. When unprintable area exists at all four margins of the paper?
     These are generally caused by the printer itself or by its software
     driver.

  6. What is the maximum number of lines per page that may be printed on
     a single sheet of paper?

  7. What is the maximum number of characters that may be printed on one
     line?

   Once you know the answer to questions 1-4, you may easily determine
the answers to the remaining questions as follows:
  1. Prepare a text file containing 100 or so records, each consisting
     of a numeric scale (‘123456789012345678901234’...).

  2. Print the file in a manner consistent with your answers to
     questions 1-4.

  3. Add any necessary additional digits to each record in your test
     file (if lines weren't full) or remove characters from the end of
     each record if lines wrapped.  If you made changes, reprint the
     file.

  4. Now that you know exactly how long each record may be, add
     additional records and reprint.  Continue until printing overflows
     to a second page.

  5. The first page you print is now a perfect template to use when
     designing reports -- it shows, given the answers to questions 1-4,
     every available printable character position on a page!  The number
     of lines printed on that page becomes your ‘PAGE LIMIT’ value for
     the ‘RD’.

   The remaining ‘PAGE LIMIT’ values can be established as required by
your report(s).

   Using IDENTIFIER rather than INTEGER specifications in the ‘RD’ will
give your program the ability -- at run time -- to accommodate multiple
printers, fonts, font sizes and paper orientation.  Just follow the
above steps for each combination you wish your program to support.


File: gnucobpr.info,  Node: Control Hierarchy,  Next: An Example,  Prev: How RWCS Builds Report Pages,  Up: Report Writer Usage

9.5 Control Hierarchy
=====================

Every report that employs control breaks has a natural hierarchy of
those control breaks based upon the manner in which the data the report
is being generated from is sorted.  This concept is best understood
using an example which assumes a COBOL program to process sales data
collected from every computerized cash register across a chain of stores
having multiple departments is being developed.

   The application that collects data from the various cash registers at
each store will generate data records that look like this to a COBOL
program:

     01  Sales-For-Register.
         05 Sales-Date            PIC 9(8).
         05 Time-Collected        PIC 9(6).
         05 Register-Number       PIC 9(7).
         05 Store-Number          PIC 9(3).
         05 Department-Number     PIC 9(3).
         05 Total-Sales           PIC 9(6)V99.

   Your task is to develop a report that shows the sales total from each
cash register and summarizes those sales by department within each
store, by store and also generates a total sales figure for the day
across all stores.

   To accomplish this, you will use a ‘SORT’ statement (*note SORT::) to
sort the file of cash register sales data into:
  1. Ascending sequence of store number
  2. Within each store, data will be sorted into ascending sequence of
     department number
  3. If there are multiple cash registers in a particular department of
     a specific store, the data needs to be further sorted so that the
     cash registers are ordered in sequence of their register number.

   So, assuming a sort file has been defined and its record layout
(essentially a mirror of the raw data file) is defined as follows:

     01  Sorted-Sales-For-Register.
         05 Sorted-Sales-Date            PIC 9(8).
         05 Sorted-Time-Collected        PIC 9(6).
         05 Sorted-Register-Number       PIC 9(7).
         05 Sorted-Store-Number          PIC 9(3).
         05 Sorted-Department-Number     PIC 9(3).
         05 Sorted-Total-Sales           PIC 9(6)V99.

   Then the ‘SORT’ statement to accomplish the desired sequencing would
be:

     SORT SORT-FILE
         ASCENDING KEY Sorted-Store-Number
                       Sorted-Department-Number
                       Sorted-Register-Number
         USING Input-file
         OUTPUT PROCEDURE 100-Generate-Report

   As a result of the sort, our program might expect to see data
somewhat like this (date, time and sales totals are shown as "..."):

        +-------------------- Register Number
        |      +------------- Store Number
        |      |  +---------- Department Number
        |      |  |
     ...0535240001001...
     ...0589130001001...
     ...0625174001001...
     ...0122234001002...
     ...0732345001002...
     ...0003423001003...
     ...2038774001004...
     ...0112646002001...
     ...9963348002002...
     ...3245677002003...
     ...4456778002003...
     ...0002345002004...

   Because of the sort, the most-frequently changing value of the three
sort keys will be that of ‘Sorted-Register-Number’.  This essentially
defines the "detail" level of the report.

   The next most-frequently changing value is that of
‘Sorted-Department-Number’, and the least-frequently changing value is
that of ‘Sorted-Store-Number’.  remember that the program should be
generating totals each time one of these two values change, plus a grand
total of sales at the end of the report.  These three points are the
“Control Break” points of the report.

   When the report is defined, it's ‘RD’ would contain a ‘CONTROLS ARE’
clause that lists the control breaks in least- to most-frequent sequence
of changing.  This would be coded as:

   ‘CONTROLS ARE FINAL, Sorted-Store-Number, Sorted-Department-Number’

   A ‘FINAL’ control break only occurs once, at the very end of the
report.  The ‘CONTROL FOOTING’ for this break will be the one that
produces the grand total of sales for all stores.

   The next break listed on the ‘CONTROLS’ clause will be the one that
occurs next most-frequently (‘Sorted-Store-Number’).  This control break
will be the one that produces the summation for each entire store, and
will have its own ‘CONTROL FOOTING’.

   The next (and last, in this case) break listed on the ‘CONTROLS’
clause will be the one that occurs even more frequently
(‘Sorted-Department-Number’).  The ‘CONTROL FOOTING’ for this control
field will be the one that summarizes sales for each department within a
store.

   This sequence of control breaks from least- to most-frequent (in
other words, in the order they occur on the ‘CONTROLS ARE’ clause) is
the 'control hierarchy' of the report; control breaks that occur more
frequently than others are said to be at a lower level in the control
hierarchy.

   Defining a control hierarchy (via ‘CONTROLS ARE’) that does not match
the actual sequence in which data will be processed is a great way to
guarantee a "broken" report.  I'll show you an example in a later
section.


File: gnucobpr.info,  Node: An Example,  Next: Control Hierarchy (Revisited),  Prev: Control Hierarchy,  Up: Report Writer Usage

9.6 An Example
==============

This section contains an example of the RWCS at work.  The complete
program, presented here, is a stripped-down version of a program I have
used to generate a report for a class I teach on PC hardware.  This
report will provide benchmark statistics on a variety of popular AMD and
Intel CPUs.  The data for the report was obtained from the website
<www.cpubenchmark.net> in December of 2013.  By the time you are reading
this, that data will most likely have become rather out of date, but it
illustrates RWCS well enough.
* Menu:

* Data.
* Program.
* Generated Report Pages.


File: gnucobpr.info,  Node: Data,  Next: Program,  Up: An Example

9.6.1 Data
----------

Here is the data that the program will be reading.  Each record reflects
the aggregated benchmark scoring for one particular CPU, as scores for
benchmarks against that CPU have been reported to the <cpubenchmark.net>
website by their PassMark benchmark software.  The data consists of four
fields.  Fields are separated from one another by a single comma.  The
descriptions of the fields are as follows:
Benchmark Score
     A five-digit number showing the aggregated benchmark scores for the
     CPU; the higher this number, the better the CPU performed in
     benchmark testing.

Vendor
     The name of the vendor who makes the CPU. In this data, that will
     either be "AMD" (American Micro Devices) or "INTEL".

Family
     The 7-character family of CPU products the CPU falls into.  This
     will have values such as "A4", "A10", "Core i5", "Core i7", etc.

Model
     The specific model of CPU within the family.

   The first record of data shown below shows that the aggregated score
of all benchmarks reported for the AMD A10-4600M CPU is 3145, as
compared to the second record which shows that the aggregated score
reported of all benchmarks reported for the Intel Core-i7-4960X CPU is
14291.

   The following is the complete set of input data used for this
example.  This is by no means the complete set of data available at
<cpubenchmark.net> -- it is just a representative sample used for this
example.  For my class, I give my students a report showing the results
for almost a thousand CPUs.

   For the sake of brevity, this document lists the data in three
columns.

03145,AMD,A10,4600M            05421,AMD,FX,6100              03917,Intel,Core i5,4300U
14291,Intel,Core i7,4960X      05813,AMD,FX,6120              01743,Intel,Core i5,4300Y
02505,AMD,A10,4655M            06194,AMD,FX,6200              04804,Intel,Core i5,4330M
03449,AMD,A10,4657M            06388,AMD,FX,6300              03604,Intel,Core i5,4350U
04251,AMD,A10,5700             07017,AMD,FX,6350              06282,Intel,Core i5,4430
02758,AMD,A10,5745M            06163,AMD,FX,8100              05954,Intel,Core i5,4430S
03332,AMD,A10,5750M            06605,AMD,FX,8120              06517,Intel,Core i5,4440
03253,AMD,A10,5757M            06845,AMD,FX,8140              07061,Intel,Core i5,4570
04798,AMD,A10,5800B            07719,AMD,FX,8150              06474,Intel,Core i5,4570R
04677,AMD,A10,5800K            08131,AMD,FX,8320              06803,Intel,Core i5,4570S
04767,AMD,A10,6700             09067,AMD,FX,8350              02503,Intel,Core i5,4570T
05062,AMD,A10,6800K            09807,AMD,FX,9370              07492,Intel,Core i5,4670
00677,AMD,A4,1200              10479,AMD,FX,9590              07565,Intel,Core i5,4670K
00559,AMD,A4,1250              03076,Intel,Core i3,3110M      06351,Intel,Core i5,4670T
01583,AMD,A4,3300              03301,Intel,Core i3,3120M      03701,Intel,Core i7,3517U
01237,AMD,A4,3300M             03655,Intel,Core i3,3130M      03449,Intel,Core i7,3517UE
01227,AMD,A4,3305M             03820,Intel,Core i3,3210       04588,Intel,Core i7,3520M
01263,AMD,A4,3310MX            02266,Intel,Core i3,3217U      03912,Intel,Core i7,3537U
01193,AMD,A4,3320M             04219,Intel,Core i3,3220       04861,Intel,Core i7,3540M
01343,AMD,A4,3330MX            03724,Intel,Core i3,3220T      04009,Intel,Core i7,3555LE
01625,AMD,A4,3400              04407,Intel,Core i3,3225       06144,Intel,Core i7,3610QE
01768,AMD,A4,3420              02575,Intel,Core i3,3227U      07532,Intel,Core i7,3610QM
01685,AMD,A4,4300M             01885,Intel,Core i3,3229Y      06988,Intel,Core i7,3612QE
01169,AMD,A4,4355M             04259,Intel,Core i3,3240       06907,Intel,Core i7,3612QM
01919,AMD,A4,5000              03793,Intel,Core i3,3240T      05495,Intel,Core i7,3615QE
01973,AMD,A4,5150M             04414,Intel,Core i3,3245       07310,Intel,Core i7,3615QM
02078,AMD,A4,5300              04757,Intel,Core i3,3250       07759,Intel,Core i7,3630QM
01632,AMD,A4,5300B             03443,Intel,Core i3,4000M      07055,Intel,Core i7,3632QM
02305,AMD,A4,6300              02459,Intel,Core i3,4010U      06516,Intel,Core i7,3635QM
01634,AMD,A6,1450              02003,Intel,Core i3,4010Y      04032,Intel,Core i7,3667U
01964,AMD,A6,3400M             04904,Intel,Core i3,4130       04271,Intel,Core i7,3687U
02101,AMD,A6,3410MX            04041,Intel,Core i3,4130T      03479,Intel,Core i7,3689Y
02078,AMD,A6,3420M             05115,Intel,Core i3,4330       08347,Intel,Core i7,3720QM
02277,AMD,A6,3430MX            05117,Intel,Core i3,4340       08512,Intel,Core i7,3740QM
01995,AMD,A6,3500              03807,Intel,Core i5,3210M      09420,Intel,Core i7,3770
02798,AMD,A6,3600              03995,Intel,Core i5,3230M      09578,Intel,Core i7,3770K
02892,AMD,A6,3620              03126,Intel,Core i5,3317U      09074,Intel,Core i7,3770S
03232,AMD,A6,3650              04101,Intel,Core i5,3320M      08280,Intel,Core i7,3770T
03327,AMD,A6,3670              05902,Intel,Core i5,3330       08995,Intel,Core i7,3820
01630,AMD,A6,4400M             05690,Intel,Core i5,3330S      08548,Intel,Core i7,3820QM
01296,AMD,A6,4455M             05781,Intel,Core i5,3335S      09025,Intel,Core i7,3840QM
02440,AMD,A6,5200              03280,Intel,Core i5,3337U      09196,Intel,Core i7,3920XM
01958,AMD,A6,5350M             02252,Intel,Core i5,3339Y      12107,Intel,Core i7,3930K
01878,AMD,A6,5357M             06282,Intel,Core i5,3340       09052,Intel,Core i7,3940XM
01906,AMD,A6,5400B             04327,Intel,Core i5,3340M      12718,Intel,Core i7,3960X
02174,AMD,A6,5400K             05372,Intel,Core i5,3340S      12823,Intel,Core i7,3970X
02384,AMD,A6,6400K             06199,Intel,Core i5,3350P      03992,Intel,Core i7,4500U
02050,AMD,A8,3500M             04314,Intel,Core i5,3360M      04507,Intel,Core i7,4558U
02426,AMD,A8,3510MX            04555,Intel,Core i5,3380M      04892,Intel,Core i7,4600M
02245,AMD,A8,3520M             03589,Intel,Core i5,3427U      04484,Intel,Core i7,4600U
02276,AMD,A8,3530MX            03479,Intel,Core i5,3437U      03680,Intel,Core i7,4610Y
02866,AMD,A8,3550MX            03057,Intel,Core i5,3439Y      04345,Intel,Core i7,4650U
03215,AMD,A8,3800              06442,Intel,Core i5,3450       07352,Intel,Core i7,4700EQ
03217,AMD,A8,3820              06071,Intel,Core i5,3450S      08161,Intel,Core i7,4700HQ
03552,AMD,A8,3850              06576,Intel,Core i5,3470       07946,Intel,Core i7,4700MQ
03682,AMD,A8,3870K             06077,Intel,Core i5,3470S      08002,Intel,Core i7,4702HQ
02709,AMD,A8,4500M             04591,Intel,Core i5,3470T      07647,Intel,Core i7,4702MQ
02193,AMD,A8,4555M             05991,Intel,Core i5,3475S      08066,Intel,Core i7,4750HQ
04052,AMD,A8,5500              06828,Intel,Core i5,3550       07367,Intel,Core i7,4765T
03464,AMD,A8,5500B             06631,Intel,Core i5,3550S      09969,Intel,Core i7,4770
02434,AMD,A8,5545M             06993,Intel,Core i5,3570       10190,Intel,Core i7,4770K
03052,AMD,A8,5550M             07118,Intel,Core i5,3570K      09803,Intel,Core i7,4770S
02935,AMD,A8,5557M             06709,Intel,Core i5,3570S      08803,Intel,Core i7,4770T
04348,AMD,A8,5600K             05414,Intel,Core i5,3570T      10078,Intel,Core i7,4771
04390,AMD,A8,6500              04333,Intel,Core i5,4200M      08567,Intel,Core i7,4800MQ
04719,AMD,A8,6600K             03355,Intel,Core i5,4200U      09969,Intel,Core i7,4820K
04055,AMD,FX,4100              02358,Intel,Core i5,4200Y      09331,Intel,Core i7,4850HQ
04153,AMD,FX,4130              02382,Intel,Core i5,4210Y      09323,Intel,Core i7,4900MQ
04094,AMD,FX,4150              03482,Intel,Core i5,4250U      13620,Intel,Core i7,4930K
04774,AMD,FX,4170              04381,Intel,Core i5,4258U      09754,Intel,Core i7,4930MX
04711,AMD,FX,4300              04663,Intel,Core i5,4288U      10262,Intel,Core i7,4960HQ
05247,AMD,FX,4350              04786,Intel,Core i5,4300M


File: gnucobpr.info,  Node: Program,  Next: Generated Report Pages,  Prev: Data,  Up: An Example

9.6.2 Program
-------------

Here is the program that will be producing the report.  Pay attention to
how the data is sorted and how the control hierarchy (‘CONTROLS ARE’)
relates to the ‘SORT’.

     IDENTIFICATION DIVISION.
     PROGRAM-ID. DEMORWCS.
     ENVIRONMENT DIVISION.
     CONFIGURATION SECTION.
     REPOSITORY. FUNCTION ALL INTRINSIC.
     INPUT-OUTPUT SECTION.
     FILE-CONTROL.
         SELECT CPU-FILE             ASSIGN TO "CPUDATA.txt"
                                     LINE SEQUENTIAL.
         SELECT REPORT-FILE          ASSIGN TO "CPUREPORT.txt"
                                     LINE SEQUENTIAL.
         SELECT SORT-FILE            ASSIGN TO DISK.
     DATA DIVISION.
     FILE SECTION.
     FD  CPU-FILE.
     01  CPU-REC                     PIC X(26).

     FD  REPORT-FILE
         REPORT IS CPU-Report.

     SD  SORT-FILE.
     01  SORT-REC.
         05 F-SR-Score-NUM           PIC 9(5).
         05 F-SR-Vendor-TXT          PIC X(5).
         05 F-SR-Family-TXT          PIC X(7).
         05 F-SR-Model-TXT           PIC X(6).
     WORKING-STORAGE SECTION.
     01  WS-Date                     PIC 9(8).

     01  WS-Family-Counters.
         05 WS-FC-AVE                PIC 9(5)V99.
         05 WS-FC-Qty                BINARY-LONG.
         05 WS-FC-Total-NUM          BINARY-LONG.

     01  WS-Flags.
         05 WS-F-EOF                 PIC X(1).

     01  WS-One-Const                PIC 9 VALUE 1.

     01  WS-Overall-Counters.
         05 WS-OC-AVE                PIC 9(5)V99.
         05 WS-OC-Qty                BINARY-LONG.
         05 WS-OC-Total-NUM          BINARY-LONG.

     01  WS-Starz                    PIC X(44) VALUE ALL '*'.

     01  WS-Vendor-Counters.
         05 WS-VC-AVE                PIC 9(5)V99.
         05 WS-VC-Qty                BINARY-LONG.
         05 WS-VC-Total-NUM          BINARY-LONG.

     REPORT SECTION.
     RD  CPU-Report
         CONTROLS ARE FINAL
                      F-SR-Vendor-TXT
                      F-SR-Family-TXT

         PAGE LIMIT IS    36 LINES
             HEADING      1
             FIRST DETAIL 5
             LAST DETAIL  36.

     01  TYPE IS PAGE HEADING.
         05 LINE NUMBER PLUS 1.
            10 COL 1  SOURCE WS-Date                PIC 9999/99/99.
            10 COL 14 VALUE 'CPU Benchmark Scores'.
            10 COL 37 VALUE 'Page:'.
            10 COL 43 SOURCE PAGE-COUNTER           PIC Z9.
         05 LINE NUMBER PLUS 1.
            10 COL 1  SOURCE WS-Starz               PIC X(44).
         05 LINE NUMBER PLUS 1.
            10 COL 1  VALUE '**'.
            10 COL 6  VALUE 'All CPU Data From cpubenchmark.net'.
            10 COL 43 VALUE '**'.
         05 LINE NUMBER PLUS 1.
            10 COL 1  SOURCE WS-Starz               PIC X(44).

     01  TYPE CONTROL HEADING F-SR-Family-TXT.
         05 LINE NUMBER PLUS 1.
            10 COL 1  SOURCE F-SR-Vendor-TXT        PIC X(6).
            10 COL 8  SOURCE F-SR-Family-TXT        PIC X(7).
         05 LINE NUMBER PLUS 1.
            10 COL 1  VALUE 'Family'.
            10 COL 9  VALUE 'Model'.
            10 COL 16 VALUE 'Benchmark Score (High to Low)'.
         05 LINE NUMBER PLUS 1.
            10 COL 1  VALUE '======'.
            10 COL 9  VALUE '======'.
            10 COL 16 VALUE '============================='.

     01  Detail-Line TYPE IS DETAIL.
         05 LINE NUMBER PLUS 1.
            10 COL 1  SOURCE F-SR-Family-TXT PIC X(7) GROUP INDICATE.
            10 COL 9  PIC X(6)       SOURCE F-SR-Model-TXT.
            10 COL 16 PIC ZZZZ9      SOURCE F-SR-Score-NUM.

     01  End-Family TYPE IS CONTROL FOOTING F-SR-Family-TXT.
         05 LINE NUMBER PLUS 1.
            10 COL 9                 VALUE  'Ave...'.
            10 COL 16 PIC ZZZZ9.99   SOURCE WS-FC-AVE.
            10 COL 25                VALUE  '('.
            10 COL 26 PIC ZZ9        SUM    WS-One-Const.
            10 COL 30                VALUE  'Family CPUs)'.

     01  End-Vendor TYPE IS CONTROL FOOTING F-SR-Vendor-TXT.
         05 LINE NUMBER PLUS 1.
            10 COL 9                 VALUE  'Ave...'.
            10 COL 16 PIC ZZZZ9.99   SOURCE WS-VC-AVE.
            10 COL 25                VALUE  '('.
            10 COL 26 PIC ZZ9        SUM    WS-One-Const.
            10 COL 30                VALUE  'Vendor CPUs)'.

     01  End-Overall TYPE IS CONTROL FOOTING FINAL.
         05 LINE NUMBER PLUS 1.
            10 COL 9                 VALUE  'Ave...'.
            10 COL 16 PIC ZZZZ9.99   SOURCE WS-OC-AVE.
            10 COL 25                VALUE  '('.
            10 COL 26 PIC ZZ9        SUM    WS-One-Const.
            10 COL 30                VALUE  'CPUs)'.

     PROCEDURE DIVISION.
     DECLARATIVES.
     000-End-Family SECTION.
         USE BEFORE REPORTING End-Family.
     1.  IF WS-FC-Qty > 0
             COMPUTE WS-FC-AVE = WS-FC-Total-NUM / WS-FC-Qty
         ELSE
             MOVE 0 TO WS-FC-AVE
         END-IF
         MOVE 0 TO WS-FC-Qty
                   WS-FC-Total-NUM
         .
     000-End-Vendor SECTION.
         USE BEFORE REPORTING End-Vendor.
     1.  IF WS-VC-Qty > 0
             COMPUTE WS-VC-AVE = WS-VC-Total-NUM / WS-VC-Qty
         ELSE
             MOVE 0 TO WS-VC-AVE
         END-IF
         MOVE 0 TO WS-VC-Qty
                   WS-VC-Total-NUM
         .
     000-End-Overall SECTION.
         USE BEFORE REPORTING End-Overall.
     1.  IF WS-OC-Qty > 0
             COMPUTE WS-OC-AVE = WS-OC-Total-NUM / WS-OC-Qty
         ELSE
             MOVE 0 TO WS-OC-AVE
         END-IF
         MOVE 0 TO WS-OC-Qty
                   WS-OC-Total-NUM
         .
     END DECLARATIVES.

     010-Main SECTION.
     1.  ACCEPT WS-Date FROM DATE YYYYMMDD
         SORT SORT-FILE
             ASCENDING KEY    F-SR-Vendor-TXT
                              F-SR-Family-TXT
             DESCENDING KEY   F-SR-Score-NUM
             ASCENDING KEY    F-SR-Model-TXT
             INPUT PROCEDURE  100-Pre-Process-Data
             OUTPUT PROCEDURE 200-Generate-Report
         STOP RUN
         .
     100-Pre-Process-Data SECTION.
     1.  OPEN INPUT CPU-FILE
         PERFORM FOREVER
             READ CPU-FILE
             AT END
                 EXIT PERFORM
             END-READ
             MOVE SPACES TO SORT-REC
             UNSTRING CPU-REC DELIMITED BY ','
                 INTO F-SR-Score-NUM,
                      F-SR-Vendor-TXT,
                      F-SR-Family-TXT,
                      F-SR-Model-TXT
             RELEASE SORT-REC
         END-PERFORM
         CLOSE CPU-FILE
         .
     200-Generate-Report SECTION.
     1.  INITIALIZE WS-Family-Counters
                    WS-Flags
         OPEN OUTPUT REPORT-FILE
         INITIATE CPU-Report
         RETURN SORT-FILE
         AT END
             MOVE 'Y' TO WS-F-EOF
         END-RETURN
         PERFORM UNTIL WS-F-EOF = 'Y'
             GENERATE Detail-Line
             ADD 1              TO WS-FC-Qty
                                   WS-OC-Qty
                                   WS-VC-Qty
             ADD F-SR-Score-NUM TO WS-FC-Total-NUM
                                   WS-OC-Total-NUM
                                   WS-VC-Total-NUM
             RETURN SORT-FILE
             AT END
                 MOVE 'Y' TO WS-F-EOF
             END-RETURN
         END-PERFORM
         TERMINATE CPU-Report
         CLOSE REPORT-FILE
         .


File: gnucobpr.info,  Node: Generated Report Pages,  Prev: Program,  Up: An Example

9.6.3 Generated Report Pages
----------------------------

Finally, here's the report the program generates!

     2013/12/24   CPU Benchmark Scores   Page:  1
     ********************************************
     **   All CPU Data From cpubenchmark.net   **
     ********************************************
     AMD    A10
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     A10     6800K   5062
             5800B   4798
             6700    4767
             5800K   4677
             5700    4251
             4657M   3449
             5750M   3332
             5757M   3253
             4600M   3145
             5745M   2758
             4655M   2505
             Ave...  3817.90 ( 11 Family CPUs)
     AMD    A4
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     A4      6300    2305
             5300    2078
             5150M   1973
             5000    1919
             3420    1768
             4300M   1685
             5300B   1632
             3400    1625
             3300    1583
             3330MX  1343
             3310MX  1263
             3300M   1237
             3305M   1227
             3320M   1193
     ____________________________________________

     2013/12/24   CPU Benchmark Scores   Page:  2
     ********************************************
     **   All CPU Data From cpubenchmark.net   **
     ********************************************
     A4      4355M   1169
             1200     677
             1250     559
             Ave...  1484.47 ( 17 Family CPUs)
     AMD    A6
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     A6      3670    3327
             3650    3232
             3620    2892
             3600    2798
             5200    2440
             6400K   2384
             3430MX  2277
             5400K   2174
             3410MX  2101
             3420M   2078
             3500    1995
             3400M   1964
             5350M   1958
             5400B   1906
             5357M   1878
             1450    1634
             4400M   1630
             4455M   1296
             Ave...  2220.22 ( 18 Family CPUs)
     AMD    A8
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     A8      6600K   4719
             6500    4390
             5600K   4348
     ____________________________________________

     2013/12/24   CPU Benchmark Scores   Page:  3
     ********************************************
     **   All CPU Data From cpubenchmark.net   **
     ********************************************
     A8      5500    4052
             3870K   3682
             3850    3552
             5500B   3464
             3820    3217
             3800    3215
             5550M   3052
             5557M   2935
             3550MX  2866
             4500M   2709
             5545M   2434
             3510MX  2426
             3530MX  2276
             3520M   2245
             4555M   2193
             3500M   2050
             Ave...  3148.68 ( 19 Family CPUs)
     AMD    FX
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     FX      9590   10479
             9370    9807
             8350    9067
             8320    8131
             8150    7719
             6350    7017
             8140    6845
             8120    6605
             6300    6388
             6200    6194
             8100    6163
             6120    5813
     ____________________________________________

     2013/12/24   CPU Benchmark Scores   Page:  4
     ********************************************
     **   All CPU Data From cpubenchmark.net   **
     ********************************************
     FX      6100    5421
             4350    5247
             4170    4774
             4300    4711
             4130    4153
             4150    4094
             4100    4055
             Ave...  6457.00 ( 19 Family CPUs)
             Ave...  3448.86 ( 84 Vendor CPUs)
     Intel  Core i3
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     Core i3 4340    5117
             4330    5115
             4130    4904
             3250    4757
             3245    4414
             3225    4407
             3240    4259
             3220    4219
             4130T   4041
             3210    3820
             3240T   3793
             3220T   3724
             3130M   3655
             4000M   3443
             3120M   3301
             3110M   3076
             3227U   2575
             4010U   2459
             3217U   2266
             4010Y   2003
     ____________________________________________

     2013/12/24   CPU Benchmark Scores   Page:  5
     ********************************************
     **   All CPU Data From cpubenchmark.net   **
     ********************************************
     Core i3 3229Y   1885
             Ave...  3677.76 ( 21 Family CPUs)
     Intel  Core i5
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     Core i5 4670K   7565
             4670    7492
             3570K   7118
             4570    7061
             3570    6993
             3550    6828
             4570S   6803
             3570S   6709
             3550S   6631
             3470    6576
             4440    6517
             4570R   6474
             3450    6442
             4670T   6351
             3340    6282
             4430    6282
             3350P   6199
             3470S   6077
             3450S   6071
             3475S   5991
             4430S   5954
             3330    5902
             3335S   5781
             3330S   5690
             3570T   5414
             3340S   5372
             4330M   4804
     ____________________________________________

     2013/12/24   CPU Benchmark Scores   Page:  6
     ********************************************
     **   All CPU Data From cpubenchmark.net   **
     ********************************************
     Core i5 4300M   4786
             4288U   4663
             3470T   4591
             3380M   4555
             4258U   4381
             4200M   4333
             3340M   4327
             3360M   4314
             3320M   4101
             3230M   3995
             4300U   3917
             3210M   3807
             4350U   3604
             3427U   3589
             4250U   3482
             3437U   3479
             4200U   3355
             3337U   3280
             3317U   3126
             3439Y   3057
             4570T   2503
             4210Y   2382
             4200Y   2358
             3339Y   2252
             4300Y   1743
             Ave...  5026.13 ( 52 Family CPUs)
     Intel  Core i7
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     Core i7 4960X  14291
             4930K  13620
             3970X  12823
     ____________________________________________

     2013/12/24   CPU Benchmark Scores   Page:  7
     ********************************************
     **   All CPU Data From cpubenchmark.net   **
     ********************************************
     Core i7 3960X  12718
             3930K  12107
             4960HQ 10262
             4770K  10190
             4771   10078
             4770    9969
             4820K   9969
             4770S   9803
             4930MX  9754
             3770K   9578
             3770    9420
             4850HQ  9331
             4900MQ  9323
             3920XM  9196
             3770S   9074
             3940XM  9052
             3840QM  9025
             3820    8995
             4770T   8803
             4800MQ  8567
             3820QM  8548
             3740QM  8512
             3720QM  8347
             3770T   8280
             4700HQ  8161
             4750HQ  8066
             4702HQ  8002
             4700MQ  7946
             3630QM  7759
             4702MQ  7647
             3610QM  7532
             4765T   7367
     ____________________________________________

     2013/12/24   CPU Benchmark Scores   Page:  8
     ********************************************
     **   All CPU Data From cpubenchmark.net   **
     ********************************************
     Core i7 4700EQ  7352
             3615QM  7310
             3632QM  7055
             3612QE  6988
             3612QM  6907
             3635QM  6516
             3610QE  6144
             3615QE  5495
             4600M   4892
             3540M   4861
             3520M   4588
             4558U   4507
             4600U   4484
             4650U   4345
             3687U   4271
             3667U   4032
             3555LE  4009
             4500U   3992
             3537U   3912
             3517U   3701
             4610Y   3680
             3689Y   3479
             3517UE  3449
             Ave...  7725.58 ( 58 Family CPUs)
             Ave...  6005.16 (131 Vendor CPUs)
             Ave...  5006.42 (215 CPUs)





     ____________________________________________


File: gnucobpr.info,  Node: Control Hierarchy (Revisited),  Next: Turning PHYSICAL Page Formatting Into LOGICAL Formatting,  Prev: An Example,  Up: Report Writer Usage

9.7 Control Hierarchy (Revisited)
=================================

The sample program just discussed presents a great opportunity to show
what can happen if you don't define the control hierarchy of a report
properly.

   I changed the ‘CONTROLS ARE’ clause on the sample program from this:

     CONTROLS ARE FINAL
                  F-SR-Vendor-TXT
                  F-SR-Family-TXT

   To this:

     CONTROLS ARE FINAL
                  F-SR-Family-TXT
                  F-SR-Vendor-TXT

   And then ran the report again.  Here are the first two pages of that
new report.  See what happened to the control breaks?

     2013/12/24   CPU Benchmark Scores   Page:  1
     ********************************************
     **   All CPU Data From cpubenchmark.net   **
     ********************************************
     AMD    A10
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     A10     6800K   5062
             5800B   4798
             6700    4767
             5800K   4677
             5700    4251
             4657M   3449
             5750M   3332
             5757M   3253
             4600M   3145
             5745M   2758
             4655M   2505
             Ave...  3817.90 ( 11 Vendor CPUs)
             Ave...  3817.90 ( 11 Family CPUs)
     AMD    A4
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     A4      6300    2305
             5300    2078
             5150M   1973
             5000    1919
             3420    1768
             4300M   1685
             5300B   1632
             3400    1625
             3300    1583
             3330MX  1343
             3310MX  1263
             3300M   1237
             3305M   1227
     ____________________________________________

     2013/12/24   CPU Benchmark Scores   Page:  2
     ********************************************
     **   All CPU Data From cpubenchmark.net   **
     ********************************************
     A4      3320M   1193
             4355M   1169
             1200     677
             1250     559
             Ave...  1484.47 ( 17 Vendor CPUs)
             Ave...  1484.47 ( 17 Family CPUs)
     AMD    A6
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     A6      3670    3327
             3650    3232
             3620    2892
             3600    2798
             5200    2440
             6400K   2384
             3430MX  2277
             5400K   2174
             3410MX  2101
             3420M   2078
             3500    1995
             3400M   1964
             5350M   1958
             5400B   1906
             5357M   1878
             1450    1634
             4400M   1630
             4455M   1296
             Ave...  2220.22 ( 18 Vendor CPUs)
             Ave...  2220.22 ( 18 Family CPUs)
     AMD    A8
     Family  Model  Benchmark Score (High to Low)
     ======  ====== =============================
     A8      6600K   4719

     ____________________________________________

